//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Src\Espertech\NEsper-master\NEsper\grammar\EsperEPL2Grammar.g4 by ANTLR 4.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419


  using System;
  using System.Collections.Generic;

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6")]
[System.CLSCompliant(false)]
public partial class EsperEPL2GrammarParser : Parser {
	internal static DFA[] decisionToDFA;
	internal static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		CREATE=1, WINDOW=2, IN_SET=3, BETWEEN=4, LIKE=5, REGEXP=6, ESCAPE=7, OR_EXPR=8, 
		AND_EXPR=9, NOT_EXPR=10, EVERY_EXPR=11, EVERY_DISTINCT_EXPR=12, WHERE=13, 
		AS=14, SUM=15, AVG=16, MAX=17, MIN=18, COALESCE=19, MEDIAN=20, STDDEV=21, 
		AVEDEV=22, COUNT=23, SELECT=24, CASE=25, ELSE=26, WHEN=27, THEN=28, END=29, 
		FROM=30, OUTER=31, INNER=32, JOIN=33, LEFT=34, RIGHT=35, FULL=36, ON=37, 
		IS=38, BY=39, GROUP=40, HAVING=41, DISTINCT=42, ALL=43, ANY=44, SOME=45, 
		OUTPUT=46, EVENTS=47, FIRST=48, LAST=49, INSERT=50, INTO=51, VALUES=52, 
		ORDER=53, ASC=54, DESC=55, RSTREAM=56, ISTREAM=57, IRSTREAM=58, SCHEMA=59, 
		UNIDIRECTIONAL=60, RETAINUNION=61, RETAININTERSECTION=62, PATTERN=63, 
		SQL=64, METADATASQL=65, PREVIOUS=66, PREVIOUSTAIL=67, PREVIOUSCOUNT=68, 
		PREVIOUSWINDOW=69, PRIOR=70, EXISTS=71, WEEKDAY=72, LW=73, INSTANCEOF=74, 
		TYPEOF=75, CAST=76, CURRENT_TIMESTAMP=77, DELETE=78, SNAPSHOT=79, SET=80, 
		VARIABLE=81, TABLE=82, UNTIL=83, AT=84, INDEX=85, TIMEPERIOD_YEAR=86, 
		TIMEPERIOD_YEARS=87, TIMEPERIOD_MONTH=88, TIMEPERIOD_MONTHS=89, TIMEPERIOD_WEEK=90, 
		TIMEPERIOD_WEEKS=91, TIMEPERIOD_DAY=92, TIMEPERIOD_DAYS=93, TIMEPERIOD_HOUR=94, 
		TIMEPERIOD_HOURS=95, TIMEPERIOD_MINUTE=96, TIMEPERIOD_MINUTES=97, TIMEPERIOD_SEC=98, 
		TIMEPERIOD_SECOND=99, TIMEPERIOD_SECONDS=100, TIMEPERIOD_MILLISEC=101, 
		TIMEPERIOD_MILLISECOND=102, TIMEPERIOD_MILLISECONDS=103, TIMEPERIOD_MICROSEC=104, 
		TIMEPERIOD_MICROSECOND=105, TIMEPERIOD_MICROSECONDS=106, BOOLEAN_TRUE=107, 
		BOOLEAN_FALSE=108, VALUE_NULL=109, ROW_LIMIT_EXPR=110, OFFSET=111, UPDATE=112, 
		MATCH_RECOGNIZE=113, MATCH_RECOGNIZE_PERMUTE=114, MEASURES=115, DEFINE=116, 
		PARTITION=117, MATCHES=118, AFTER=119, FOR=120, WHILE=121, USING=122, 
		MERGE=123, MATCHED=124, EXPRESSIONDECL=125, NEWKW=126, START=127, CONTEXT=128, 
		INITIATED=129, TERMINATED=130, DATAFLOW=131, CUBE=132, ROLLUP=133, GROUPING=134, 
		GROUPING_ID=135, SETS=136, FOLLOWMAX_BEGIN=137, FOLLOWMAX_END=138, FOLLOWED_BY=139, 
		GOES=140, EQUALS=141, SQL_NE=142, QUESTION=143, LPAREN=144, RPAREN=145, 
		LBRACK=146, RBRACK=147, LCURLY=148, RCURLY=149, COLON=150, COMMA=151, 
		EQUAL=152, LNOT=153, BNOT=154, NOT_EQUAL=155, DIV=156, DIV_ASSIGN=157, 
		PLUS=158, PLUS_ASSIGN=159, INC=160, MINUS=161, MINUS_ASSIGN=162, DEC=163, 
		STAR=164, STAR_ASSIGN=165, MOD=166, MOD_ASSIGN=167, GE=168, GT=169, LE=170, 
		LT=171, BXOR=172, BXOR_ASSIGN=173, BOR=174, BOR_ASSIGN=175, LOR=176, BAND=177, 
		BAND_ASSIGN=178, LAND=179, SEMI=180, DOT=181, NUM_LONG=182, NUM_DOUBLE=183, 
		NUM_FLOAT=184, ESCAPECHAR=185, ESCAPEBACKTICK=186, ATCHAR=187, HASHCHAR=188, 
		WS=189, SL_COMMENT=190, ML_COMMENT=191, TICKED_STRING_LITERAL=192, QUOTED_STRING_LITERAL=193, 
		STRING_LITERAL=194, IDENT=195, IntegerLiteral=196, FloatingPointLiteral=197;
	public const int
		RULE_startPatternExpressionRule = 0, RULE_startEPLExpressionRule = 1, 
		RULE_startEventPropertyRule = 2, RULE_startJsonValueRule = 3, RULE_expressionDecl = 4, 
		RULE_expressionDialect = 5, RULE_expressionDef = 6, RULE_expressionLambdaDecl = 7, 
		RULE_expressionTypeAnno = 8, RULE_annotationEnum = 9, RULE_elementValuePairsEnum = 10, 
		RULE_elementValuePairEnum = 11, RULE_elementValueEnum = 12, RULE_elementValueArrayEnum = 13, 
		RULE_eplExpression = 14, RULE_contextExpr = 15, RULE_selectExpr = 16, 
		RULE_onExpr = 17, RULE_onStreamExpr = 18, RULE_updateExpr = 19, RULE_updateDetails = 20, 
		RULE_onMergeExpr = 21, RULE_mergeItem = 22, RULE_mergeMatched = 23, RULE_mergeMatchedItem = 24, 
		RULE_mergeUnmatched = 25, RULE_mergeUnmatchedItem = 26, RULE_mergeInsert = 27, 
		RULE_onSelectExpr = 28, RULE_onUpdateExpr = 29, RULE_onSelectInsertExpr = 30, 
		RULE_onSelectInsertFromClause = 31, RULE_outputClauseInsert = 32, RULE_onDeleteExpr = 33, 
		RULE_onSetExpr = 34, RULE_onSetAssignmentList = 35, RULE_onSetAssignment = 36, 
		RULE_onExprFrom = 37, RULE_createWindowExpr = 38, RULE_createWindowExprModelAfter = 39, 
		RULE_createIndexExpr = 40, RULE_createIndexColumnList = 41, RULE_createIndexColumn = 42, 
		RULE_createVariableExpr = 43, RULE_createTableExpr = 44, RULE_createTableColumnList = 45, 
		RULE_createTableColumn = 46, RULE_createTableColumnPlain = 47, RULE_createColumnList = 48, 
		RULE_createColumnListElement = 49, RULE_createSelectionList = 50, RULE_createSelectionListElement = 51, 
		RULE_createSchemaExpr = 52, RULE_createSchemaDef = 53, RULE_fafDelete = 54, 
		RULE_fafUpdate = 55, RULE_fafInsert = 56, RULE_createDataflow = 57, RULE_gopList = 58, 
		RULE_gop = 59, RULE_gopParams = 60, RULE_gopParamsItemList = 61, RULE_gopParamsItem = 62, 
		RULE_gopParamsItemMany = 63, RULE_gopParamsItemAs = 64, RULE_gopOut = 65, 
		RULE_gopOutItem = 66, RULE_gopOutTypeList = 67, RULE_gopOutTypeParam = 68, 
		RULE_gopOutTypeItem = 69, RULE_gopDetail = 70, RULE_gopConfig = 71, RULE_createContextExpr = 72, 
		RULE_createExpressionExpr = 73, RULE_createContextDetail = 74, RULE_contextContextNested = 75, 
		RULE_createContextChoice = 76, RULE_createContextDistinct = 77, RULE_createContextRangePoint = 78, 
		RULE_createContextFilter = 79, RULE_createContextPartitionItem = 80, RULE_createContextCoalesceItem = 81, 
		RULE_createContextGroupItem = 82, RULE_createSchemaQual = 83, RULE_variantList = 84, 
		RULE_variantListElement = 85, RULE_intoTableExpr = 86, RULE_insertIntoExpr = 87, 
		RULE_columnList = 88, RULE_fromClause = 89, RULE_regularJoin = 90, RULE_outerJoinList = 91, 
		RULE_outerJoin = 92, RULE_outerJoinIdent = 93, RULE_outerJoinIdentPair = 94, 
		RULE_whereClause = 95, RULE_selectClause = 96, RULE_selectionList = 97, 
		RULE_selectionListElement = 98, RULE_selectionListElementExpr = 99, RULE_selectionListElementAnno = 100, 
		RULE_streamSelector = 101, RULE_streamExpression = 102, RULE_forExpr = 103, 
		RULE_patternInclusionExpression = 104, RULE_databaseJoinExpression = 105, 
		RULE_methodJoinExpression = 106, RULE_viewExpressions = 107, RULE_viewExpressionWNamespace = 108, 
		RULE_viewExpressionOptNamespace = 109, RULE_viewWParameters = 110, RULE_groupByListExpr = 111, 
		RULE_groupByListChoice = 112, RULE_groupByCubeOrRollup = 113, RULE_groupByGroupingSets = 114, 
		RULE_groupBySetsChoice = 115, RULE_groupByCombinableExpr = 116, RULE_orderByListExpr = 117, 
		RULE_orderByListElement = 118, RULE_havingClause = 119, RULE_outputLimit = 120, 
		RULE_outputLimitAndTerm = 121, RULE_outputLimitAfter = 122, RULE_rowLimit = 123, 
		RULE_crontabLimitParameterSet = 124, RULE_whenClause = 125, RULE_elseClause = 126, 
		RULE_matchRecog = 127, RULE_matchRecogPartitionBy = 128, RULE_matchRecogMeasures = 129, 
		RULE_matchRecogMeasureItem = 130, RULE_matchRecogMatchesSelection = 131, 
		RULE_matchRecogPattern = 132, RULE_matchRecogMatchesAfterSkip = 133, RULE_matchRecogMatchesInterval = 134, 
		RULE_matchRecogPatternAlteration = 135, RULE_matchRecogPatternConcat = 136, 
		RULE_matchRecogPatternUnary = 137, RULE_matchRecogPatternNested = 138, 
		RULE_matchRecogPatternPermute = 139, RULE_matchRecogPatternAtom = 140, 
		RULE_matchRecogPatternRepeat = 141, RULE_matchRecogDefine = 142, RULE_matchRecogDefineItem = 143, 
		RULE_expression = 144, RULE_caseExpression = 145, RULE_evalOrExpression = 146, 
		RULE_evalAndExpression = 147, RULE_bitWiseExpression = 148, RULE_negatedExpression = 149, 
		RULE_evalEqualsExpression = 150, RULE_evalRelationalExpression = 151, 
		RULE_inSubSelectQuery = 152, RULE_concatenationExpr = 153, RULE_additiveExpression = 154, 
		RULE_multiplyExpression = 155, RULE_unaryExpression = 156, RULE_substitutionCanChain = 157, 
		RULE_chainedFunction = 158, RULE_newAssign = 159, RULE_rowSubSelectExpression = 160, 
		RULE_subSelectGroupExpression = 161, RULE_existsSubSelectExpression = 162, 
		RULE_subQueryExpr = 163, RULE_subSelectFilterExpr = 164, RULE_arrayExpression = 165, 
		RULE_builtinFunc = 166, RULE_firstLastWindowAggregation = 167, RULE_eventPropertyOrLibFunction = 168, 
		RULE_libFunction = 169, RULE_libFunctionWithClass = 170, RULE_libFunctionNoClass = 171, 
		RULE_funcIdentTop = 172, RULE_funcIdentInner = 173, RULE_funcIdentChained = 174, 
		RULE_libFunctionArgs = 175, RULE_libFunctionArgItem = 176, RULE_betweenList = 177, 
		RULE_patternExpression = 178, RULE_followedByExpression = 179, RULE_followedByRepeat = 180, 
		RULE_orExpression = 181, RULE_andExpression = 182, RULE_matchUntilExpression = 183, 
		RULE_qualifyExpression = 184, RULE_guardPostFix = 185, RULE_distinctExpressionList = 186, 
		RULE_distinctExpressionAtom = 187, RULE_atomicExpression = 188, RULE_observerExpression = 189, 
		RULE_guardWhereExpression = 190, RULE_guardWhileExpression = 191, RULE_matchUntilRange = 192, 
		RULE_eventFilterExpression = 193, RULE_propertyExpression = 194, RULE_propertyExpressionAtomic = 195, 
		RULE_propertyExpressionSelect = 196, RULE_propertySelectionList = 197, 
		RULE_propertySelectionListElement = 198, RULE_propertyStreamSelector = 199, 
		RULE_typeExpressionAnnotation = 200, RULE_patternFilterExpression = 201, 
		RULE_patternFilterAnnotation = 202, RULE_classIdentifier = 203, RULE_slashIdentifier = 204, 
		RULE_expressionListWithNamed = 205, RULE_expressionListWithNamedWithTime = 206, 
		RULE_expressionWithNamed = 207, RULE_expressionWithNamedWithTime = 208, 
		RULE_expressionNamedParameter = 209, RULE_expressionNamedParameterWithTime = 210, 
		RULE_expressionList = 211, RULE_expressionWithTimeList = 212, RULE_expressionWithTime = 213, 
		RULE_expressionWithTimeInclLast = 214, RULE_expressionQualifyable = 215, 
		RULE_lastWeekdayOperand = 216, RULE_lastOperand = 217, RULE_frequencyOperand = 218, 
		RULE_rangeOperand = 219, RULE_lastOperator = 220, RULE_weekDayOperator = 221, 
		RULE_numericParameterList = 222, RULE_numericListParameter = 223, RULE_eventProperty = 224, 
		RULE_eventPropertyAtomic = 225, RULE_eventPropertyIdent = 226, RULE_keywordAllowedIdent = 227, 
		RULE_escapableStr = 228, RULE_escapableIdent = 229, RULE_timePeriod = 230, 
		RULE_yearPart = 231, RULE_monthPart = 232, RULE_weekPart = 233, RULE_dayPart = 234, 
		RULE_hourPart = 235, RULE_minutePart = 236, RULE_secondPart = 237, RULE_millisecondPart = 238, 
		RULE_microsecondPart = 239, RULE_number = 240, RULE_substitution = 241, 
		RULE_constant = 242, RULE_numberconstant = 243, RULE_stringconstant = 244, 
		RULE_jsonvalue = 245, RULE_jsonobject = 246, RULE_jsonarray = 247, RULE_jsonelements = 248, 
		RULE_jsonmembers = 249, RULE_jsonpair = 250;
	public static readonly string[] ruleNames = {
		"startPatternExpressionRule", "startEPLExpressionRule", "startEventPropertyRule", 
		"startJsonValueRule", "expressionDecl", "expressionDialect", "expressionDef", 
		"expressionLambdaDecl", "expressionTypeAnno", "annotationEnum", "elementValuePairsEnum", 
		"elementValuePairEnum", "elementValueEnum", "elementValueArrayEnum", "eplExpression", 
		"contextExpr", "selectExpr", "onExpr", "onStreamExpr", "updateExpr", "updateDetails", 
		"onMergeExpr", "mergeItem", "mergeMatched", "mergeMatchedItem", "mergeUnmatched", 
		"mergeUnmatchedItem", "mergeInsert", "onSelectExpr", "onUpdateExpr", "onSelectInsertExpr", 
		"onSelectInsertFromClause", "outputClauseInsert", "onDeleteExpr", "onSetExpr", 
		"onSetAssignmentList", "onSetAssignment", "onExprFrom", "createWindowExpr", 
		"createWindowExprModelAfter", "createIndexExpr", "createIndexColumnList", 
		"createIndexColumn", "createVariableExpr", "createTableExpr", "createTableColumnList", 
		"createTableColumn", "createTableColumnPlain", "createColumnList", "createColumnListElement", 
		"createSelectionList", "createSelectionListElement", "createSchemaExpr", 
		"createSchemaDef", "fafDelete", "fafUpdate", "fafInsert", "createDataflow", 
		"gopList", "gop", "gopParams", "gopParamsItemList", "gopParamsItem", "gopParamsItemMany", 
		"gopParamsItemAs", "gopOut", "gopOutItem", "gopOutTypeList", "gopOutTypeParam", 
		"gopOutTypeItem", "gopDetail", "gopConfig", "createContextExpr", "createExpressionExpr", 
		"createContextDetail", "contextContextNested", "createContextChoice", 
		"createContextDistinct", "createContextRangePoint", "createContextFilter", 
		"createContextPartitionItem", "createContextCoalesceItem", "createContextGroupItem", 
		"createSchemaQual", "variantList", "variantListElement", "intoTableExpr", 
		"insertIntoExpr", "columnList", "fromClause", "regularJoin", "outerJoinList", 
		"outerJoin", "outerJoinIdent", "outerJoinIdentPair", "whereClause", "selectClause", 
		"selectionList", "selectionListElement", "selectionListElementExpr", "selectionListElementAnno", 
		"streamSelector", "streamExpression", "forExpr", "patternInclusionExpression", 
		"databaseJoinExpression", "methodJoinExpression", "viewExpressions", "viewExpressionWNamespace", 
		"viewExpressionOptNamespace", "viewWParameters", "groupByListExpr", "groupByListChoice", 
		"groupByCubeOrRollup", "groupByGroupingSets", "groupBySetsChoice", "groupByCombinableExpr", 
		"orderByListExpr", "orderByListElement", "havingClause", "outputLimit", 
		"outputLimitAndTerm", "outputLimitAfter", "rowLimit", "crontabLimitParameterSet", 
		"whenClause", "elseClause", "matchRecog", "matchRecogPartitionBy", "matchRecogMeasures", 
		"matchRecogMeasureItem", "matchRecogMatchesSelection", "matchRecogPattern", 
		"matchRecogMatchesAfterSkip", "matchRecogMatchesInterval", "matchRecogPatternAlteration", 
		"matchRecogPatternConcat", "matchRecogPatternUnary", "matchRecogPatternNested", 
		"matchRecogPatternPermute", "matchRecogPatternAtom", "matchRecogPatternRepeat", 
		"matchRecogDefine", "matchRecogDefineItem", "expression", "caseExpression", 
		"evalOrExpression", "evalAndExpression", "bitWiseExpression", "negatedExpression", 
		"evalEqualsExpression", "evalRelationalExpression", "inSubSelectQuery", 
		"concatenationExpr", "additiveExpression", "multiplyExpression", "unaryExpression", 
		"substitutionCanChain", "chainedFunction", "newAssign", "rowSubSelectExpression", 
		"subSelectGroupExpression", "existsSubSelectExpression", "subQueryExpr", 
		"subSelectFilterExpr", "arrayExpression", "builtinFunc", "firstLastWindowAggregation", 
		"eventPropertyOrLibFunction", "libFunction", "libFunctionWithClass", "libFunctionNoClass", 
		"funcIdentTop", "funcIdentInner", "funcIdentChained", "libFunctionArgs", 
		"libFunctionArgItem", "betweenList", "patternExpression", "followedByExpression", 
		"followedByRepeat", "orExpression", "andExpression", "matchUntilExpression", 
		"qualifyExpression", "guardPostFix", "distinctExpressionList", "distinctExpressionAtom", 
		"atomicExpression", "observerExpression", "guardWhereExpression", "guardWhileExpression", 
		"matchUntilRange", "eventFilterExpression", "propertyExpression", "propertyExpressionAtomic", 
		"propertyExpressionSelect", "propertySelectionList", "propertySelectionListElement", 
		"propertyStreamSelector", "typeExpressionAnnotation", "patternFilterExpression", 
		"patternFilterAnnotation", "classIdentifier", "slashIdentifier", "expressionListWithNamed", 
		"expressionListWithNamedWithTime", "expressionWithNamed", "expressionWithNamedWithTime", 
		"expressionNamedParameter", "expressionNamedParameterWithTime", "expressionList", 
		"expressionWithTimeList", "expressionWithTime", "expressionWithTimeInclLast", 
		"expressionQualifyable", "lastWeekdayOperand", "lastOperand", "frequencyOperand", 
		"rangeOperand", "lastOperator", "weekDayOperator", "numericParameterList", 
		"numericListParameter", "eventProperty", "eventPropertyAtomic", "eventPropertyIdent", 
		"keywordAllowedIdent", "escapableStr", "escapableIdent", "timePeriod", 
		"yearPart", "monthPart", "weekPart", "dayPart", "hourPart", "minutePart", 
		"secondPart", "millisecondPart", "microsecondPart", "number", "substitution", 
		"constant", "numberconstant", "stringconstant", "jsonvalue", "jsonobject", 
		"jsonarray", "jsonelements", "jsonmembers", "jsonpair"
	};

	private static readonly string[] _LiteralNames = {
		null, "'create'", "'window'", "'in'", "'between'", "'like'", "'regexp'", 
		"'escape'", "'or'", "'and'", "'not'", "'every'", "'every-distinct'", "'where'", 
		"'as'", "'sum'", "'avg'", "'max'", "'min'", "'coalesce'", "'median'", 
		"'stddev'", "'avedev'", "'count'", "'select'", "'case'", "'else'", "'when'", 
		"'then'", "'end'", "'from'", "'outer'", "'inner'", "'join'", "'left'", 
		"'right'", "'full'", "'on'", "'is'", "'by'", "'group'", "'having'", "'distinct'", 
		"'all'", "'any'", "'some'", "'output'", "'events'", "'first'", "'last'", 
		"'insert'", "'into'", "'values'", "'order'", "'asc'", "'desc'", "'rstream'", 
		"'istream'", "'irstream'", "'schema'", "'unidirectional'", "'retain-union'", 
		"'retain-intersection'", "'pattern'", "'sql'", "'metadatasql'", "'prev'", 
		"'prevtail'", "'prevcount'", "'prevwindow'", "'prior'", "'exists'", "'weekday'", 
		"'lastweekday'", "'instanceof'", "'typeof'", "'cast'", "'current_timestamp'", 
		"'delete'", "'snapshot'", "'set'", "'variable'", "'table'", "'until'", 
		"'at'", "'index'", "'year'", "'years'", "'month'", "'months'", "'week'", 
		"'weeks'", "'day'", "'days'", "'hour'", "'hours'", "'minute'", "'minutes'", 
		"'sec'", "'second'", "'seconds'", "'msec'", "'millisecond'", "'milliseconds'", 
		"'usec'", "'microsecond'", "'microseconds'", "'true'", "'false'", "'null'", 
		"'limit'", "'offset'", "'update'", "'match_recognize'", "'match_recognize_permute'", 
		"'measures'", "'define'", "'partition'", "'matches'", "'after'", "'for'", 
		"'while'", "'using'", "'merge'", "'matched'", "'expression'", "'new'", 
		"'start'", "'context'", "'initiated'", "'terminated'", "'dataflow'", "'cube'", 
		"'rollup'", "'grouping'", "'grouping_id'", "'sets'", "'-['", "']>'", "'->'", 
		"'=>'", "'='", "'<>'", "'?'", "'('", "')'", "'['", "']'", "'{'", "'}'", 
		"':'", "','", "'=='", "'!'", "'~'", "'!='", "'/'", "'/='", "'+'", "'+='", 
		"'++'", "'-'", "'-='", "'--'", "'*'", "'*='", "'%'", "'%='", "'>='", "'>'", 
		"'<='", "'<'", "'^'", "'^='", "'|'", "'|='", "'||'", "'&'", "'&='", "'&&'", 
		"';'", "'.'", "'\\u18FF'", "'\\u18FE'", "'\\u18FD'", "'\\'", "'`'", "'@'", 
		"'#'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "CREATE", "WINDOW", "IN_SET", "BETWEEN", "LIKE", "REGEXP", "ESCAPE", 
		"OR_EXPR", "AND_EXPR", "NOT_EXPR", "EVERY_EXPR", "EVERY_DISTINCT_EXPR", 
		"WHERE", "AS", "SUM", "AVG", "MAX", "MIN", "COALESCE", "MEDIAN", "STDDEV", 
		"AVEDEV", "COUNT", "SELECT", "CASE", "ELSE", "WHEN", "THEN", "END", "FROM", 
		"OUTER", "INNER", "JOIN", "LEFT", "RIGHT", "FULL", "ON", "IS", "BY", "GROUP", 
		"HAVING", "DISTINCT", "ALL", "ANY", "SOME", "OUTPUT", "EVENTS", "FIRST", 
		"LAST", "INSERT", "INTO", "VALUES", "ORDER", "ASC", "DESC", "RSTREAM", 
		"ISTREAM", "IRSTREAM", "SCHEMA", "UNIDIRECTIONAL", "RETAINUNION", "RETAININTERSECTION", 
		"PATTERN", "SQL", "METADATASQL", "PREVIOUS", "PREVIOUSTAIL", "PREVIOUSCOUNT", 
		"PREVIOUSWINDOW", "PRIOR", "EXISTS", "WEEKDAY", "LW", "INSTANCEOF", "TYPEOF", 
		"CAST", "CURRENT_TIMESTAMP", "DELETE", "SNAPSHOT", "SET", "VARIABLE", 
		"TABLE", "UNTIL", "AT", "INDEX", "TIMEPERIOD_YEAR", "TIMEPERIOD_YEARS", 
		"TIMEPERIOD_MONTH", "TIMEPERIOD_MONTHS", "TIMEPERIOD_WEEK", "TIMEPERIOD_WEEKS", 
		"TIMEPERIOD_DAY", "TIMEPERIOD_DAYS", "TIMEPERIOD_HOUR", "TIMEPERIOD_HOURS", 
		"TIMEPERIOD_MINUTE", "TIMEPERIOD_MINUTES", "TIMEPERIOD_SEC", "TIMEPERIOD_SECOND", 
		"TIMEPERIOD_SECONDS", "TIMEPERIOD_MILLISEC", "TIMEPERIOD_MILLISECOND", 
		"TIMEPERIOD_MILLISECONDS", "TIMEPERIOD_MICROSEC", "TIMEPERIOD_MICROSECOND", 
		"TIMEPERIOD_MICROSECONDS", "BOOLEAN_TRUE", "BOOLEAN_FALSE", "VALUE_NULL", 
		"ROW_LIMIT_EXPR", "OFFSET", "UPDATE", "MATCH_RECOGNIZE", "MATCH_RECOGNIZE_PERMUTE", 
		"MEASURES", "DEFINE", "PARTITION", "MATCHES", "AFTER", "FOR", "WHILE", 
		"USING", "MERGE", "MATCHED", "EXPRESSIONDECL", "NEWKW", "START", "CONTEXT", 
		"INITIATED", "TERMINATED", "DATAFLOW", "CUBE", "ROLLUP", "GROUPING", "GROUPING_ID", 
		"SETS", "FOLLOWMAX_BEGIN", "FOLLOWMAX_END", "FOLLOWED_BY", "GOES", "EQUALS", 
		"SQL_NE", "QUESTION", "LPAREN", "RPAREN", "LBRACK", "RBRACK", "LCURLY", 
		"RCURLY", "COLON", "COMMA", "EQUAL", "LNOT", "BNOT", "NOT_EQUAL", "DIV", 
		"DIV_ASSIGN", "PLUS", "PLUS_ASSIGN", "INC", "MINUS", "MINUS_ASSIGN", "DEC", 
		"STAR", "STAR_ASSIGN", "MOD", "MOD_ASSIGN", "GE", "GT", "LE", "LT", "BXOR", 
		"BXOR_ASSIGN", "BOR", "BOR_ASSIGN", "LOR", "BAND", "BAND_ASSIGN", "LAND", 
		"SEMI", "DOT", "NUM_LONG", "NUM_DOUBLE", "NUM_FLOAT", "ESCAPECHAR", "ESCAPEBACKTICK", 
		"ATCHAR", "HASHCHAR", "WS", "SL_COMMENT", "ML_COMMENT", "TICKED_STRING_LITERAL", 
		"QUOTED_STRING_LITERAL", "STRING_LITERAL", "IDENT", "IntegerLiteral", 
		"FloatingPointLiteral"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "EsperEPL2Grammar.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	static EsperEPL2GrammarParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}


		// provide nice error messages
		private System.Collections.Generic.Stack<string> paraphrases =
			new System.Collections.Generic.Stack<string>();

		// static information initialized once
		private static System.Collections.Generic.IDictionary<int, string> lexerTokenParaphrases =
			       new System.Collections.Generic.Dictionary<int, string>();
		private static System.Collections.Generic.IDictionary<int, string> parserTokenParaphrases =
				   new System.Collections.Generic.Dictionary<int, string>();
		private static System.Collections.Generic.ISet<string> parserKeywordSet =
				   new System.Collections.Generic.HashSet<string>();
		private static System.Collections.Generic.ISet<int> afterScriptTokens =
				   new System.Collections.Generic.HashSet<int>();

		private static readonly Object _iLock = new Object();

		public System.Collections.Generic.Stack<string> GetParaphrases()
		{
			return paraphrases;
		}

		public System.Collections.Generic.ISet<string> GetKeywords()
		{
			GetParserTokenParaphrases();
			return parserKeywordSet;
		}

		public static System.Collections.Generic.IDictionary<int, string> GetLexerTokenParaphrases()
		{
			lock(_iLock)
			{
				if (lexerTokenParaphrases.Count == 0)
				{
					lexerTokenParaphrases[IDENT] = "an identifier";
					lexerTokenParaphrases[FOLLOWED_BY] = "an followed-by '->'";
					lexerTokenParaphrases[EQUALS] = "an equals '='";
					lexerTokenParaphrases[SQL_NE] = "a sql-style not equals '<>'";
					lexerTokenParaphrases[QUESTION] = "a questionmark '?'";
					lexerTokenParaphrases[LPAREN] = "an opening parenthesis '('";
					lexerTokenParaphrases[RPAREN] = "a closing parenthesis ')'";
					lexerTokenParaphrases[LBRACK] = "a left angle bracket '['";
					lexerTokenParaphrases[RBRACK] = "a right angle bracket ']'";
					lexerTokenParaphrases[LCURLY] = "a left curly bracket '{'";
					lexerTokenParaphrases[RCURLY] = "a right curly bracket '}'";
					lexerTokenParaphrases[COLON] = "a colon ':'";
					lexerTokenParaphrases[COMMA] = "a comma ','";
					lexerTokenParaphrases[EQUAL] = "an equals compare '=='";
					lexerTokenParaphrases[LNOT] = "a not '!'";
					lexerTokenParaphrases[BNOT] = "a binary not '~'";
					lexerTokenParaphrases[NOT_EQUAL] = "a not equals '!='";
					lexerTokenParaphrases[DIV] = "a division operator '\'";
					lexerTokenParaphrases[DIV_ASSIGN] = "a division assign '/='";
					lexerTokenParaphrases[PLUS] = "a plus operator '+'";
					lexerTokenParaphrases[PLUS_ASSIGN] = "a plus assign '+='";
					lexerTokenParaphrases[INC] = "an increment operator '++'";
					lexerTokenParaphrases[MINUS] = "a minus '-'";
					lexerTokenParaphrases[MINUS_ASSIGN] = "a minus assign '-='";
					lexerTokenParaphrases[DEC] = "a decrement operator '--'";
					lexerTokenParaphrases[STAR] = "a star '*'";
					lexerTokenParaphrases[STAR_ASSIGN] = "a star assign '*='";
					lexerTokenParaphrases[MOD] = "a modulo";
					lexerTokenParaphrases[MOD_ASSIGN] = "a modulo assign";
					lexerTokenParaphrases[GE] = "a greater equals '>='";
					lexerTokenParaphrases[GT] = "a greater then '>'";
					lexerTokenParaphrases[LE] = "a less equals '<='";
					lexerTokenParaphrases[LT] = "a lesser then '<'";
					lexerTokenParaphrases[BXOR] = "a binary xor '^'";
					lexerTokenParaphrases[BXOR_ASSIGN] = "a binary xor assign '^='";
					lexerTokenParaphrases[BOR] = "a binary or '|'";
					lexerTokenParaphrases[BOR_ASSIGN] = "a binary or assign '|='";
					lexerTokenParaphrases[LOR] = "a logical or '||'";
					lexerTokenParaphrases[BAND] = "a binary and '&'";
					lexerTokenParaphrases[BAND_ASSIGN] = "a binary and assign '&='";
					lexerTokenParaphrases[LAND] = "a logical and '&&'";
					lexerTokenParaphrases[SEMI] = "a semicolon ';'";
					lexerTokenParaphrases[DOT] = "a dot '.'";
				}
			}

			return lexerTokenParaphrases;
		}

		public static System.Collections.Generic.IDictionary<int, string> GetParserTokenParaphrases()
		{
			lock(_iLock)
			{
				if (parserTokenParaphrases.Count == 0)
				{
					parserTokenParaphrases[CREATE] = "'create'";
					parserTokenParaphrases[WINDOW] = "'window'";
					parserTokenParaphrases[IN_SET] = "'in'";
					parserTokenParaphrases[BETWEEN] = "'between'";
					parserTokenParaphrases[LIKE] = "'like'";
					parserTokenParaphrases[REGEXP] = "'regexp'";
					parserTokenParaphrases[ESCAPE] = "'escape'";
					parserTokenParaphrases[OR_EXPR] = "'or'";
					parserTokenParaphrases[AND_EXPR] = "'and'";
					parserTokenParaphrases[NOT_EXPR] = "'not'";
					parserTokenParaphrases[EVERY_EXPR] = "'every'";
					parserTokenParaphrases[EVERY_DISTINCT_EXPR] = "'every-distinct'";
					parserTokenParaphrases[WHERE] = "'where'";
					parserTokenParaphrases[AS] = "'as'";
					parserTokenParaphrases[SUM] = "'sum'";
					parserTokenParaphrases[AVG] = "'avg'";
					parserTokenParaphrases[MAX] = "'max'";
					parserTokenParaphrases[MIN] = "'min'";
					parserTokenParaphrases[COALESCE] = "'coalesce'";
					parserTokenParaphrases[MEDIAN] = "'median'";
					parserTokenParaphrases[STDDEV] = "'stddev'";
					parserTokenParaphrases[AVEDEV] = "'avedev'";
					parserTokenParaphrases[COUNT] = "'count'";
					parserTokenParaphrases[SELECT] = "'select'";
					parserTokenParaphrases[CASE] = "'case'";
					parserTokenParaphrases[ELSE] = "'else'";
					parserTokenParaphrases[WHEN] = "'when'";
					parserTokenParaphrases[THEN] = "'then'";
					parserTokenParaphrases[END] = "'end'";
					parserTokenParaphrases[FROM] = "'from'";
					parserTokenParaphrases[OUTER] = "'outer'";
					parserTokenParaphrases[INNER] = "'inner'";
					parserTokenParaphrases[JOIN] = "'join'";
					parserTokenParaphrases[LEFT] = "'left'";
					parserTokenParaphrases[RIGHT] = "'right'";
					parserTokenParaphrases[FULL] = "'full'";
					parserTokenParaphrases[ON] = "'on'";
					parserTokenParaphrases[IS] = "'is'";
					parserTokenParaphrases[BY] = "'by'";
					parserTokenParaphrases[GROUP] = "'group'";
					parserTokenParaphrases[HAVING] = "'having'";
					parserTokenParaphrases[ALL] = "'all'";
					parserTokenParaphrases[ANY] = "'any'";
					parserTokenParaphrases[SOME] = "'some'";
					parserTokenParaphrases[OUTPUT] = "'output'";
					parserTokenParaphrases[EVENTS] = "'events'";
					parserTokenParaphrases[FIRST] = "'first'";
					parserTokenParaphrases[LAST] = "'last'";
					parserTokenParaphrases[INSERT] = "'insert'";
					parserTokenParaphrases[INTO] = "'into'";
					parserTokenParaphrases[ORDER] = "'order'";
					parserTokenParaphrases[ASC] = "'asc'";
					parserTokenParaphrases[DESC] = "'desc'";
					parserTokenParaphrases[RSTREAM] = "'rstream'";
					parserTokenParaphrases[ISTREAM] = "'istream'";
					parserTokenParaphrases[IRSTREAM] = "'irstream'";
					parserTokenParaphrases[SCHEMA] = "'schema'";
					parserTokenParaphrases[UNIDIRECTIONAL] = "'unidirectional'";
					parserTokenParaphrases[RETAINUNION] = "'retain-union'";
					parserTokenParaphrases[RETAININTERSECTION] = "'retain-intersection'";
					parserTokenParaphrases[PATTERN] = "'pattern'";
					parserTokenParaphrases[SQL] = "'sql'";
					parserTokenParaphrases[METADATASQL] = "'metadatasql'";
					parserTokenParaphrases[PREVIOUS] = "'prev'";
					parserTokenParaphrases[PREVIOUSTAIL] = "'prevtail'";
					parserTokenParaphrases[PREVIOUSCOUNT] = "'prevcount'";
					parserTokenParaphrases[PREVIOUSWINDOW] = "'prevwindow'";
					parserTokenParaphrases[PRIOR] = "'prior'";
					parserTokenParaphrases[EXISTS] = "'exists'";
					parserTokenParaphrases[WEEKDAY] = "'weekday'";
					parserTokenParaphrases[LW] = "'lastweekday'";
					parserTokenParaphrases[INSTANCEOF] = "'instanceof'";
					parserTokenParaphrases[TYPEOF] = "'typeof'";
					parserTokenParaphrases[CAST] = "'cast'";
					parserTokenParaphrases[CURRENT_TIMESTAMP] = "'current_timestamp'";
					parserTokenParaphrases[DELETE] = "'delete'";
					parserTokenParaphrases[DISTINCT] = "'distinct'";
					parserTokenParaphrases[SNAPSHOT] = "'snapshot'";
					parserTokenParaphrases[SET] = "'set'";
					parserTokenParaphrases[VARIABLE] = "'variable'";
					parserTokenParaphrases[TABLE] = "'table'";
					parserTokenParaphrases[INDEX] = "'index'";
					parserTokenParaphrases[UNTIL] = "'until'";
					parserTokenParaphrases[AT] = "'at'";
					parserTokenParaphrases[TIMEPERIOD_YEAR] = "'year'";
					parserTokenParaphrases[TIMEPERIOD_YEARS] = "'years'";
					parserTokenParaphrases[TIMEPERIOD_MONTH] = "'month'";
					parserTokenParaphrases[TIMEPERIOD_MONTHS] = "'months'";
					parserTokenParaphrases[TIMEPERIOD_WEEK] = "'week'";
					parserTokenParaphrases[TIMEPERIOD_WEEKS] = "'weeks'";
					parserTokenParaphrases[TIMEPERIOD_DAY] = "'day'";
					parserTokenParaphrases[TIMEPERIOD_DAYS] = "'days'";
					parserTokenParaphrases[TIMEPERIOD_HOUR] = "'hour'";
					parserTokenParaphrases[TIMEPERIOD_HOURS] = "'hours'";
					parserTokenParaphrases[TIMEPERIOD_MINUTE] = "'minute'";
					parserTokenParaphrases[TIMEPERIOD_MINUTES] = "'minutes'";
					parserTokenParaphrases[TIMEPERIOD_SEC] = "'sec'";
					parserTokenParaphrases[TIMEPERIOD_SECOND] = "'second'";
					parserTokenParaphrases[TIMEPERIOD_SECONDS] = "'seconds'";
					parserTokenParaphrases[TIMEPERIOD_MILLISEC] = "'msec'";
					parserTokenParaphrases[TIMEPERIOD_MILLISECOND] = "'millisecond'";
					parserTokenParaphrases[TIMEPERIOD_MILLISECONDS] = "'milliseconds'";
					parserTokenParaphrases[TIMEPERIOD_MICROSEC] = "'usec'";
					parserTokenParaphrases[TIMEPERIOD_MICROSECOND] = "'microsecond'";
					parserTokenParaphrases[TIMEPERIOD_MICROSECONDS] = "'microseconds'";
					parserTokenParaphrases[BOOLEAN_TRUE] = "'true'";
					parserTokenParaphrases[BOOLEAN_FALSE] = "'false'";
					parserTokenParaphrases[VALUE_NULL] = "'null'";
					parserTokenParaphrases[ROW_LIMIT_EXPR] = "'limit'";
					parserTokenParaphrases[OFFSET] = "'offset'";
					parserTokenParaphrases[UPDATE] = "'update'";
					parserTokenParaphrases[MATCH_RECOGNIZE] = "'match_recognize'";
					parserTokenParaphrases[MEASURES] = "'measures'";
					parserTokenParaphrases[DEFINE] = "'define'";
					parserTokenParaphrases[PARTITION] = "'partition'";
					parserTokenParaphrases[MATCHES] = "'matches'";
					parserTokenParaphrases[AFTER] = "'after'";
					parserTokenParaphrases[FOR] = "'for'";
					parserTokenParaphrases[WHILE] = "'while'";
					parserTokenParaphrases[MERGE] = "'merge'";
					parserTokenParaphrases[MATCHED] = "'matched'";
					parserTokenParaphrases[CONTEXT] = "'context'";
					parserTokenParaphrases[START] = "'start'";
					parserTokenParaphrases[END] = "'end'";
					parserTokenParaphrases[INITIATED] = "'initiated'";
					parserTokenParaphrases[TERMINATED] = "'terminated'";
					parserTokenParaphrases[USING] = "'using'";
					parserTokenParaphrases[EXPRESSIONDECL] = "'expression'";
					parserTokenParaphrases[NEWKW] = "'new'";
					parserTokenParaphrases[DATAFLOW] = "'dataflow'";
					parserTokenParaphrases[VALUES] = "'values'";
					parserTokenParaphrases[CUBE] = "'cube'";
					parserTokenParaphrases[ROLLUP] = "'rollup'";
					parserTokenParaphrases[GROUPING] = "'grouping'";
					parserTokenParaphrases[GROUPING_ID] = "'grouping_id'";
					parserTokenParaphrases[SETS] = "'sets'";

					parserKeywordSet = new HashSet<string>(
						parserTokenParaphrases.Values);
				}
			}

			return parserTokenParaphrases;
		}

		public static System.Collections.Generic.ISet<int> GetAfterScriptTokens()
		{
			if (afterScriptTokens.Count == 0)
			{
				afterScriptTokens.Add(CREATE);
				afterScriptTokens.Add(EXPRESSIONDECL);
				afterScriptTokens.Add(SELECT);
				afterScriptTokens.Add(INSERT);
				afterScriptTokens.Add(ON);
				afterScriptTokens.Add(DELETE);
				afterScriptTokens.Add(UPDATE);
				afterScriptTokens.Add(ATCHAR);
			}

			return afterScriptTokens;
		}

	public EsperEPL2GrammarParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
	public partial class StartPatternExpressionRuleContext : ParserRuleContext {
		public PatternExpressionContext patternExpression() {
			return GetRuleContext<PatternExpressionContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(EsperEPL2GrammarParser.Eof, 0); }
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public ExpressionDeclContext[] expressionDecl() {
			return GetRuleContexts<ExpressionDeclContext>();
		}
		public ExpressionDeclContext expressionDecl(int i) {
			return GetRuleContext<ExpressionDeclContext>(i);
		}
		public StartPatternExpressionRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startPatternExpressionRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStartPatternExpressionRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStartPatternExpressionRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartPatternExpressionRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartPatternExpressionRuleContext startPatternExpressionRule() {
		StartPatternExpressionRuleContext _localctx = new StartPatternExpressionRuleContext(Context, State);
		EnterRule(_localctx, 0, RULE_startPatternExpressionRule);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 506;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==EXPRESSIONDECL || _la==ATCHAR) {
				{
				State = 504;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ATCHAR:
					{
					State = 502; annotationEnum();
					}
					break;
				case EXPRESSIONDECL:
					{
					State = 503; expressionDecl();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 508;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 509; patternExpression();
			State = 510; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartEPLExpressionRuleContext : ParserRuleContext {
		public EplExpressionContext eplExpression() {
			return GetRuleContext<EplExpressionContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(EsperEPL2GrammarParser.Eof, 0); }
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public ExpressionDeclContext[] expressionDecl() {
			return GetRuleContexts<ExpressionDeclContext>();
		}
		public ExpressionDeclContext expressionDecl(int i) {
			return GetRuleContext<ExpressionDeclContext>(i);
		}
		public StartEPLExpressionRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startEPLExpressionRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStartEPLExpressionRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStartEPLExpressionRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartEPLExpressionRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartEPLExpressionRuleContext startEPLExpressionRule() {
		StartEPLExpressionRuleContext _localctx = new StartEPLExpressionRuleContext(Context, State);
		EnterRule(_localctx, 2, RULE_startEPLExpressionRule);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 516;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==EXPRESSIONDECL || _la==ATCHAR) {
				{
				State = 514;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ATCHAR:
					{
					State = 512; annotationEnum();
					}
					break;
				case EXPRESSIONDECL:
					{
					State = 513; expressionDecl();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 518;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 519; eplExpression();
			State = 520; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartEventPropertyRuleContext : ParserRuleContext {
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(EsperEPL2GrammarParser.Eof, 0); }
		public StartEventPropertyRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startEventPropertyRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStartEventPropertyRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStartEventPropertyRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartEventPropertyRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartEventPropertyRuleContext startEventPropertyRule() {
		StartEventPropertyRuleContext _localctx = new StartEventPropertyRuleContext(Context, State);
		EnterRule(_localctx, 4, RULE_startEventPropertyRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 522; eventProperty();
			State = 523; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartJsonValueRuleContext : ParserRuleContext {
		public JsonvalueContext jsonvalue() {
			return GetRuleContext<JsonvalueContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(EsperEPL2GrammarParser.Eof, 0); }
		public StartJsonValueRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startJsonValueRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStartJsonValueRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStartJsonValueRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartJsonValueRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartJsonValueRuleContext startJsonValueRule() {
		StartJsonValueRuleContext _localctx = new StartJsonValueRuleContext(Context, State);
		EnterRule(_localctx, 6, RULE_startJsonValueRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 525; jsonvalue();
			State = 526; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionDeclContext : ParserRuleContext {
		public IToken array;
		public IToken name;
		public IToken alias;
		public ITerminalNode EXPRESSIONDECL() { return GetToken(EsperEPL2GrammarParser.EXPRESSIONDECL, 0); }
		public ExpressionDefContext expressionDef() {
			return GetRuleContext<ExpressionDefContext>(0);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public TypeExpressionAnnotationContext typeExpressionAnnotation() {
			return GetRuleContext<TypeExpressionAnnotationContext>(0);
		}
		public ExpressionDialectContext expressionDialect() {
			return GetRuleContext<ExpressionDialectContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode FOR() { return GetToken(EsperEPL2GrammarParser.FOR, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public ExpressionDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionDecl; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionDeclContext expressionDecl() {
		ExpressionDeclContext _localctx = new ExpressionDeclContext(Context, State);
		EnterRule(_localctx, 8, RULE_expressionDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 528; Match(EXPRESSIONDECL);
			State = 530;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 529; classIdentifier();
				}
				break;
			}
			State = 534;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LBRACK) {
				{
				State = 532; _localctx.array = Match(LBRACK);
				State = 533; Match(RBRACK);
				}
			}

			State = 537;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ATCHAR) {
				{
				State = 536; typeExpressionAnnotation();
				}
			}

			State = 540;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
			case 1:
				{
				State = 539; expressionDialect();
				}
				break;
			}
			State = 542; _localctx.name = Match(IDENT);
			State = 548;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 543; Match(LPAREN);
				State = 545;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IDENT) {
					{
					State = 544; columnList();
					}
				}

				State = 547; Match(RPAREN);
				}
			}

			State = 552;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENT) {
				{
				State = 550; _localctx.alias = Match(IDENT);
				State = 551; Match(FOR);
				}
			}

			State = 554; expressionDef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionDialectContext : ParserRuleContext {
		public IToken d;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ExpressionDialectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionDialect; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionDialect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionDialect(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionDialect(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionDialectContext expressionDialect() {
		ExpressionDialectContext _localctx = new ExpressionDialectContext(Context, State);
		EnterRule(_localctx, 10, RULE_expressionDialect);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 556; _localctx.d = Match(IDENT);
			State = 557; Match(COLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionDefContext : ParserRuleContext {
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public ExpressionLambdaDeclContext expressionLambdaDecl() {
			return GetRuleContext<ExpressionLambdaDeclContext>(0);
		}
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public StringconstantContext stringconstant() {
			return GetRuleContext<StringconstantContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ExpressionDefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionDef; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionDef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionDef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionDef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionDefContext expressionDef() {
		ExpressionDefContext _localctx = new ExpressionDefContext(Context, State);
		EnterRule(_localctx, 12, RULE_expressionDef);
		try {
			State = 570;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LCURLY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 559; Match(LCURLY);
				State = 561;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
				case 1:
					{
					State = 560; expressionLambdaDecl();
					}
					break;
				}
				State = 563; expression();
				State = 564; Match(RCURLY);
				}
				break;
			case LBRACK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 566; Match(LBRACK);
				State = 567; stringconstant();
				State = 568; Match(RBRACK);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionLambdaDeclContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode GOES() { return GetToken(EsperEPL2GrammarParser.GOES, 0); }
		public ITerminalNode FOLLOWED_BY() { return GetToken(EsperEPL2GrammarParser.FOLLOWED_BY, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionLambdaDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionLambdaDecl; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionLambdaDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionLambdaDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionLambdaDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionLambdaDeclContext expressionLambdaDecl() {
		ExpressionLambdaDeclContext _localctx = new ExpressionLambdaDeclContext(Context, State);
		EnterRule(_localctx, 14, RULE_expressionLambdaDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 577;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENT:
				{
				State = 572; _localctx.i = Match(IDENT);
				}
				break;
			case LPAREN:
				{
				{
				State = 573; Match(LPAREN);
				State = 574; columnList();
				State = 575; Match(RPAREN);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 579;
			_la = TokenStream.LA(1);
			if ( !(_la==FOLLOWED_BY || _la==GOES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionTypeAnnoContext : ParserRuleContext {
		public IToken n;
		public IToken v;
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionTypeAnnoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionTypeAnno; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionTypeAnno(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionTypeAnno(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionTypeAnno(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionTypeAnnoContext expressionTypeAnno() {
		ExpressionTypeAnnoContext _localctx = new ExpressionTypeAnnoContext(Context, State);
		EnterRule(_localctx, 16, RULE_expressionTypeAnno);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 581; Match(ATCHAR);
			State = 582; _localctx.n = Match(IDENT);
			{
			State = 583; Match(LPAREN);
			State = 584; _localctx.v = Match(IDENT);
			State = 585; Match(RPAREN);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnnotationEnumContext : ParserRuleContext {
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ElementValuePairsEnumContext elementValuePairsEnum() {
			return GetRuleContext<ElementValuePairsEnumContext>(0);
		}
		public ElementValueEnumContext elementValueEnum() {
			return GetRuleContext<ElementValueEnumContext>(0);
		}
		public AnnotationEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_annotationEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterAnnotationEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitAnnotationEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnnotationEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnnotationEnumContext annotationEnum() {
		AnnotationEnumContext _localctx = new AnnotationEnumContext(Context, State);
		EnterRule(_localctx, 18, RULE_annotationEnum);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 587; Match(ATCHAR);
			State = 588; classIdentifier();
			State = 595;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				{
				State = 589; Match(LPAREN);
				State = 592;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
				case 1:
					{
					State = 590; elementValuePairsEnum();
					}
					break;
				case 2:
					{
					State = 591; elementValueEnum();
					}
					break;
				}
				State = 594; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementValuePairsEnumContext : ParserRuleContext {
		public ElementValuePairEnumContext[] elementValuePairEnum() {
			return GetRuleContexts<ElementValuePairEnumContext>();
		}
		public ElementValuePairEnumContext elementValuePairEnum(int i) {
			return GetRuleContext<ElementValuePairEnumContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ElementValuePairsEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementValuePairsEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElementValuePairsEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElementValuePairsEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementValuePairsEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementValuePairsEnumContext elementValuePairsEnum() {
		ElementValuePairsEnumContext _localctx = new ElementValuePairsEnumContext(Context, State);
		EnterRule(_localctx, 20, RULE_elementValuePairsEnum);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 597; elementValuePairEnum();
			State = 602;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 598; Match(COMMA);
				State = 599; elementValuePairEnum();
				}
				}
				State = 604;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementValuePairEnumContext : ParserRuleContext {
		public KeywordAllowedIdentContext keywordAllowedIdent() {
			return GetRuleContext<KeywordAllowedIdentContext>(0);
		}
		public ElementValueEnumContext elementValueEnum() {
			return GetRuleContext<ElementValueEnumContext>(0);
		}
		public ElementValuePairEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementValuePairEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElementValuePairEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElementValuePairEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementValuePairEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementValuePairEnumContext elementValuePairEnum() {
		ElementValuePairEnumContext _localctx = new ElementValuePairEnumContext(Context, State);
		EnterRule(_localctx, 22, RULE_elementValuePairEnum);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 605; keywordAllowedIdent();
			State = 606; Match(EQUALS);
			State = 607; elementValueEnum();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementValueEnumContext : ParserRuleContext {
		public IToken v;
		public AnnotationEnumContext annotationEnum() {
			return GetRuleContext<AnnotationEnumContext>(0);
		}
		public ElementValueArrayEnumContext elementValueArrayEnum() {
			return GetRuleContext<ElementValueArrayEnumContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ElementValueEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementValueEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElementValueEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElementValueEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementValueEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementValueEnumContext elementValueEnum() {
		ElementValueEnumContext _localctx = new ElementValueEnumContext(Context, State);
		EnterRule(_localctx, 24, RULE_elementValueEnum);
		try {
			State = 614;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 609; annotationEnum();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 610; elementValueArrayEnum();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 611; constant();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 612; _localctx.v = Match(IDENT);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 613; classIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementValueArrayEnumContext : ParserRuleContext {
		public ElementValueEnumContext[] elementValueEnum() {
			return GetRuleContexts<ElementValueEnumContext>();
		}
		public ElementValueEnumContext elementValueEnum(int i) {
			return GetRuleContext<ElementValueEnumContext>(i);
		}
		public ElementValueArrayEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementValueArrayEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElementValueArrayEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElementValueArrayEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementValueArrayEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementValueArrayEnumContext elementValueArrayEnum() {
		ElementValueArrayEnumContext _localctx = new ElementValueArrayEnumContext(Context, State);
		EnterRule(_localctx, 26, RULE_elementValueArrayEnum);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 616; Match(LCURLY);
			State = 625;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 47)) & ~0x3f) == 0 && ((1L << (_la - 47)) & ((1L << (EVENTS - 47)) | (1L << (BOOLEAN_TRUE - 47)) | (1L << (BOOLEAN_FALSE - 47)) | (1L << (VALUE_NULL - 47)))) != 0) || ((((_la - 148)) & ~0x3f) == 0 && ((1L << (_la - 148)) & ((1L << (LCURLY - 148)) | (1L << (PLUS - 148)) | (1L << (MINUS - 148)) | (1L << (ATCHAR - 148)) | (1L << (TICKED_STRING_LITERAL - 148)) | (1L << (QUOTED_STRING_LITERAL - 148)) | (1L << (STRING_LITERAL - 148)) | (1L << (IDENT - 148)) | (1L << (IntegerLiteral - 148)) | (1L << (FloatingPointLiteral - 148)))) != 0)) {
				{
				State = 617; elementValueEnum();
				State = 622;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 618; Match(COMMA);
						State = 619; elementValueEnum();
						}
						} 
					}
					State = 624;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
				}
				}
			}

			State = 628;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 627; Match(COMMA);
				}
			}

			State = 630; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EplExpressionContext : ParserRuleContext {
		public SelectExprContext selectExpr() {
			return GetRuleContext<SelectExprContext>(0);
		}
		public CreateWindowExprContext createWindowExpr() {
			return GetRuleContext<CreateWindowExprContext>(0);
		}
		public CreateIndexExprContext createIndexExpr() {
			return GetRuleContext<CreateIndexExprContext>(0);
		}
		public CreateVariableExprContext createVariableExpr() {
			return GetRuleContext<CreateVariableExprContext>(0);
		}
		public CreateTableExprContext createTableExpr() {
			return GetRuleContext<CreateTableExprContext>(0);
		}
		public CreateSchemaExprContext createSchemaExpr() {
			return GetRuleContext<CreateSchemaExprContext>(0);
		}
		public CreateContextExprContext createContextExpr() {
			return GetRuleContext<CreateContextExprContext>(0);
		}
		public CreateExpressionExprContext createExpressionExpr() {
			return GetRuleContext<CreateExpressionExprContext>(0);
		}
		public OnExprContext onExpr() {
			return GetRuleContext<OnExprContext>(0);
		}
		public UpdateExprContext updateExpr() {
			return GetRuleContext<UpdateExprContext>(0);
		}
		public CreateDataflowContext createDataflow() {
			return GetRuleContext<CreateDataflowContext>(0);
		}
		public FafDeleteContext fafDelete() {
			return GetRuleContext<FafDeleteContext>(0);
		}
		public FafUpdateContext fafUpdate() {
			return GetRuleContext<FafUpdateContext>(0);
		}
		public FafInsertContext fafInsert() {
			return GetRuleContext<FafInsertContext>(0);
		}
		public ContextExprContext contextExpr() {
			return GetRuleContext<ContextExprContext>(0);
		}
		public ForExprContext forExpr() {
			return GetRuleContext<ForExprContext>(0);
		}
		public EplExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eplExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEplExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEplExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEplExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EplExpressionContext eplExpression() {
		EplExpressionContext _localctx = new EplExpressionContext(Context, State);
		EnterRule(_localctx, 28, RULE_eplExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 633;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONTEXT) {
				{
				State = 632; contextExpr();
				}
			}

			State = 649;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,22,Context) ) {
			case 1:
				{
				State = 635; selectExpr();
				}
				break;
			case 2:
				{
				State = 636; createWindowExpr();
				}
				break;
			case 3:
				{
				State = 637; createIndexExpr();
				}
				break;
			case 4:
				{
				State = 638; createVariableExpr();
				}
				break;
			case 5:
				{
				State = 639; createTableExpr();
				}
				break;
			case 6:
				{
				State = 640; createSchemaExpr();
				}
				break;
			case 7:
				{
				State = 641; createContextExpr();
				}
				break;
			case 8:
				{
				State = 642; createExpressionExpr();
				}
				break;
			case 9:
				{
				State = 643; onExpr();
				}
				break;
			case 10:
				{
				State = 644; updateExpr();
				}
				break;
			case 11:
				{
				State = 645; createDataflow();
				}
				break;
			case 12:
				{
				State = 646; fafDelete();
				}
				break;
			case 13:
				{
				State = 647; fafUpdate();
				}
				break;
			case 14:
				{
				State = 648; fafInsert();
				}
				break;
			}
			State = 652;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FOR) {
				{
				State = 651; forExpr();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ContextExprContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode CONTEXT() { return GetToken(EsperEPL2GrammarParser.CONTEXT, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ContextExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_contextExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterContextExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitContextExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContextExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ContextExprContext contextExpr() {
		ContextExprContext _localctx = new ContextExprContext(Context, State);
		EnterRule(_localctx, 30, RULE_contextExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 654; Match(CONTEXT);
			State = 655; _localctx.i = Match(IDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectExprContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectClauseContext selectClause() {
			return GetRuleContext<SelectClauseContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(EsperEPL2GrammarParser.INTO, 0); }
		public IntoTableExprContext intoTableExpr() {
			return GetRuleContext<IntoTableExprContext>(0);
		}
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public InsertIntoExprContext insertIntoExpr() {
			return GetRuleContext<InsertIntoExprContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public FromClauseContext fromClause() {
			return GetRuleContext<FromClauseContext>(0);
		}
		public MatchRecogContext matchRecog() {
			return GetRuleContext<MatchRecogContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode GROUP() { return GetToken(EsperEPL2GrammarParser.GROUP, 0); }
		public ITerminalNode[] BY() { return GetTokens(EsperEPL2GrammarParser.BY); }
		public ITerminalNode BY(int i) {
			return GetToken(EsperEPL2GrammarParser.BY, i);
		}
		public GroupByListExprContext groupByListExpr() {
			return GetRuleContext<GroupByListExprContext>(0);
		}
		public ITerminalNode HAVING() { return GetToken(EsperEPL2GrammarParser.HAVING, 0); }
		public HavingClauseContext havingClause() {
			return GetRuleContext<HavingClauseContext>(0);
		}
		public ITerminalNode OUTPUT() { return GetToken(EsperEPL2GrammarParser.OUTPUT, 0); }
		public OutputLimitContext outputLimit() {
			return GetRuleContext<OutputLimitContext>(0);
		}
		public ITerminalNode ORDER() { return GetToken(EsperEPL2GrammarParser.ORDER, 0); }
		public OrderByListExprContext orderByListExpr() {
			return GetRuleContext<OrderByListExprContext>(0);
		}
		public ITerminalNode ROW_LIMIT_EXPR() { return GetToken(EsperEPL2GrammarParser.ROW_LIMIT_EXPR, 0); }
		public RowLimitContext rowLimit() {
			return GetRuleContext<RowLimitContext>(0);
		}
		public SelectExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectExprContext selectExpr() {
		SelectExprContext _localctx = new SelectExprContext(Context, State);
		EnterRule(_localctx, 32, RULE_selectExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 659;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 657; Match(INTO);
				State = 658; intoTableExpr();
				}
			}

			State = 663;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INSERT) {
				{
				State = 661; Match(INSERT);
				State = 662; insertIntoExpr();
				}
			}

			State = 665; Match(SELECT);
			State = 666; selectClause();
			State = 669;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 667; Match(FROM);
				State = 668; fromClause();
				}
			}

			State = 672;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MATCH_RECOGNIZE) {
				{
				State = 671; matchRecog();
				}
			}

			State = 676;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 674; Match(WHERE);
				State = 675; whereClause();
				}
			}

			State = 681;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GROUP) {
				{
				State = 678; Match(GROUP);
				State = 679; Match(BY);
				State = 680; groupByListExpr();
				}
			}

			State = 685;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==HAVING) {
				{
				State = 683; Match(HAVING);
				State = 684; havingClause();
				}
			}

			State = 689;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OUTPUT) {
				{
				State = 687; Match(OUTPUT);
				State = 688; outputLimit();
				}
			}

			State = 694;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 691; Match(ORDER);
				State = 692; Match(BY);
				State = 693; orderByListExpr();
				}
			}

			State = 698;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ROW_LIMIT_EXPR) {
				{
				State = 696; Match(ROW_LIMIT_EXPR);
				State = 697; rowLimit();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnExprContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(EsperEPL2GrammarParser.ON, 0); }
		public OnStreamExprContext onStreamExpr() {
			return GetRuleContext<OnStreamExprContext>(0);
		}
		public OnDeleteExprContext onDeleteExpr() {
			return GetRuleContext<OnDeleteExprContext>(0);
		}
		public OnSelectExprContext onSelectExpr() {
			return GetRuleContext<OnSelectExprContext>(0);
		}
		public OnSetExprContext onSetExpr() {
			return GetRuleContext<OnSetExprContext>(0);
		}
		public OnUpdateExprContext onUpdateExpr() {
			return GetRuleContext<OnUpdateExprContext>(0);
		}
		public OnMergeExprContext onMergeExpr() {
			return GetRuleContext<OnMergeExprContext>(0);
		}
		public OnSelectInsertExprContext[] onSelectInsertExpr() {
			return GetRuleContexts<OnSelectInsertExprContext>();
		}
		public OnSelectInsertExprContext onSelectInsertExpr(int i) {
			return GetRuleContext<OnSelectInsertExprContext>(i);
		}
		public OutputClauseInsertContext outputClauseInsert() {
			return GetRuleContext<OutputClauseInsertContext>(0);
		}
		public OnExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnExprContext onExpr() {
		OnExprContext _localctx = new OnExprContext(Context, State);
		EnterRule(_localctx, 34, RULE_onExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 700; Match(ON);
			State = 701; onStreamExpr();
			State = 717;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DELETE:
				{
				State = 702; onDeleteExpr();
				}
				break;
			case SELECT:
			case INSERT:
				{
				State = 703; onSelectExpr();
				State = 712;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INSERT) {
					{
					State = 705;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do {
						{
						{
						State = 704; onSelectInsertExpr();
						}
						}
						State = 707;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while ( _la==INSERT );
					State = 710;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==OUTPUT) {
						{
						State = 709; outputClauseInsert();
						}
					}

					}
				}

				}
				break;
			case SET:
				{
				State = 714; onSetExpr();
				}
				break;
			case UPDATE:
				{
				State = 715; onUpdateExpr();
				}
				break;
			case MERGE:
				{
				State = 716; onMergeExpr();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnStreamExprContext : ParserRuleContext {
		public IToken i;
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public PatternInclusionExpressionContext patternInclusionExpression() {
			return GetRuleContext<PatternInclusionExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public OnStreamExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onStreamExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnStreamExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnStreamExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnStreamExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnStreamExprContext onStreamExpr() {
		OnStreamExprContext _localctx = new OnStreamExprContext(Context, State);
		EnterRule(_localctx, 36, RULE_onStreamExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 721;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 719; eventFilterExpression();
				}
				break;
			case PATTERN:
				{
				State = 720; patternInclusionExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 726;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 723; Match(AS);
				State = 724; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 725; _localctx.i = Match(IDENT);
				}
				break;
			case SELECT:
			case INSERT:
			case DELETE:
			case SET:
			case UPDATE:
			case MERGE:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdateExprContext : ParserRuleContext {
		public ITerminalNode UPDATE() { return GetToken(EsperEPL2GrammarParser.UPDATE, 0); }
		public ITerminalNode ISTREAM() { return GetToken(EsperEPL2GrammarParser.ISTREAM, 0); }
		public UpdateDetailsContext updateDetails() {
			return GetRuleContext<UpdateDetailsContext>(0);
		}
		public UpdateExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updateExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterUpdateExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitUpdateExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdateExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UpdateExprContext updateExpr() {
		UpdateExprContext _localctx = new UpdateExprContext(Context, State);
		EnterRule(_localctx, 38, RULE_updateExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 728; Match(UPDATE);
			State = 729; Match(ISTREAM);
			State = 730; updateDetails();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdateDetailsContext : ParserRuleContext {
		public IToken i;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public OnSetAssignmentListContext onSetAssignmentList() {
			return GetRuleContext<OnSetAssignmentListContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public UpdateDetailsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updateDetails; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterUpdateDetails(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitUpdateDetails(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdateDetails(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UpdateDetailsContext updateDetails() {
		UpdateDetailsContext _localctx = new UpdateDetailsContext(Context, State);
		EnterRule(_localctx, 40, RULE_updateDetails);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 732; classIdentifier();
			State = 736;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 733; Match(AS);
				State = 734; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 735; _localctx.i = Match(IDENT);
				}
				break;
			case SET:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 738; Match(SET);
			State = 739; onSetAssignmentList();
			State = 742;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 740; Match(WHERE);
				State = 741; whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnMergeExprContext : ParserRuleContext {
		public IToken n;
		public IToken i;
		public ITerminalNode MERGE() { return GetToken(EsperEPL2GrammarParser.MERGE, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode INTO() { return GetToken(EsperEPL2GrammarParser.INTO, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public MergeItemContext[] mergeItem() {
			return GetRuleContexts<MergeItemContext>();
		}
		public MergeItemContext mergeItem(int i) {
			return GetRuleContext<MergeItemContext>(i);
		}
		public OnMergeExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onMergeExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnMergeExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnMergeExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnMergeExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnMergeExprContext onMergeExpr() {
		OnMergeExprContext _localctx = new OnMergeExprContext(Context, State);
		EnterRule(_localctx, 42, RULE_onMergeExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 744; Match(MERGE);
			State = 746;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 745; Match(INTO);
				}
			}

			State = 748; _localctx.n = Match(IDENT);
			State = 752;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 749; Match(AS);
				State = 750; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 751; _localctx.i = Match(IDENT);
				}
				break;
			case WHERE:
			case WHEN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 756;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 754; Match(WHERE);
				State = 755; whereClause();
				}
			}

			State = 759;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 758; mergeItem();
				}
				}
				State = 761;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeItemContext : ParserRuleContext {
		public MergeMatchedContext mergeMatched() {
			return GetRuleContext<MergeMatchedContext>(0);
		}
		public MergeUnmatchedContext mergeUnmatched() {
			return GetRuleContext<MergeUnmatchedContext>(0);
		}
		public MergeItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeItemContext mergeItem() {
		MergeItemContext _localctx = new MergeItemContext(Context, State);
		EnterRule(_localctx, 44, RULE_mergeItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 765;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,46,Context) ) {
			case 1:
				{
				State = 763; mergeMatched();
				}
				break;
			case 2:
				{
				State = 764; mergeUnmatched();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeMatchedContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public ITerminalNode MATCHED() { return GetToken(EsperEPL2GrammarParser.MATCHED, 0); }
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public MergeMatchedItemContext[] mergeMatchedItem() {
			return GetRuleContexts<MergeMatchedItemContext>();
		}
		public MergeMatchedItemContext mergeMatchedItem(int i) {
			return GetRuleContext<MergeMatchedItemContext>(i);
		}
		public MergeMatchedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeMatched; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeMatched(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeMatched(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeMatched(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeMatchedContext mergeMatched() {
		MergeMatchedContext _localctx = new MergeMatchedContext(Context, State);
		EnterRule(_localctx, 46, RULE_mergeMatched);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 767; Match(WHEN);
			State = 768; Match(MATCHED);
			State = 771;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND_EXPR) {
				{
				State = 769; Match(AND_EXPR);
				State = 770; expression();
				}
			}

			State = 774;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 773; mergeMatchedItem();
				}
				}
				State = 776;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==THEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeMatchedItemContext : ParserRuleContext {
		public IToken u;
		public IToken d;
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public MergeInsertContext mergeInsert() {
			return GetRuleContext<MergeInsertContext>(0);
		}
		public ITerminalNode DELETE() { return GetToken(EsperEPL2GrammarParser.DELETE, 0); }
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public OnSetAssignmentListContext onSetAssignmentList() {
			return GetRuleContext<OnSetAssignmentListContext>(0);
		}
		public ITerminalNode UPDATE() { return GetToken(EsperEPL2GrammarParser.UPDATE, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public MergeMatchedItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeMatchedItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeMatchedItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeMatchedItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeMatchedItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeMatchedItemContext mergeMatchedItem() {
		MergeMatchedItemContext _localctx = new MergeMatchedItemContext(Context, State);
		EnterRule(_localctx, 48, RULE_mergeMatchedItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 778; Match(THEN);
			State = 793;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UPDATE:
				{
				{
				State = 779; _localctx.u = Match(UPDATE);
				State = 780; Match(SET);
				State = 781; onSetAssignmentList();
				}
				State = 785;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 783; Match(WHERE);
					State = 784; whereClause();
					}
				}

				}
				break;
			case DELETE:
				{
				State = 787; _localctx.d = Match(DELETE);
				State = 790;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 788; Match(WHERE);
					State = 789; whereClause();
					}
				}

				}
				break;
			case INSERT:
				{
				State = 792; mergeInsert();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUnmatchedContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public ITerminalNode NOT_EXPR() { return GetToken(EsperEPL2GrammarParser.NOT_EXPR, 0); }
		public ITerminalNode MATCHED() { return GetToken(EsperEPL2GrammarParser.MATCHED, 0); }
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public MergeUnmatchedItemContext[] mergeUnmatchedItem() {
			return GetRuleContexts<MergeUnmatchedItemContext>();
		}
		public MergeUnmatchedItemContext mergeUnmatchedItem(int i) {
			return GetRuleContext<MergeUnmatchedItemContext>(i);
		}
		public MergeUnmatchedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUnmatched; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeUnmatched(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeUnmatched(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeUnmatched(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeUnmatchedContext mergeUnmatched() {
		MergeUnmatchedContext _localctx = new MergeUnmatchedContext(Context, State);
		EnterRule(_localctx, 50, RULE_mergeUnmatched);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 795; Match(WHEN);
			State = 796; Match(NOT_EXPR);
			State = 797; Match(MATCHED);
			State = 800;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND_EXPR) {
				{
				State = 798; Match(AND_EXPR);
				State = 799; expression();
				}
			}

			State = 803;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 802; mergeUnmatchedItem();
				}
				}
				State = 805;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==THEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUnmatchedItemContext : ParserRuleContext {
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public MergeInsertContext mergeInsert() {
			return GetRuleContext<MergeInsertContext>(0);
		}
		public MergeUnmatchedItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUnmatchedItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeUnmatchedItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeUnmatchedItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeUnmatchedItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeUnmatchedItemContext mergeUnmatchedItem() {
		MergeUnmatchedItemContext _localctx = new MergeUnmatchedItemContext(Context, State);
		EnterRule(_localctx, 52, RULE_mergeUnmatchedItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 807; Match(THEN);
			State = 808; mergeInsert();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeInsertContext : ParserRuleContext {
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(EsperEPL2GrammarParser.INTO, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public MergeInsertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeInsert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeInsert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeInsert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeInsert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeInsertContext mergeInsert() {
		MergeInsertContext _localctx = new MergeInsertContext(Context, State);
		EnterRule(_localctx, 54, RULE_mergeInsert);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 810; Match(INSERT);
			State = 813;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INTO) {
				{
				State = 811; Match(INTO);
				State = 812; classIdentifier();
				}
			}

			State = 819;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 815; Match(LPAREN);
				State = 816; columnList();
				State = 817; Match(RPAREN);
				}
			}

			State = 821; Match(SELECT);
			State = 822; selectionList();
			State = 825;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 823; Match(WHERE);
				State = 824; whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSelectExprContext : ParserRuleContext {
		public IToken d;
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public InsertIntoExprContext insertIntoExpr() {
			return GetRuleContext<InsertIntoExprContext>(0);
		}
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public OnExprFromContext onExprFrom() {
			return GetRuleContext<OnExprFromContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode GROUP() { return GetToken(EsperEPL2GrammarParser.GROUP, 0); }
		public ITerminalNode[] BY() { return GetTokens(EsperEPL2GrammarParser.BY); }
		public ITerminalNode BY(int i) {
			return GetToken(EsperEPL2GrammarParser.BY, i);
		}
		public GroupByListExprContext groupByListExpr() {
			return GetRuleContext<GroupByListExprContext>(0);
		}
		public ITerminalNode HAVING() { return GetToken(EsperEPL2GrammarParser.HAVING, 0); }
		public HavingClauseContext havingClause() {
			return GetRuleContext<HavingClauseContext>(0);
		}
		public ITerminalNode ORDER() { return GetToken(EsperEPL2GrammarParser.ORDER, 0); }
		public OrderByListExprContext orderByListExpr() {
			return GetRuleContext<OrderByListExprContext>(0);
		}
		public ITerminalNode ROW_LIMIT_EXPR() { return GetToken(EsperEPL2GrammarParser.ROW_LIMIT_EXPR, 0); }
		public RowLimitContext rowLimit() {
			return GetRuleContext<RowLimitContext>(0);
		}
		public ITerminalNode DELETE() { return GetToken(EsperEPL2GrammarParser.DELETE, 0); }
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public OnSelectExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSelectExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSelectExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSelectExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSelectExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSelectExprContext onSelectExpr() {
		OnSelectExprContext _localctx = new OnSelectExprContext(Context, State);
		EnterRule(_localctx, 56, RULE_onSelectExpr);
		 paraphrases.Push("on-select clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 829;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INSERT) {
				{
				State = 827; Match(INSERT);
				State = 828; insertIntoExpr();
				}
			}

			State = 831; Match(SELECT);
			State = 836;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND_EXPR || _la==DELETE) {
				{
				State = 833;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AND_EXPR) {
					{
					State = 832; Match(AND_EXPR);
					}
				}

				State = 835; _localctx.d = Match(DELETE);
				}
			}

			State = 839;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISTINCT) {
				{
				State = 838; Match(DISTINCT);
				}
			}

			State = 841; selectionList();
			State = 843;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 842; onExprFrom();
				}
			}

			State = 847;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 845; Match(WHERE);
				State = 846; whereClause();
				}
			}

			State = 852;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GROUP) {
				{
				State = 849; Match(GROUP);
				State = 850; Match(BY);
				State = 851; groupByListExpr();
				}
			}

			State = 856;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==HAVING) {
				{
				State = 854; Match(HAVING);
				State = 855; havingClause();
				}
			}

			State = 861;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 858; Match(ORDER);
				State = 859; Match(BY);
				State = 860; orderByListExpr();
				}
			}

			State = 865;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ROW_LIMIT_EXPR) {
				{
				State = 863; Match(ROW_LIMIT_EXPR);
				State = 864; rowLimit();
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnUpdateExprContext : ParserRuleContext {
		public IToken n;
		public IToken i;
		public ITerminalNode UPDATE() { return GetToken(EsperEPL2GrammarParser.UPDATE, 0); }
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public OnSetAssignmentListContext onSetAssignmentList() {
			return GetRuleContext<OnSetAssignmentListContext>(0);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public OnUpdateExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onUpdateExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnUpdateExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnUpdateExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnUpdateExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnUpdateExprContext onUpdateExpr() {
		OnUpdateExprContext _localctx = new OnUpdateExprContext(Context, State);
		EnterRule(_localctx, 58, RULE_onUpdateExpr);
		 paraphrases.Push("on-update clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 867; Match(UPDATE);
			State = 868; _localctx.n = Match(IDENT);
			State = 872;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 869; Match(AS);
				State = 870; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 871; _localctx.i = Match(IDENT);
				}
				break;
			case SET:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 874; Match(SET);
			State = 875; onSetAssignmentList();
			State = 878;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 876; Match(WHERE);
				State = 877; whereClause();
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSelectInsertExprContext : ParserRuleContext {
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public InsertIntoExprContext insertIntoExpr() {
			return GetRuleContext<InsertIntoExprContext>(0);
		}
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public OnSelectInsertFromClauseContext onSelectInsertFromClause() {
			return GetRuleContext<OnSelectInsertFromClauseContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public OnSelectInsertExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSelectInsertExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSelectInsertExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSelectInsertExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSelectInsertExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSelectInsertExprContext onSelectInsertExpr() {
		OnSelectInsertExprContext _localctx = new OnSelectInsertExprContext(Context, State);
		EnterRule(_localctx, 60, RULE_onSelectInsertExpr);
		 paraphrases.Push("on-select-insert clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 880; Match(INSERT);
			State = 881; insertIntoExpr();
			State = 882; Match(SELECT);
			State = 883; selectionList();
			State = 885;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 884; onSelectInsertFromClause();
				}
			}

			State = 889;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 887; Match(WHERE);
				State = 888; whereClause();
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSelectInsertFromClauseContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public PropertyExpressionContext propertyExpression() {
			return GetRuleContext<PropertyExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public OnSelectInsertFromClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSelectInsertFromClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSelectInsertFromClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSelectInsertFromClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSelectInsertFromClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSelectInsertFromClauseContext onSelectInsertFromClause() {
		OnSelectInsertFromClauseContext _localctx = new OnSelectInsertFromClauseContext(Context, State);
		EnterRule(_localctx, 62, RULE_onSelectInsertFromClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 891; Match(FROM);
			State = 892; propertyExpression();
			State = 896;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 893; Match(AS);
				State = 894; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 895; _localctx.i = Match(IDENT);
				}
				break;
			case Eof:
			case WHERE:
			case OUTPUT:
			case INSERT:
			case FOR:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OutputClauseInsertContext : ParserRuleContext {
		public IToken f;
		public IToken a;
		public ITerminalNode OUTPUT() { return GetToken(EsperEPL2GrammarParser.OUTPUT, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public OutputClauseInsertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outputClauseInsert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOutputClauseInsert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOutputClauseInsert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOutputClauseInsert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OutputClauseInsertContext outputClauseInsert() {
		OutputClauseInsertContext _localctx = new OutputClauseInsertContext(Context, State);
		EnterRule(_localctx, 64, RULE_outputClauseInsert);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 898; Match(OUTPUT);
			State = 901;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FIRST:
				{
				State = 899; _localctx.f = Match(FIRST);
				}
				break;
			case ALL:
				{
				State = 900; _localctx.a = Match(ALL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnDeleteExprContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(EsperEPL2GrammarParser.DELETE, 0); }
		public OnExprFromContext onExprFrom() {
			return GetRuleContext<OnExprFromContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public OnDeleteExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onDeleteExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnDeleteExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnDeleteExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnDeleteExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnDeleteExprContext onDeleteExpr() {
		OnDeleteExprContext _localctx = new OnDeleteExprContext(Context, State);
		EnterRule(_localctx, 66, RULE_onDeleteExpr);
		 paraphrases.Push("on-delete clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 903; Match(DELETE);
			State = 904; onExprFrom();
			State = 907;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 905; Match(WHERE);
				State = 906; whereClause();
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSetExprContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public OnSetAssignmentListContext onSetAssignmentList() {
			return GetRuleContext<OnSetAssignmentListContext>(0);
		}
		public OnSetExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSetExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSetExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSetExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSetExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSetExprContext onSetExpr() {
		OnSetExprContext _localctx = new OnSetExprContext(Context, State);
		EnterRule(_localctx, 68, RULE_onSetExpr);
		 paraphrases.Push("on-set clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 909; Match(SET);
			State = 910; onSetAssignmentList();
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSetAssignmentListContext : ParserRuleContext {
		public OnSetAssignmentContext[] onSetAssignment() {
			return GetRuleContexts<OnSetAssignmentContext>();
		}
		public OnSetAssignmentContext onSetAssignment(int i) {
			return GetRuleContext<OnSetAssignmentContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public OnSetAssignmentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSetAssignmentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSetAssignmentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSetAssignmentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSetAssignmentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSetAssignmentListContext onSetAssignmentList() {
		OnSetAssignmentListContext _localctx = new OnSetAssignmentListContext(Context, State);
		EnterRule(_localctx, 70, RULE_onSetAssignmentList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 912; onSetAssignment();
			State = 917;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 913; Match(COMMA);
				State = 914; onSetAssignment();
				}
				}
				State = 919;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSetAssignmentContext : ParserRuleContext {
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public OnSetAssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSetAssignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSetAssignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSetAssignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSetAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSetAssignmentContext onSetAssignment() {
		OnSetAssignmentContext _localctx = new OnSetAssignmentContext(Context, State);
		EnterRule(_localctx, 72, RULE_onSetAssignment);
		try {
			State = 925;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,75,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 920; eventProperty();
				State = 921; Match(EQUALS);
				State = 922; expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 924; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnExprFromContext : ParserRuleContext {
		public IToken n;
		public IToken i;
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public OnExprFromContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onExprFrom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnExprFrom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnExprFrom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnExprFrom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnExprFromContext onExprFrom() {
		OnExprFromContext _localctx = new OnExprFromContext(Context, State);
		EnterRule(_localctx, 74, RULE_onExprFrom);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 927; Match(FROM);
			State = 928; _localctx.n = Match(IDENT);
			State = 932;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 929; Match(AS);
				State = 930; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 931; _localctx.i = Match(IDENT);
				}
				break;
			case Eof:
			case WHERE:
			case GROUP:
			case HAVING:
			case INSERT:
			case ORDER:
			case ROW_LIMIT_EXPR:
			case FOR:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateWindowExprContext : ParserRuleContext {
		public IToken i;
		public IToken ru;
		public IToken ri;
		public IToken i1;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateWindowExprModelAfterContext createWindowExprModelAfter() {
			return GetRuleContext<CreateWindowExprModelAfterContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public CreateColumnListContext createColumnList() {
			return GetRuleContext<CreateColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ViewExpressionsContext viewExpressions() {
			return GetRuleContext<ViewExpressionsContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode RETAINUNION() { return GetToken(EsperEPL2GrammarParser.RETAINUNION, 0); }
		public ITerminalNode RETAININTERSECTION() { return GetToken(EsperEPL2GrammarParser.RETAININTERSECTION, 0); }
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CreateWindowExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createWindowExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateWindowExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateWindowExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateWindowExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateWindowExprContext createWindowExpr() {
		CreateWindowExprContext _localctx = new CreateWindowExprContext(Context, State);
		EnterRule(_localctx, 76, RULE_createWindowExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 934; Match(CREATE);
			State = 935; Match(WINDOW);
			State = 936; _localctx.i = Match(IDENT);
			State = 938;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOT || _la==HASHCHAR) {
				{
				State = 937; viewExpressions();
				}
			}

			State = 942;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RETAINUNION:
				{
				State = 940; _localctx.ru = Match(RETAINUNION);
				}
				break;
			case RETAININTERSECTION:
				{
				State = 941; _localctx.ri = Match(RETAININTERSECTION);
				}
				break;
			case AS:
			case SELECT:
			case EVENTS:
			case LPAREN:
			case TICKED_STRING_LITERAL:
			case IDENT:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 945;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 944; Match(AS);
				}
			}

			State = 952;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 947; createWindowExprModelAfter();
				}
				break;
			case LPAREN:
				{
				State = 948; Match(LPAREN);
				State = 949; createColumnList();
				State = 950; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 959;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INSERT) {
				{
				State = 954; _localctx.i1 = Match(INSERT);
				State = 957;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 955; Match(WHERE);
					State = 956; expression();
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateWindowExprModelAfterContext : ParserRuleContext {
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public CreateSelectionListContext createSelectionList() {
			return GetRuleContext<CreateSelectionListContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public CreateWindowExprModelAfterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createWindowExprModelAfter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateWindowExprModelAfter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateWindowExprModelAfter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateWindowExprModelAfter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateWindowExprModelAfterContext createWindowExprModelAfter() {
		CreateWindowExprModelAfterContext _localctx = new CreateWindowExprModelAfterContext(Context, State);
		EnterRule(_localctx, 78, RULE_createWindowExprModelAfter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 965;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SELECT) {
				{
				State = 961; Match(SELECT);
				State = 962; createSelectionList();
				State = 963; Match(FROM);
				}
			}

			State = 967; classIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexExprContext : ParserRuleContext {
		public IToken u;
		public IToken n;
		public IToken w;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode INDEX() { return GetToken(EsperEPL2GrammarParser.INDEX, 0); }
		public ITerminalNode ON() { return GetToken(EsperEPL2GrammarParser.ON, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public CreateIndexColumnListContext createIndexColumnList() {
			return GetRuleContext<CreateIndexColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public CreateIndexExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndexExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateIndexExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateIndexExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateIndexExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexExprContext createIndexExpr() {
		CreateIndexExprContext _localctx = new CreateIndexExprContext(Context, State);
		EnterRule(_localctx, 80, RULE_createIndexExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 969; Match(CREATE);
			State = 971;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENT) {
				{
				State = 970; _localctx.u = Match(IDENT);
				}
			}

			State = 973; Match(INDEX);
			State = 974; _localctx.n = Match(IDENT);
			State = 975; Match(ON);
			State = 976; _localctx.w = Match(IDENT);
			State = 977; Match(LPAREN);
			State = 978; createIndexColumnList();
			State = 979; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexColumnListContext : ParserRuleContext {
		public CreateIndexColumnContext[] createIndexColumn() {
			return GetRuleContexts<CreateIndexColumnContext>();
		}
		public CreateIndexColumnContext createIndexColumn(int i) {
			return GetRuleContext<CreateIndexColumnContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateIndexColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndexColumnList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateIndexColumnList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateIndexColumnList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateIndexColumnList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexColumnListContext createIndexColumnList() {
		CreateIndexColumnListContext _localctx = new CreateIndexColumnListContext(Context, State);
		EnterRule(_localctx, 82, RULE_createIndexColumnList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 981; createIndexColumn();
			State = 986;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 982; Match(COMMA);
				State = 983; createIndexColumn();
				}
				}
				State = 988;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexColumnContext : ParserRuleContext {
		public IToken c;
		public IToken t;
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public CreateIndexColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndexColumn; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateIndexColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateIndexColumn(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateIndexColumn(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexColumnContext createIndexColumn() {
		CreateIndexColumnContext _localctx = new CreateIndexColumnContext(Context, State);
		EnterRule(_localctx, 84, RULE_createIndexColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 989; _localctx.c = Match(IDENT);
			State = 991;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENT) {
				{
				State = 990; _localctx.t = Match(IDENT);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateVariableExprContext : ParserRuleContext {
		public IToken c;
		public IToken arr;
		public IToken p;
		public IToken n;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode VARIABLE() { return GetToken(EsperEPL2GrammarParser.VARIABLE, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public CreateVariableExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createVariableExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateVariableExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateVariableExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateVariableExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateVariableExprContext createVariableExpr() {
		CreateVariableExprContext _localctx = new CreateVariableExprContext(Context, State);
		EnterRule(_localctx, 86, RULE_createVariableExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 993; Match(CREATE);
			State = 995;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENT) {
				{
				State = 994; _localctx.c = Match(IDENT);
				}
			}

			State = 997; Match(VARIABLE);
			State = 998; classIdentifier();
			State = 1004;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LBRACK) {
				{
				State = 999; _localctx.arr = Match(LBRACK);
				State = 1001;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IDENT) {
					{
					State = 1000; _localctx.p = Match(IDENT);
					}
				}

				State = 1003; Match(RBRACK);
				}
			}

			State = 1006; _localctx.n = Match(IDENT);
			State = 1009;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUALS) {
				{
				State = 1007; Match(EQUALS);
				State = 1008; expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableExprContext : ParserRuleContext {
		public IToken n;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode TABLE() { return GetToken(EsperEPL2GrammarParser.TABLE, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public CreateTableColumnListContext createTableColumnList() {
			return GetRuleContext<CreateTableColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateTableExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateTableExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateTableExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTableExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableExprContext createTableExpr() {
		CreateTableExprContext _localctx = new CreateTableExprContext(Context, State);
		EnterRule(_localctx, 88, RULE_createTableExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1011; Match(CREATE);
			State = 1012; Match(TABLE);
			State = 1013; _localctx.n = Match(IDENT);
			State = 1015;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1014; Match(AS);
				}
			}

			State = 1017; Match(LPAREN);
			State = 1018; createTableColumnList();
			State = 1019; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableColumnListContext : ParserRuleContext {
		public CreateTableColumnContext[] createTableColumn() {
			return GetRuleContexts<CreateTableColumnContext>();
		}
		public CreateTableColumnContext createTableColumn(int i) {
			return GetRuleContext<CreateTableColumnContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateTableColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableColumnList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateTableColumnList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateTableColumnList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTableColumnList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableColumnListContext createTableColumnList() {
		CreateTableColumnListContext _localctx = new CreateTableColumnListContext(Context, State);
		EnterRule(_localctx, 90, RULE_createTableColumnList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1021; createTableColumn();
			State = 1026;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1022; Match(COMMA);
				State = 1023; createTableColumn();
				}
				}
				State = 1028;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableColumnContext : ParserRuleContext {
		public IToken n;
		public IToken p;
		public IToken k;
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public CreateTableColumnPlainContext createTableColumnPlain() {
			return GetRuleContext<CreateTableColumnPlainContext>(0);
		}
		public BuiltinFuncContext builtinFunc() {
			return GetRuleContext<BuiltinFuncContext>(0);
		}
		public LibFunctionContext libFunction() {
			return GetRuleContext<LibFunctionContext>(0);
		}
		public TypeExpressionAnnotationContext[] typeExpressionAnnotation() {
			return GetRuleContexts<TypeExpressionAnnotationContext>();
		}
		public TypeExpressionAnnotationContext typeExpressionAnnotation(int i) {
			return GetRuleContext<TypeExpressionAnnotationContext>(i);
		}
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public CreateTableColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableColumn; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateTableColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateTableColumn(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTableColumn(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableColumnContext createTableColumn() {
		CreateTableColumnContext _localctx = new CreateTableColumnContext(Context, State);
		EnterRule(_localctx, 92, RULE_createTableColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1029; _localctx.n = Match(IDENT);
			State = 1033;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,93,Context) ) {
			case 1:
				{
				State = 1030; createTableColumnPlain();
				}
				break;
			case 2:
				{
				State = 1031; builtinFunc();
				}
				break;
			case 3:
				{
				State = 1032; libFunction();
				}
				break;
			}
			State = 1036;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,94,Context) ) {
			case 1:
				{
				State = 1035; _localctx.p = Match(IDENT);
				}
				break;
			}
			State = 1039;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENT) {
				{
				State = 1038; _localctx.k = Match(IDENT);
				}
			}

			State = 1045;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ATCHAR) {
				{
				State = 1043;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,96,Context) ) {
				case 1:
					{
					State = 1041; typeExpressionAnnotation();
					}
					break;
				case 2:
					{
					State = 1042; annotationEnum();
					}
					break;
				}
				}
				State = 1047;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableColumnPlainContext : ParserRuleContext {
		public IToken b;
		public IToken p;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateTableColumnPlainContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableColumnPlain; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateTableColumnPlain(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateTableColumnPlain(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTableColumnPlain(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableColumnPlainContext createTableColumnPlain() {
		CreateTableColumnPlainContext _localctx = new CreateTableColumnPlainContext(Context, State);
		EnterRule(_localctx, 94, RULE_createTableColumnPlain);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1048; classIdentifier();
			State = 1054;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LBRACK) {
				{
				State = 1049; _localctx.b = Match(LBRACK);
				State = 1051;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IDENT) {
					{
					State = 1050; _localctx.p = Match(IDENT);
					}
				}

				State = 1053; Match(RBRACK);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateColumnListContext : ParserRuleContext {
		public CreateColumnListElementContext[] createColumnListElement() {
			return GetRuleContexts<CreateColumnListElementContext>();
		}
		public CreateColumnListElementContext createColumnListElement(int i) {
			return GetRuleContext<CreateColumnListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createColumnList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateColumnList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateColumnList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateColumnList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateColumnListContext createColumnList() {
		CreateColumnListContext _localctx = new CreateColumnListContext(Context, State);
		EnterRule(_localctx, 96, RULE_createColumnList);
		 paraphrases.Push("column list"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1056; createColumnListElement();
			State = 1061;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1057; Match(COMMA);
				State = 1058; createColumnListElement();
				}
				}
				State = 1063;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateColumnListElementContext : ParserRuleContext {
		public IToken b;
		public IToken p;
		public ClassIdentifierContext[] classIdentifier() {
			return GetRuleContexts<ClassIdentifierContext>();
		}
		public ClassIdentifierContext classIdentifier(int i) {
			return GetRuleContext<ClassIdentifierContext>(i);
		}
		public ITerminalNode VALUE_NULL() { return GetToken(EsperEPL2GrammarParser.VALUE_NULL, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateColumnListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createColumnListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateColumnListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateColumnListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateColumnListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateColumnListElementContext createColumnListElement() {
		CreateColumnListElementContext _localctx = new CreateColumnListElementContext(Context, State);
		EnterRule(_localctx, 98, RULE_createColumnListElement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1064; classIdentifier();
			State = 1074;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VALUE_NULL:
				{
				State = 1065; Match(VALUE_NULL);
				}
				break;
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				{
				State = 1066; classIdentifier();
				State = 1072;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LBRACK) {
					{
					State = 1067; _localctx.b = Match(LBRACK);
					State = 1069;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==IDENT) {
						{
						State = 1068; _localctx.p = Match(IDENT);
						}
					}

					State = 1071; Match(RBRACK);
					}
				}

				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSelectionListContext : ParserRuleContext {
		public CreateSelectionListElementContext[] createSelectionListElement() {
			return GetRuleContexts<CreateSelectionListElementContext>();
		}
		public CreateSelectionListElementContext createSelectionListElement(int i) {
			return GetRuleContext<CreateSelectionListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateSelectionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSelectionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSelectionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSelectionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSelectionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSelectionListContext createSelectionList() {
		CreateSelectionListContext _localctx = new CreateSelectionListContext(Context, State);
		EnterRule(_localctx, 100, RULE_createSelectionList);
		 paraphrases.Push("select clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1076; createSelectionListElement();
			State = 1081;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1077; Match(COMMA);
				State = 1078; createSelectionListElement();
				}
				}
				State = 1083;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSelectionListElementContext : ParserRuleContext {
		public IToken s;
		public IToken i;
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public CreateSelectionListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSelectionListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSelectionListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSelectionListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSelectionListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSelectionListElementContext createSelectionListElement() {
		CreateSelectionListElementContext _localctx = new CreateSelectionListElementContext(Context, State);
		EnterRule(_localctx, 102, RULE_createSelectionListElement);
		int _la;
		try {
			State = 1094;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STAR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1084; _localctx.s = Match(STAR);
				}
				break;
			case WINDOW:
			case ESCAPE:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case SCHEMA:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PRIOR:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case CONTEXT:
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1085; eventProperty();
				State = 1088;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 1086; Match(AS);
					State = 1087; _localctx.i = Match(IDENT);
					}
				}

				}
				break;
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case PLUS:
			case MINUS:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1090; constant();
				State = 1091; Match(AS);
				State = 1092; _localctx.i = Match(IDENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSchemaExprContext : ParserRuleContext {
		public IToken keyword;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public CreateSchemaDefContext createSchemaDef() {
			return GetRuleContext<CreateSchemaDefContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateSchemaExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSchemaExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSchemaExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSchemaExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSchemaExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSchemaExprContext createSchemaExpr() {
		CreateSchemaExprContext _localctx = new CreateSchemaExprContext(Context, State);
		EnterRule(_localctx, 104, RULE_createSchemaExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1096; Match(CREATE);
			State = 1098;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENT) {
				{
				State = 1097; _localctx.keyword = Match(IDENT);
				}
			}

			State = 1100; createSchemaDef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSchemaDefContext : ParserRuleContext {
		public IToken name;
		public ITerminalNode SCHEMA() { return GetToken(EsperEPL2GrammarParser.SCHEMA, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public VariantListContext variantList() {
			return GetRuleContext<VariantListContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateSchemaQualContext[] createSchemaQual() {
			return GetRuleContexts<CreateSchemaQualContext>();
		}
		public CreateSchemaQualContext createSchemaQual(int i) {
			return GetRuleContext<CreateSchemaQualContext>(i);
		}
		public CreateColumnListContext createColumnList() {
			return GetRuleContext<CreateColumnListContext>(0);
		}
		public CreateSchemaDefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSchemaDef; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSchemaDef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSchemaDef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSchemaDef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSchemaDefContext createSchemaDef() {
		CreateSchemaDefContext _localctx = new CreateSchemaDefContext(Context, State);
		EnterRule(_localctx, 106, RULE_createSchemaDef);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1102; Match(SCHEMA);
			State = 1103; _localctx.name = Match(IDENT);
			State = 1105;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1104; Match(AS);
				}
			}

			State = 1113;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EVENTS:
			case STAR:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 1107; variantList();
				}
				break;
			case LPAREN:
				{
				State = 1108; Match(LPAREN);
				State = 1110;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EVENTS || _la==TICKED_STRING_LITERAL || _la==IDENT) {
					{
					State = 1109; createColumnList();
					}
				}

				State = 1112; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1118;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==IDENT) {
				{
				{
				State = 1115; createSchemaQual();
				}
				}
				State = 1120;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FafDeleteContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode DELETE() { return GetToken(EsperEPL2GrammarParser.DELETE, 0); }
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public FafDeleteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fafDelete; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFafDelete(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFafDelete(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFafDelete(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FafDeleteContext fafDelete() {
		FafDeleteContext _localctx = new FafDeleteContext(Context, State);
		EnterRule(_localctx, 108, RULE_fafDelete);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1121; Match(DELETE);
			State = 1122; Match(FROM);
			State = 1123; classIdentifier();
			State = 1127;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 1124; Match(AS);
				State = 1125; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 1126; _localctx.i = Match(IDENT);
				}
				break;
			case Eof:
			case WHERE:
			case FOR:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1131;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 1129; Match(WHERE);
				State = 1130; whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FafUpdateContext : ParserRuleContext {
		public ITerminalNode UPDATE() { return GetToken(EsperEPL2GrammarParser.UPDATE, 0); }
		public UpdateDetailsContext updateDetails() {
			return GetRuleContext<UpdateDetailsContext>(0);
		}
		public FafUpdateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fafUpdate; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFafUpdate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFafUpdate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFafUpdate(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FafUpdateContext fafUpdate() {
		FafUpdateContext _localctx = new FafUpdateContext(Context, State);
		EnterRule(_localctx, 110, RULE_fafUpdate);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1133; Match(UPDATE);
			State = 1134; updateDetails();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FafInsertContext : ParserRuleContext {
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public InsertIntoExprContext insertIntoExpr() {
			return GetRuleContext<InsertIntoExprContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(EsperEPL2GrammarParser.VALUES, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public FafInsertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fafInsert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFafInsert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFafInsert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFafInsert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FafInsertContext fafInsert() {
		FafInsertContext _localctx = new FafInsertContext(Context, State);
		EnterRule(_localctx, 112, RULE_fafInsert);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1136; Match(INSERT);
			State = 1137; insertIntoExpr();
			State = 1138; Match(VALUES);
			State = 1139; Match(LPAREN);
			State = 1140; expressionList();
			State = 1141; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDataflowContext : ParserRuleContext {
		public IToken name;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode DATAFLOW() { return GetToken(EsperEPL2GrammarParser.DATAFLOW, 0); }
		public GopListContext gopList() {
			return GetRuleContext<GopListContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateDataflowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDataflow; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateDataflow(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateDataflow(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateDataflow(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateDataflowContext createDataflow() {
		CreateDataflowContext _localctx = new CreateDataflowContext(Context, State);
		EnterRule(_localctx, 114, RULE_createDataflow);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1143; Match(CREATE);
			State = 1144; Match(DATAFLOW);
			State = 1145; _localctx.name = Match(IDENT);
			State = 1147;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1146; Match(AS);
				}
			}

			State = 1149; gopList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopListContext : ParserRuleContext {
		public GopContext[] gop() {
			return GetRuleContexts<GopContext>();
		}
		public GopContext gop(int i) {
			return GetRuleContext<GopContext>(i);
		}
		public GopListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopListContext gopList() {
		GopListContext _localctx = new GopListContext(Context, State);
		EnterRule(_localctx, 116, RULE_gopList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1151; gop();
			State = 1155;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CREATE || _la==SELECT || _la==ATCHAR || _la==IDENT) {
				{
				{
				State = 1152; gop();
				}
				}
				State = 1157;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopContext : ParserRuleContext {
		public IToken opName;
		public IToken s;
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public GopParamsContext gopParams() {
			return GetRuleContext<GopParamsContext>(0);
		}
		public GopOutContext gopOut() {
			return GetRuleContext<GopOutContext>(0);
		}
		public GopDetailContext gopDetail() {
			return GetRuleContext<GopDetailContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public CreateSchemaExprContext createSchemaExpr() {
			return GetRuleContext<CreateSchemaExprContext>(0);
		}
		public GopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopContext gop() {
		GopContext _localctx = new GopContext(Context, State);
		EnterRule(_localctx, 118, RULE_gop);
		int _la;
		try {
			State = 1185;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
			case ATCHAR:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1161;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==ATCHAR) {
					{
					{
					State = 1158; annotationEnum();
					}
					}
					State = 1163;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1166;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IDENT:
					{
					State = 1164; _localctx.opName = Match(IDENT);
					}
					break;
				case SELECT:
					{
					State = 1165; _localctx.s = Match(SELECT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1169;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LPAREN) {
					{
					State = 1168; gopParams();
					}
				}

				State = 1172;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOLLOWED_BY) {
					{
					State = 1171; gopOut();
					}
				}

				State = 1174; Match(LCURLY);
				State = 1176;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SELECT || _la==IDENT) {
					{
					State = 1175; gopDetail();
					}
				}

				State = 1179;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1178; Match(COMMA);
					}
				}

				State = 1181; Match(RCURLY);
				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1182; createSchemaExpr();
				State = 1183; Match(COMMA);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public GopParamsItemListContext gopParamsItemList() {
			return GetRuleContext<GopParamsItemListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public GopParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParams; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParams(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParams(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParams(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsContext gopParams() {
		GopParamsContext _localctx = new GopParamsContext(Context, State);
		EnterRule(_localctx, 120, RULE_gopParams);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1187; Match(LPAREN);
			State = 1188; gopParamsItemList();
			State = 1189; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsItemListContext : ParserRuleContext {
		public GopParamsItemContext[] gopParamsItem() {
			return GetRuleContexts<GopParamsItemContext>();
		}
		public GopParamsItemContext gopParamsItem(int i) {
			return GetRuleContext<GopParamsItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GopParamsItemListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParamsItemList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParamsItemList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParamsItemList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParamsItemList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsItemListContext gopParamsItemList() {
		GopParamsItemListContext _localctx = new GopParamsItemListContext(Context, State);
		EnterRule(_localctx, 122, RULE_gopParamsItemList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1191; gopParamsItem();
			State = 1196;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1192; Match(COMMA);
				State = 1193; gopParamsItem();
				}
				}
				State = 1198;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsItemContext : ParserRuleContext {
		public ClassIdentifierContext n;
		public GopParamsItemManyContext gopParamsItemMany() {
			return GetRuleContext<GopParamsItemManyContext>(0);
		}
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public GopParamsItemAsContext gopParamsItemAs() {
			return GetRuleContext<GopParamsItemAsContext>(0);
		}
		public GopParamsItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParamsItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParamsItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParamsItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParamsItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsItemContext gopParamsItem() {
		GopParamsItemContext _localctx = new GopParamsItemContext(Context, State);
		EnterRule(_localctx, 124, RULE_gopParamsItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1201;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 1199; _localctx.n = classIdentifier();
				}
				break;
			case LPAREN:
				{
				State = 1200; gopParamsItemMany();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1204;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1203; gopParamsItemAs();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsItemManyContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ClassIdentifierContext[] classIdentifier() {
			return GetRuleContexts<ClassIdentifierContext>();
		}
		public ClassIdentifierContext classIdentifier(int i) {
			return GetRuleContext<ClassIdentifierContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public GopParamsItemManyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParamsItemMany; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParamsItemMany(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParamsItemMany(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParamsItemMany(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsItemManyContext gopParamsItemMany() {
		GopParamsItemManyContext _localctx = new GopParamsItemManyContext(Context, State);
		EnterRule(_localctx, 126, RULE_gopParamsItemMany);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1206; Match(LPAREN);
			State = 1207; classIdentifier();
			{
			State = 1208; Match(COMMA);
			State = 1209; classIdentifier();
			}
			State = 1211; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsItemAsContext : ParserRuleContext {
		public IToken a;
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public GopParamsItemAsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParamsItemAs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParamsItemAs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParamsItemAs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParamsItemAs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsItemAsContext gopParamsItemAs() {
		GopParamsItemAsContext _localctx = new GopParamsItemAsContext(Context, State);
		EnterRule(_localctx, 128, RULE_gopParamsItemAs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1213; Match(AS);
			State = 1214; _localctx.a = Match(IDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutContext : ParserRuleContext {
		public ITerminalNode FOLLOWED_BY() { return GetToken(EsperEPL2GrammarParser.FOLLOWED_BY, 0); }
		public GopOutItemContext[] gopOutItem() {
			return GetRuleContexts<GopOutItemContext>();
		}
		public GopOutItemContext gopOutItem(int i) {
			return GetRuleContext<GopOutItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GopOutContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOut; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOut(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOut(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOut(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutContext gopOut() {
		GopOutContext _localctx = new GopOutContext(Context, State);
		EnterRule(_localctx, 130, RULE_gopOut);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1216; Match(FOLLOWED_BY);
			State = 1217; gopOutItem();
			State = 1222;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1218; Match(COMMA);
				State = 1219; gopOutItem();
				}
				}
				State = 1224;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutItemContext : ParserRuleContext {
		public ClassIdentifierContext n;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public GopOutTypeListContext gopOutTypeList() {
			return GetRuleContext<GopOutTypeListContext>(0);
		}
		public GopOutItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOutItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOutItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOutItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOutItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutItemContext gopOutItem() {
		GopOutItemContext _localctx = new GopOutItemContext(Context, State);
		EnterRule(_localctx, 132, RULE_gopOutItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1225; _localctx.n = classIdentifier();
			State = 1227;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 1226; gopOutTypeList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutTypeListContext : ParserRuleContext {
		public ITerminalNode LT() { return GetToken(EsperEPL2GrammarParser.LT, 0); }
		public GopOutTypeParamContext[] gopOutTypeParam() {
			return GetRuleContexts<GopOutTypeParamContext>();
		}
		public GopOutTypeParamContext gopOutTypeParam(int i) {
			return GetRuleContext<GopOutTypeParamContext>(i);
		}
		public ITerminalNode GT() { return GetToken(EsperEPL2GrammarParser.GT, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GopOutTypeListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOutTypeList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOutTypeList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOutTypeList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOutTypeList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutTypeListContext gopOutTypeList() {
		GopOutTypeListContext _localctx = new GopOutTypeListContext(Context, State);
		EnterRule(_localctx, 134, RULE_gopOutTypeList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1229; Match(LT);
			State = 1230; gopOutTypeParam();
			State = 1235;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1231; Match(COMMA);
				State = 1232; gopOutTypeParam();
				}
				}
				State = 1237;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1238; Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutTypeParamContext : ParserRuleContext {
		public IToken q;
		public GopOutTypeItemContext gopOutTypeItem() {
			return GetRuleContext<GopOutTypeItemContext>(0);
		}
		public ITerminalNode QUESTION() { return GetToken(EsperEPL2GrammarParser.QUESTION, 0); }
		public GopOutTypeParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOutTypeParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOutTypeParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOutTypeParam(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOutTypeParam(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutTypeParamContext gopOutTypeParam() {
		GopOutTypeParamContext _localctx = new GopOutTypeParamContext(Context, State);
		EnterRule(_localctx, 136, RULE_gopOutTypeParam);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1242;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 1240; gopOutTypeItem();
				}
				break;
			case QUESTION:
				{
				State = 1241; _localctx.q = Match(QUESTION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutTypeItemContext : ParserRuleContext {
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public GopOutTypeListContext gopOutTypeList() {
			return GetRuleContext<GopOutTypeListContext>(0);
		}
		public GopOutTypeItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOutTypeItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOutTypeItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOutTypeItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOutTypeItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutTypeItemContext gopOutTypeItem() {
		GopOutTypeItemContext _localctx = new GopOutTypeItemContext(Context, State);
		EnterRule(_localctx, 138, RULE_gopOutTypeItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1244; classIdentifier();
			State = 1246;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT) {
				{
				State = 1245; gopOutTypeList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopDetailContext : ParserRuleContext {
		public GopConfigContext[] gopConfig() {
			return GetRuleContexts<GopConfigContext>();
		}
		public GopConfigContext gopConfig(int i) {
			return GetRuleContext<GopConfigContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GopDetailContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopDetail; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopDetail(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopDetail(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopDetail(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopDetailContext gopDetail() {
		GopDetailContext _localctx = new GopDetailContext(Context, State);
		EnterRule(_localctx, 140, RULE_gopDetail);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1248; gopConfig();
			State = 1253;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,131,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1249; Match(COMMA);
					State = 1250; gopConfig();
					}
					} 
				}
				State = 1255;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,131,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopConfigContext : ParserRuleContext {
		public IToken n;
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public SelectExprContext selectExpr() {
			return GetRuleContext<SelectExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public JsonobjectContext jsonobject() {
			return GetRuleContext<JsonobjectContext>(0);
		}
		public JsonarrayContext jsonarray() {
			return GetRuleContext<JsonarrayContext>(0);
		}
		public GopConfigContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopConfig; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopConfig(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopConfig(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopConfig(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopConfigContext gopConfig() {
		GopConfigContext _localctx = new GopConfigContext(Context, State);
		EnterRule(_localctx, 142, RULE_gopConfig);
		int _la;
		try {
			State = 1269;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1256; Match(SELECT);
				State = 1257;
				_la = TokenStream.LA(1);
				if ( !(_la==EQUALS || _la==COLON) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1258; Match(LPAREN);
				State = 1259; selectExpr();
				State = 1260; Match(RPAREN);
				}
				break;
			case IDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1262; _localctx.n = Match(IDENT);
				State = 1263;
				_la = TokenStream.LA(1);
				if ( !(_la==EQUALS || _la==COLON) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1267;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,132,Context) ) {
				case 1:
					{
					State = 1264; expression();
					}
					break;
				case 2:
					{
					State = 1265; jsonobject();
					}
					break;
				case 3:
					{
					State = 1266; jsonarray();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextExprContext : ParserRuleContext {
		public IToken name;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode CONTEXT() { return GetToken(EsperEPL2GrammarParser.CONTEXT, 0); }
		public CreateContextDetailContext createContextDetail() {
			return GetRuleContext<CreateContextDetailContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateContextExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextExprContext createContextExpr() {
		CreateContextExprContext _localctx = new CreateContextExprContext(Context, State);
		EnterRule(_localctx, 144, RULE_createContextExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1271; Match(CREATE);
			State = 1272; Match(CONTEXT);
			State = 1273; _localctx.name = Match(IDENT);
			State = 1275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1274; Match(AS);
				}
			}

			State = 1277; createContextDetail();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateExpressionExprContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ExpressionDeclContext expressionDecl() {
			return GetRuleContext<ExpressionDeclContext>(0);
		}
		public CreateExpressionExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createExpressionExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateExpressionExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateExpressionExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateExpressionExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateExpressionExprContext createExpressionExpr() {
		CreateExpressionExprContext _localctx = new CreateExpressionExprContext(Context, State);
		EnterRule(_localctx, 146, RULE_createExpressionExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1279; Match(CREATE);
			State = 1280; expressionDecl();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextDetailContext : ParserRuleContext {
		public CreateContextChoiceContext createContextChoice() {
			return GetRuleContext<CreateContextChoiceContext>(0);
		}
		public ContextContextNestedContext[] contextContextNested() {
			return GetRuleContexts<ContextContextNestedContext>();
		}
		public ContextContextNestedContext contextContextNested(int i) {
			return GetRuleContext<ContextContextNestedContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateContextDetailContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextDetail; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextDetail(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextDetail(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextDetail(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextDetailContext createContextDetail() {
		CreateContextDetailContext _localctx = new CreateContextDetailContext(Context, State);
		EnterRule(_localctx, 148, RULE_createContextDetail);
		int _la;
		try {
			State = 1293;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COALESCE:
			case GROUP:
			case PARTITION:
			case START:
			case INITIATED:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1282; createContextChoice();
				}
				break;
			case CONTEXT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1283; contextContextNested();
				State = 1284; Match(COMMA);
				State = 1285; contextContextNested();
				State = 1290;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1286; Match(COMMA);
					State = 1287; contextContextNested();
					}
					}
					State = 1292;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ContextContextNestedContext : ParserRuleContext {
		public IToken name;
		public ITerminalNode CONTEXT() { return GetToken(EsperEPL2GrammarParser.CONTEXT, 0); }
		public CreateContextChoiceContext createContextChoice() {
			return GetRuleContext<CreateContextChoiceContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ContextContextNestedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_contextContextNested; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterContextContextNested(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitContextContextNested(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContextContextNested(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ContextContextNestedContext contextContextNested() {
		ContextContextNestedContext _localctx = new ContextContextNestedContext(Context, State);
		EnterRule(_localctx, 150, RULE_contextContextNested);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1295; Match(CONTEXT);
			State = 1296; _localctx.name = Match(IDENT);
			State = 1298;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1297; Match(AS);
				}
			}

			State = 1300; createContextChoice();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextChoiceContext : ParserRuleContext {
		public IToken i;
		public CreateContextRangePointContext r1;
		public CreateContextRangePointContext r2;
		public IToken g;
		public IToken p;
		public ITerminalNode START() { return GetToken(EsperEPL2GrammarParser.START, 0); }
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public CreateContextRangePointContext[] createContextRangePoint() {
			return GetRuleContexts<CreateContextRangePointContext>();
		}
		public CreateContextRangePointContext createContextRangePoint(int i) {
			return GetRuleContext<CreateContextRangePointContext>(i);
		}
		public ITerminalNode END() { return GetToken(EsperEPL2GrammarParser.END, 0); }
		public ITerminalNode INITIATED() { return GetToken(EsperEPL2GrammarParser.INITIATED, 0); }
		public ITerminalNode[] BY() { return GetTokens(EsperEPL2GrammarParser.BY); }
		public ITerminalNode BY(int i) {
			return GetToken(EsperEPL2GrammarParser.BY, i);
		}
		public CreateContextDistinctContext createContextDistinct() {
			return GetRuleContext<CreateContextDistinctContext>(0);
		}
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public ITerminalNode TERMINATED() { return GetToken(EsperEPL2GrammarParser.TERMINATED, 0); }
		public ITerminalNode PARTITION() { return GetToken(EsperEPL2GrammarParser.PARTITION, 0); }
		public CreateContextPartitionItemContext[] createContextPartitionItem() {
			return GetRuleContexts<CreateContextPartitionItemContext>();
		}
		public CreateContextPartitionItemContext createContextPartitionItem(int i) {
			return GetRuleContext<CreateContextPartitionItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateContextGroupItemContext[] createContextGroupItem() {
			return GetRuleContexts<CreateContextGroupItemContext>();
		}
		public CreateContextGroupItemContext createContextGroupItem(int i) {
			return GetRuleContext<CreateContextGroupItemContext>(i);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public ITerminalNode COALESCE() { return GetToken(EsperEPL2GrammarParser.COALESCE, 0); }
		public CreateContextCoalesceItemContext[] createContextCoalesceItem() {
			return GetRuleContexts<CreateContextCoalesceItemContext>();
		}
		public CreateContextCoalesceItemContext createContextCoalesceItem(int i) {
			return GetRuleContext<CreateContextCoalesceItemContext>(i);
		}
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public CreateContextChoiceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextChoice; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextChoice(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextChoice(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextChoice(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextChoiceContext createContextChoice() {
		CreateContextChoiceContext _localctx = new CreateContextChoiceContext(Context, State);
		EnterRule(_localctx, 152, RULE_createContextChoice);
		int _la;
		try {
			int _alt;
			State = 1372;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case START:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1302; Match(START);
				State = 1306;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ATCHAR:
					{
					State = 1303; Match(ATCHAR);
					State = 1304; _localctx.i = Match(IDENT);
					}
					break;
				case EVENTS:
				case PATTERN:
				case AFTER:
				case LPAREN:
				case TICKED_STRING_LITERAL:
				case IDENT:
					{
					State = 1305; _localctx.r1 = createContextRangePoint();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1310;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==END) {
					{
					State = 1308; Match(END);
					State = 1309; _localctx.r2 = createContextRangePoint();
					}
				}

				}
				break;
			case INITIATED:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1312; Match(INITIATED);
				State = 1314;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BY) {
					{
					State = 1313; Match(BY);
					}
				}

				State = 1317;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DISTINCT) {
					{
					State = 1316; createContextDistinct();
					}
				}

				State = 1322;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ATCHAR) {
					{
					State = 1319; Match(ATCHAR);
					State = 1320; _localctx.i = Match(IDENT);
					State = 1321; Match(AND_EXPR);
					}
				}

				State = 1324; _localctx.r1 = createContextRangePoint();
				State = 1330;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TERMINATED) {
					{
					State = 1325; Match(TERMINATED);
					State = 1327;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==BY) {
						{
						State = 1326; Match(BY);
						}
					}

					State = 1329; _localctx.r2 = createContextRangePoint();
					}
				}

				}
				break;
			case PARTITION:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1332; Match(PARTITION);
				State = 1334;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BY) {
					{
					State = 1333; Match(BY);
					}
				}

				State = 1336; createContextPartitionItem();
				State = 1341;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,146,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1337; Match(COMMA);
						State = 1338; createContextPartitionItem();
						}
						} 
					}
					State = 1343;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,146,Context);
				}
				}
				break;
			case GROUP:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1344; createContextGroupItem();
				State = 1349;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1345; Match(COMMA);
					State = 1346; createContextGroupItem();
					}
					}
					State = 1351;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1352; Match(FROM);
				State = 1353; eventFilterExpression();
				}
				break;
			case COALESCE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1355; Match(COALESCE);
				State = 1357;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BY) {
					{
					State = 1356; Match(BY);
					}
				}

				State = 1359; createContextCoalesceItem();
				State = 1364;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1360; Match(COMMA);
					State = 1361; createContextCoalesceItem();
					}
					}
					State = 1366;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1367; _localctx.g = Match(IDENT);
				State = 1368; number();
				State = 1370;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IDENT) {
					{
					State = 1369; _localctx.p = Match(IDENT);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextDistinctContext : ParserRuleContext {
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public CreateContextDistinctContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextDistinct; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextDistinct(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextDistinct(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextDistinct(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextDistinctContext createContextDistinct() {
		CreateContextDistinctContext _localctx = new CreateContextDistinctContext(Context, State);
		EnterRule(_localctx, 154, RULE_createContextDistinct);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1374; Match(DISTINCT);
			State = 1375; Match(LPAREN);
			State = 1377;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
				{
				State = 1376; expressionList();
				}
			}

			State = 1379; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextRangePointContext : ParserRuleContext {
		public IToken i;
		public CreateContextFilterContext createContextFilter() {
			return GetRuleContext<CreateContextFilterContext>(0);
		}
		public PatternInclusionExpressionContext patternInclusionExpression() {
			return GetRuleContext<PatternInclusionExpressionContext>(0);
		}
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CrontabLimitParameterSetContext crontabLimitParameterSet() {
			return GetRuleContext<CrontabLimitParameterSetContext>(0);
		}
		public ITerminalNode AFTER() { return GetToken(EsperEPL2GrammarParser.AFTER, 0); }
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public CreateContextRangePointContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextRangePoint; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextRangePoint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextRangePoint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextRangePoint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextRangePointContext createContextRangePoint() {
		CreateContextRangePointContext _localctx = new CreateContextRangePointContext(Context, State);
		EnterRule(_localctx, 156, RULE_createContextRangePoint);
		int _la;
		try {
			State = 1390;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1381; createContextFilter();
				}
				break;
			case PATTERN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1382; patternInclusionExpression();
				State = 1385;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ATCHAR) {
					{
					State = 1383; Match(ATCHAR);
					State = 1384; _localctx.i = Match(IDENT);
					}
				}

				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1387; crontabLimitParameterSet();
				}
				break;
			case AFTER:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1388; Match(AFTER);
				State = 1389; timePeriod();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextFilterContext : ParserRuleContext {
		public IToken i;
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateContextFilterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextFilter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextFilter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextFilter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextFilterContext createContextFilter() {
		CreateContextFilterContext _localctx = new CreateContextFilterContext(Context, State);
		EnterRule(_localctx, 158, RULE_createContextFilter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1392; eventFilterExpression();
			State = 1397;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS || _la==IDENT) {
				{
				State = 1394;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 1393; Match(AS);
					}
				}

				State = 1396; _localctx.i = Match(IDENT);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextPartitionItemContext : ParserRuleContext {
		public EventPropertyContext[] eventProperty() {
			return GetRuleContexts<EventPropertyContext>();
		}
		public EventPropertyContext eventProperty(int i) {
			return GetRuleContext<EventPropertyContext>(i);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateContextPartitionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextPartitionItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextPartitionItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextPartitionItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextPartitionItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextPartitionItemContext createContextPartitionItem() {
		CreateContextPartitionItemContext _localctx = new CreateContextPartitionItemContext(Context, State);
		EnterRule(_localctx, 160, RULE_createContextPartitionItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1399; eventProperty();
			State = 1404;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AND_EXPR || _la==COMMA) {
				{
				{
				State = 1400;
				_la = TokenStream.LA(1);
				if ( !(_la==AND_EXPR || _la==COMMA) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1401; eventProperty();
				}
				}
				State = 1406;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1407; Match(FROM);
			State = 1408; eventFilterExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextCoalesceItemContext : ParserRuleContext {
		public LibFunctionNoClassContext libFunctionNoClass() {
			return GetRuleContext<LibFunctionNoClassContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public CreateContextCoalesceItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextCoalesceItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextCoalesceItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextCoalesceItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextCoalesceItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextCoalesceItemContext createContextCoalesceItem() {
		CreateContextCoalesceItemContext _localctx = new CreateContextCoalesceItemContext(Context, State);
		EnterRule(_localctx, 162, RULE_createContextCoalesceItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1410; libFunctionNoClass();
			State = 1411; Match(FROM);
			State = 1412; eventFilterExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextGroupItemContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode GROUP() { return GetToken(EsperEPL2GrammarParser.GROUP, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode BY() { return GetToken(EsperEPL2GrammarParser.BY, 0); }
		public CreateContextGroupItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextGroupItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextGroupItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextGroupItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextGroupItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextGroupItemContext createContextGroupItem() {
		CreateContextGroupItemContext _localctx = new CreateContextGroupItemContext(Context, State);
		EnterRule(_localctx, 164, RULE_createContextGroupItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1414; Match(GROUP);
			State = 1416;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BY) {
				{
				State = 1415; Match(BY);
				}
			}

			State = 1418; expression();
			State = 1419; Match(AS);
			State = 1420; _localctx.i = Match(IDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSchemaQualContext : ParserRuleContext {
		public IToken i;
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateSchemaQualContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSchemaQual; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSchemaQual(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSchemaQual(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSchemaQual(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSchemaQualContext createSchemaQual() {
		CreateSchemaQualContext _localctx = new CreateSchemaQualContext(Context, State);
		EnterRule(_localctx, 166, RULE_createSchemaQual);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1422; _localctx.i = Match(IDENT);
			State = 1423; columnList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariantListContext : ParserRuleContext {
		public VariantListElementContext[] variantListElement() {
			return GetRuleContexts<VariantListElementContext>();
		}
		public VariantListElementContext variantListElement(int i) {
			return GetRuleContext<VariantListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public VariantListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variantList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterVariantList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitVariantList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariantList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariantListContext variantList() {
		VariantListContext _localctx = new VariantListContext(Context, State);
		EnterRule(_localctx, 168, RULE_variantList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1425; variantListElement();
			State = 1430;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,159,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1426; Match(COMMA);
					State = 1427; variantListElement();
					}
					} 
				}
				State = 1432;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,159,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariantListElementContext : ParserRuleContext {
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public VariantListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variantListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterVariantListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitVariantListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariantListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariantListElementContext variantListElement() {
		VariantListElementContext _localctx = new VariantListElementContext(Context, State);
		EnterRule(_localctx, 170, RULE_variantListElement);
		try {
			State = 1435;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STAR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1433; Match(STAR);
				}
				break;
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1434; classIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntoTableExprContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TABLE() { return GetToken(EsperEPL2GrammarParser.TABLE, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public IntoTableExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intoTableExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterIntoTableExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitIntoTableExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntoTableExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntoTableExprContext intoTableExpr() {
		IntoTableExprContext _localctx = new IntoTableExprContext(Context, State);
		EnterRule(_localctx, 172, RULE_intoTableExpr);
		 paraphrases.Push("into-table clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1437; Match(TABLE);
			State = 1438; _localctx.i = Match(IDENT);
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertIntoExprContext : ParserRuleContext {
		public IToken i;
		public IToken r;
		public IToken ir;
		public ITerminalNode INTO() { return GetToken(EsperEPL2GrammarParser.INTO, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ISTREAM() { return GetToken(EsperEPL2GrammarParser.ISTREAM, 0); }
		public ITerminalNode RSTREAM() { return GetToken(EsperEPL2GrammarParser.RSTREAM, 0); }
		public ITerminalNode IRSTREAM() { return GetToken(EsperEPL2GrammarParser.IRSTREAM, 0); }
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public InsertIntoExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertIntoExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterInsertIntoExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitInsertIntoExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertIntoExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertIntoExprContext insertIntoExpr() {
		InsertIntoExprContext _localctx = new InsertIntoExprContext(Context, State);
		EnterRule(_localctx, 174, RULE_insertIntoExpr);
		 paraphrases.Push("insert-into clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1443;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ISTREAM:
				{
				State = 1440; _localctx.i = Match(ISTREAM);
				}
				break;
			case RSTREAM:
				{
				State = 1441; _localctx.r = Match(RSTREAM);
				}
				break;
			case IRSTREAM:
				{
				State = 1442; _localctx.ir = Match(IRSTREAM);
				}
				break;
			case INTO:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1445; Match(INTO);
			State = 1446; classIdentifier();
			State = 1452;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 1447; Match(LPAREN);
				State = 1449;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IDENT) {
					{
					State = 1448; columnList();
					}
				}

				State = 1451; Match(RPAREN);
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListContext : ParserRuleContext {
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterColumnList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitColumnList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumnList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListContext columnList() {
		ColumnListContext _localctx = new ColumnListContext(Context, State);
		EnterRule(_localctx, 176, RULE_columnList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1454; Match(IDENT);
			State = 1459;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,164,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1455; Match(COMMA);
					State = 1456; Match(IDENT);
					}
					} 
				}
				State = 1461;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,164,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseContext : ParserRuleContext {
		public StreamExpressionContext streamExpression() {
			return GetRuleContext<StreamExpressionContext>(0);
		}
		public RegularJoinContext regularJoin() {
			return GetRuleContext<RegularJoinContext>(0);
		}
		public OuterJoinListContext outerJoinList() {
			return GetRuleContext<OuterJoinListContext>(0);
		}
		public FromClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFromClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFromClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFromClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseContext fromClause() {
		FromClauseContext _localctx = new FromClauseContext(Context, State);
		EnterRule(_localctx, 178, RULE_fromClause);
		 paraphrases.Push("from clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1462; streamExpression();
			State = 1465;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Eof:
			case WHERE:
			case GROUP:
			case HAVING:
			case OUTPUT:
			case ORDER:
			case ROW_LIMIT_EXPR:
			case MATCH_RECOGNIZE:
			case FOR:
			case RPAREN:
			case COMMA:
				{
				State = 1463; regularJoin();
				}
				break;
			case INNER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
				{
				State = 1464; outerJoinList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegularJoinContext : ParserRuleContext {
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public StreamExpressionContext[] streamExpression() {
			return GetRuleContexts<StreamExpressionContext>();
		}
		public StreamExpressionContext streamExpression(int i) {
			return GetRuleContext<StreamExpressionContext>(i);
		}
		public RegularJoinContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regularJoin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterRegularJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitRegularJoin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegularJoin(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RegularJoinContext regularJoin() {
		RegularJoinContext _localctx = new RegularJoinContext(Context, State);
		EnterRule(_localctx, 180, RULE_regularJoin);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1471;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1467; Match(COMMA);
				State = 1468; streamExpression();
				}
				}
				State = 1473;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinListContext : ParserRuleContext {
		public OuterJoinContext[] outerJoin() {
			return GetRuleContexts<OuterJoinContext>();
		}
		public OuterJoinContext outerJoin(int i) {
			return GetRuleContext<OuterJoinContext>(i);
		}
		public OuterJoinListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoinList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOuterJoinList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOuterJoinList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuterJoinList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinListContext outerJoinList() {
		OuterJoinListContext _localctx = new OuterJoinListContext(Context, State);
		EnterRule(_localctx, 182, RULE_outerJoinList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1474; outerJoin();
			State = 1478;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INNER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL))) != 0)) {
				{
				{
				State = 1475; outerJoin();
				}
				}
				State = 1480;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinContext : ParserRuleContext {
		public IToken tl;
		public IToken tr;
		public IToken tf;
		public IToken i;
		public ITerminalNode JOIN() { return GetToken(EsperEPL2GrammarParser.JOIN, 0); }
		public StreamExpressionContext streamExpression() {
			return GetRuleContext<StreamExpressionContext>(0);
		}
		public OuterJoinIdentContext outerJoinIdent() {
			return GetRuleContext<OuterJoinIdentContext>(0);
		}
		public ITerminalNode OUTER() { return GetToken(EsperEPL2GrammarParser.OUTER, 0); }
		public ITerminalNode INNER() { return GetToken(EsperEPL2GrammarParser.INNER, 0); }
		public ITerminalNode LEFT() { return GetToken(EsperEPL2GrammarParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(EsperEPL2GrammarParser.RIGHT, 0); }
		public ITerminalNode FULL() { return GetToken(EsperEPL2GrammarParser.FULL, 0); }
		public OuterJoinContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOuterJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOuterJoin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuterJoin(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinContext outerJoin() {
		OuterJoinContext _localctx = new OuterJoinContext(Context, State);
		EnterRule(_localctx, 184, RULE_outerJoin);
		 paraphrases.Push("outer join"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1490;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
				{
				State = 1487;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LEFT) | (1L << RIGHT) | (1L << FULL))) != 0)) {
					{
					State = 1484;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case LEFT:
						{
						State = 1481; _localctx.tl = Match(LEFT);
						}
						break;
					case RIGHT:
						{
						State = 1482; _localctx.tr = Match(RIGHT);
						}
						break;
					case FULL:
						{
						State = 1483; _localctx.tf = Match(FULL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 1486; Match(OUTER);
					}
				}

				}
				break;
			case INNER:
				{
				{
				State = 1489; _localctx.i = Match(INNER);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1492; Match(JOIN);
			State = 1493; streamExpression();
			State = 1495;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 1494; outerJoinIdent();
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinIdentContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(EsperEPL2GrammarParser.ON, 0); }
		public OuterJoinIdentPairContext[] outerJoinIdentPair() {
			return GetRuleContexts<OuterJoinIdentPairContext>();
		}
		public OuterJoinIdentPairContext outerJoinIdentPair(int i) {
			return GetRuleContext<OuterJoinIdentPairContext>(i);
		}
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public OuterJoinIdentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoinIdent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOuterJoinIdent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOuterJoinIdent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuterJoinIdent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinIdentContext outerJoinIdent() {
		OuterJoinIdentContext _localctx = new OuterJoinIdentContext(Context, State);
		EnterRule(_localctx, 186, RULE_outerJoinIdent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1497; Match(ON);
			State = 1498; outerJoinIdentPair();
			State = 1503;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AND_EXPR) {
				{
				{
				State = 1499; Match(AND_EXPR);
				State = 1500; outerJoinIdentPair();
				}
				}
				State = 1505;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinIdentPairContext : ParserRuleContext {
		public EventPropertyContext[] eventProperty() {
			return GetRuleContexts<EventPropertyContext>();
		}
		public EventPropertyContext eventProperty(int i) {
			return GetRuleContext<EventPropertyContext>(i);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public OuterJoinIdentPairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoinIdentPair; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOuterJoinIdentPair(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOuterJoinIdentPair(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuterJoinIdentPair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinIdentPairContext outerJoinIdentPair() {
		OuterJoinIdentPairContext _localctx = new OuterJoinIdentPairContext(Context, State);
		EnterRule(_localctx, 188, RULE_outerJoinIdentPair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1506; eventProperty();
			State = 1507; Match(EQUALS);
			State = 1508; eventProperty();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhereClauseContext : ParserRuleContext {
		public EvalOrExpressionContext evalOrExpression() {
			return GetRuleContext<EvalOrExpressionContext>(0);
		}
		public WhereClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whereClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterWhereClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitWhereClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhereClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhereClauseContext whereClause() {
		WhereClauseContext _localctx = new WhereClauseContext(Context, State);
		EnterRule(_localctx, 190, RULE_whereClause);
		 paraphrases.Push("where clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1510; evalOrExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectClauseContext : ParserRuleContext {
		public IToken s;
		public IToken d;
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public ITerminalNode RSTREAM() { return GetToken(EsperEPL2GrammarParser.RSTREAM, 0); }
		public ITerminalNode ISTREAM() { return GetToken(EsperEPL2GrammarParser.ISTREAM, 0); }
		public ITerminalNode IRSTREAM() { return GetToken(EsperEPL2GrammarParser.IRSTREAM, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public SelectClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectClauseContext selectClause() {
		SelectClauseContext _localctx = new SelectClauseContext(Context, State);
		EnterRule(_localctx, 192, RULE_selectClause);
		 paraphrases.Push("select clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1515;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,173,Context) ) {
			case 1:
				{
				State = 1512; _localctx.s = Match(RSTREAM);
				}
				break;
			case 2:
				{
				State = 1513; _localctx.s = Match(ISTREAM);
				}
				break;
			case 3:
				{
				State = 1514; _localctx.s = Match(IRSTREAM);
				}
				break;
			}
			State = 1518;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISTINCT) {
				{
				State = 1517; _localctx.d = Match(DISTINCT);
				}
			}

			State = 1520; selectionList();
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionListContext : ParserRuleContext {
		public SelectionListElementContext[] selectionListElement() {
			return GetRuleContexts<SelectionListElementContext>();
		}
		public SelectionListElementContext selectionListElement(int i) {
			return GetRuleContext<SelectionListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public SelectionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionListContext selectionList() {
		SelectionListContext _localctx = new SelectionListContext(Context, State);
		EnterRule(_localctx, 194, RULE_selectionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1522; selectionListElement();
			State = 1527;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1523; Match(COMMA);
				State = 1524; selectionListElement();
				}
				}
				State = 1529;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionListElementContext : ParserRuleContext {
		public IToken s;
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public StreamSelectorContext streamSelector() {
			return GetRuleContext<StreamSelectorContext>(0);
		}
		public SelectionListElementExprContext selectionListElementExpr() {
			return GetRuleContext<SelectionListElementExprContext>(0);
		}
		public SelectionListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionListElementContext selectionListElement() {
		SelectionListElementContext _localctx = new SelectionListElementContext(Context, State);
		EnterRule(_localctx, 196, RULE_selectionListElement);
		try {
			State = 1533;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,176,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1530; _localctx.s = Match(STAR);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1531; streamSelector();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1532; selectionListElementExpr();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionListElementExprContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SelectionListElementAnnoContext selectionListElementAnno() {
			return GetRuleContext<SelectionListElementAnnoContext>(0);
		}
		public KeywordAllowedIdentContext keywordAllowedIdent() {
			return GetRuleContext<KeywordAllowedIdentContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public SelectionListElementExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionListElementExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionListElementExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionListElementExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionListElementExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionListElementExprContext selectionListElementExpr() {
		SelectionListElementExprContext _localctx = new SelectionListElementExprContext(Context, State);
		EnterRule(_localctx, 198, RULE_selectionListElementExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1535; expression();
			State = 1537;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ATCHAR) {
				{
				State = 1536; selectionListElementAnno();
				}
			}

			State = 1543;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,179,Context) ) {
			case 1:
				{
				State = 1540;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 1539; Match(AS);
					}
				}

				State = 1542; keywordAllowedIdent();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionListElementAnnoContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public SelectionListElementAnnoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionListElementAnno; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionListElementAnno(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionListElementAnno(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionListElementAnno(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionListElementAnnoContext selectionListElementAnno() {
		SelectionListElementAnnoContext _localctx = new SelectionListElementAnnoContext(Context, State);
		EnterRule(_localctx, 200, RULE_selectionListElementAnno);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1545; Match(ATCHAR);
			State = 1546; _localctx.i = Match(IDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StreamSelectorContext : ParserRuleContext {
		public IToken s;
		public IToken i;
		public ITerminalNode DOT() { return GetToken(EsperEPL2GrammarParser.DOT, 0); }
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public StreamSelectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_streamSelector; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStreamSelector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStreamSelector(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStreamSelector(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StreamSelectorContext streamSelector() {
		StreamSelectorContext _localctx = new StreamSelectorContext(Context, State);
		EnterRule(_localctx, 202, RULE_streamSelector);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1548; _localctx.s = Match(IDENT);
			State = 1549; Match(DOT);
			State = 1550; Match(STAR);
			State = 1553;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1551; Match(AS);
				State = 1552; _localctx.i = Match(IDENT);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StreamExpressionContext : ParserRuleContext {
		public IToken i;
		public IToken u;
		public IToken ru;
		public IToken ri;
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public PatternInclusionExpressionContext patternInclusionExpression() {
			return GetRuleContext<PatternInclusionExpressionContext>(0);
		}
		public DatabaseJoinExpressionContext databaseJoinExpression() {
			return GetRuleContext<DatabaseJoinExpressionContext>(0);
		}
		public MethodJoinExpressionContext methodJoinExpression() {
			return GetRuleContext<MethodJoinExpressionContext>(0);
		}
		public ViewExpressionsContext viewExpressions() {
			return GetRuleContext<ViewExpressionsContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode UNIDIRECTIONAL() { return GetToken(EsperEPL2GrammarParser.UNIDIRECTIONAL, 0); }
		public ITerminalNode RETAINUNION() { return GetToken(EsperEPL2GrammarParser.RETAINUNION, 0); }
		public ITerminalNode RETAININTERSECTION() { return GetToken(EsperEPL2GrammarParser.RETAININTERSECTION, 0); }
		public StreamExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_streamExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStreamExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStreamExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStreamExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StreamExpressionContext streamExpression() {
		StreamExpressionContext _localctx = new StreamExpressionContext(Context, State);
		EnterRule(_localctx, 204, RULE_streamExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1559;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,181,Context) ) {
			case 1:
				{
				State = 1555; eventFilterExpression();
				}
				break;
			case 2:
				{
				State = 1556; patternInclusionExpression();
				}
				break;
			case 3:
				{
				State = 1557; databaseJoinExpression();
				}
				break;
			case 4:
				{
				State = 1558; methodJoinExpression();
				}
				break;
			}
			State = 1562;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOT || _la==HASHCHAR) {
				{
				State = 1561; viewExpressions();
				}
			}

			State = 1567;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 1564; Match(AS);
				State = 1565; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 1566; _localctx.i = Match(IDENT);
				}
				break;
			case Eof:
			case WHERE:
			case INNER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case ON:
			case GROUP:
			case HAVING:
			case OUTPUT:
			case ORDER:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case ROW_LIMIT_EXPR:
			case MATCH_RECOGNIZE:
			case FOR:
			case RPAREN:
			case COMMA:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1570;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNIDIRECTIONAL) {
				{
				State = 1569; _localctx.u = Match(UNIDIRECTIONAL);
				}
			}

			State = 1574;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RETAINUNION:
				{
				State = 1572; _localctx.ru = Match(RETAINUNION);
				}
				break;
			case RETAININTERSECTION:
				{
				State = 1573; _localctx.ri = Match(RETAININTERSECTION);
				}
				break;
			case Eof:
			case WHERE:
			case INNER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case ON:
			case GROUP:
			case HAVING:
			case OUTPUT:
			case ORDER:
			case ROW_LIMIT_EXPR:
			case MATCH_RECOGNIZE:
			case FOR:
			case RPAREN:
			case COMMA:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForExprContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode FOR() { return GetToken(EsperEPL2GrammarParser.FOR, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ForExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterForExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitForExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForExprContext forExpr() {
		ForExprContext _localctx = new ForExprContext(Context, State);
		EnterRule(_localctx, 206, RULE_forExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1576; Match(FOR);
			State = 1577; _localctx.i = Match(IDENT);
			State = 1583;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 1578; Match(LPAREN);
				State = 1580;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 1579; expressionList();
					}
				}

				State = 1582; Match(RPAREN);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternInclusionExpressionContext : ParserRuleContext {
		public ITerminalNode PATTERN() { return GetToken(EsperEPL2GrammarParser.PATTERN, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public PatternExpressionContext patternExpression() {
			return GetRuleContext<PatternExpressionContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public PatternInclusionExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternInclusionExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPatternInclusionExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPatternInclusionExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternInclusionExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternInclusionExpressionContext patternInclusionExpression() {
		PatternInclusionExpressionContext _localctx = new PatternInclusionExpressionContext(Context, State);
		EnterRule(_localctx, 208, RULE_patternInclusionExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1585; Match(PATTERN);
			State = 1589;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ATCHAR) {
				{
				{
				State = 1586; annotationEnum();
				}
				}
				State = 1591;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1592; Match(LBRACK);
			State = 1593; patternExpression();
			State = 1594; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatabaseJoinExpressionContext : ParserRuleContext {
		public IToken i;
		public IToken s;
		public IToken s2;
		public ITerminalNode SQL() { return GetToken(EsperEPL2GrammarParser.SQL, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(EsperEPL2GrammarParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(EsperEPL2GrammarParser.STRING_LITERAL, i);
		}
		public ITerminalNode[] QUOTED_STRING_LITERAL() { return GetTokens(EsperEPL2GrammarParser.QUOTED_STRING_LITERAL); }
		public ITerminalNode QUOTED_STRING_LITERAL(int i) {
			return GetToken(EsperEPL2GrammarParser.QUOTED_STRING_LITERAL, i);
		}
		public ITerminalNode METADATASQL() { return GetToken(EsperEPL2GrammarParser.METADATASQL, 0); }
		public DatabaseJoinExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_databaseJoinExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterDatabaseJoinExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitDatabaseJoinExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatabaseJoinExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DatabaseJoinExpressionContext databaseJoinExpression() {
		DatabaseJoinExpressionContext _localctx = new DatabaseJoinExpressionContext(Context, State);
		EnterRule(_localctx, 210, RULE_databaseJoinExpression);
		 paraphrases.Push("relational data join"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1596; Match(SQL);
			State = 1597; Match(COLON);
			State = 1598; _localctx.i = Match(IDENT);
			State = 1599; Match(LBRACK);
			State = 1602;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL:
				{
				State = 1600; _localctx.s = Match(STRING_LITERAL);
				}
				break;
			case QUOTED_STRING_LITERAL:
				{
				State = 1601; _localctx.s = Match(QUOTED_STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1609;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==METADATASQL) {
				{
				State = 1604; Match(METADATASQL);
				State = 1607;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STRING_LITERAL:
					{
					State = 1605; _localctx.s2 = Match(STRING_LITERAL);
					}
					break;
				case QUOTED_STRING_LITERAL:
					{
					State = 1606; _localctx.s2 = Match(QUOTED_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			State = 1611; Match(RBRACK);
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MethodJoinExpressionContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public TypeExpressionAnnotationContext typeExpressionAnnotation() {
			return GetRuleContext<TypeExpressionAnnotationContext>(0);
		}
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public MethodJoinExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_methodJoinExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMethodJoinExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMethodJoinExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethodJoinExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MethodJoinExpressionContext methodJoinExpression() {
		MethodJoinExpressionContext _localctx = new MethodJoinExpressionContext(Context, State);
		EnterRule(_localctx, 212, RULE_methodJoinExpression);
		 paraphrases.Push("method invocation join"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1613; _localctx.i = Match(IDENT);
			State = 1614; Match(COLON);
			State = 1615; classIdentifier();
			State = 1621;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 1616; Match(LPAREN);
				State = 1618;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 1617; expressionList();
					}
				}

				State = 1620; Match(RPAREN);
				}
			}

			State = 1624;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ATCHAR) {
				{
				State = 1623; typeExpressionAnnotation();
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewExpressionsContext : ParserRuleContext {
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public ViewExpressionWNamespaceContext[] viewExpressionWNamespace() {
			return GetRuleContexts<ViewExpressionWNamespaceContext>();
		}
		public ViewExpressionWNamespaceContext viewExpressionWNamespace(int i) {
			return GetRuleContext<ViewExpressionWNamespaceContext>(i);
		}
		public ITerminalNode[] HASHCHAR() { return GetTokens(EsperEPL2GrammarParser.HASHCHAR); }
		public ITerminalNode HASHCHAR(int i) {
			return GetToken(EsperEPL2GrammarParser.HASHCHAR, i);
		}
		public ViewExpressionOptNamespaceContext[] viewExpressionOptNamespace() {
			return GetRuleContexts<ViewExpressionOptNamespaceContext>();
		}
		public ViewExpressionOptNamespaceContext viewExpressionOptNamespace(int i) {
			return GetRuleContext<ViewExpressionOptNamespaceContext>(i);
		}
		public ViewExpressionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewExpressions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterViewExpressions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitViewExpressions(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitViewExpressions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ViewExpressionsContext viewExpressions() {
		ViewExpressionsContext _localctx = new ViewExpressionsContext(Context, State);
		EnterRule(_localctx, 214, RULE_viewExpressions);
		 paraphrases.Push("view specifications"); 
		int _la;
		try {
			State = 1644;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DOT:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 1626; Match(DOT);
				State = 1627; viewExpressionWNamespace();
				State = 1632;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==DOT) {
					{
					{
					State = 1628; Match(DOT);
					State = 1629; viewExpressionWNamespace();
					}
					}
					State = 1634;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				}
				break;
			case HASHCHAR:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 1635; Match(HASHCHAR);
				State = 1636; viewExpressionOptNamespace();
				State = 1641;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==HASHCHAR) {
					{
					{
					State = 1637; Match(HASHCHAR);
					State = 1638; viewExpressionOptNamespace();
					}
					}
					State = 1643;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewExpressionWNamespaceContext : ParserRuleContext {
		public IToken ns;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ViewWParametersContext viewWParameters() {
			return GetRuleContext<ViewWParametersContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ViewExpressionWNamespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewExpressionWNamespace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterViewExpressionWNamespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitViewExpressionWNamespace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitViewExpressionWNamespace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ViewExpressionWNamespaceContext viewExpressionWNamespace() {
		ViewExpressionWNamespaceContext _localctx = new ViewExpressionWNamespaceContext(Context, State);
		EnterRule(_localctx, 216, RULE_viewExpressionWNamespace);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1646; _localctx.ns = Match(IDENT);
			State = 1647; Match(COLON);
			State = 1648; viewWParameters();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewExpressionOptNamespaceContext : ParserRuleContext {
		public IToken ns;
		public ViewWParametersContext viewWParameters() {
			return GetRuleContext<ViewWParametersContext>(0);
		}
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ViewExpressionOptNamespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewExpressionOptNamespace; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterViewExpressionOptNamespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitViewExpressionOptNamespace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitViewExpressionOptNamespace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ViewExpressionOptNamespaceContext viewExpressionOptNamespace() {
		ViewExpressionOptNamespaceContext _localctx = new ViewExpressionOptNamespaceContext(Context, State);
		EnterRule(_localctx, 218, RULE_viewExpressionOptNamespace);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1652;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,198,Context) ) {
			case 1:
				{
				State = 1650; _localctx.ns = Match(IDENT);
				State = 1651; Match(COLON);
				}
				break;
			}
			State = 1654; viewWParameters();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewWParametersContext : ParserRuleContext {
		public IToken i;
		public IToken m;
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode MERGE() { return GetToken(EsperEPL2GrammarParser.MERGE, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionWithTimeListContext expressionWithTimeList() {
			return GetRuleContext<ExpressionWithTimeListContext>(0);
		}
		public ViewWParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewWParameters; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterViewWParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitViewWParameters(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitViewWParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ViewWParametersContext viewWParameters() {
		ViewWParametersContext _localctx = new ViewWParametersContext(Context, State);
		EnterRule(_localctx, 220, RULE_viewWParameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1658;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENT:
				{
				State = 1656; _localctx.i = Match(IDENT);
				}
				break;
			case MERGE:
				{
				State = 1657; _localctx.m = Match(MERGE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1665;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,201,Context) ) {
			case 1:
				{
				State = 1660; Match(LPAREN);
				State = 1662;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LBRACK - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (STAR - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 1661; expressionWithTimeList();
					}
				}

				State = 1664; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByListExprContext : ParserRuleContext {
		public GroupByListChoiceContext[] groupByListChoice() {
			return GetRuleContexts<GroupByListChoiceContext>();
		}
		public GroupByListChoiceContext groupByListChoice(int i) {
			return GetRuleContext<GroupByListChoiceContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GroupByListExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByListExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByListExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByListExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByListExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByListExprContext groupByListExpr() {
		GroupByListExprContext _localctx = new GroupByListExprContext(Context, State);
		EnterRule(_localctx, 222, RULE_groupByListExpr);
		 paraphrases.Push("group-by clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1667; groupByListChoice();
			State = 1672;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1668; Match(COMMA);
				State = 1669; groupByListChoice();
				}
				}
				State = 1674;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByListChoiceContext : ParserRuleContext {
		public ExpressionContext e1;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public GroupByCubeOrRollupContext groupByCubeOrRollup() {
			return GetRuleContext<GroupByCubeOrRollupContext>(0);
		}
		public GroupByGroupingSetsContext groupByGroupingSets() {
			return GetRuleContext<GroupByGroupingSetsContext>(0);
		}
		public GroupByListChoiceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByListChoice; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByListChoice(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByListChoice(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByListChoice(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByListChoiceContext groupByListChoice() {
		GroupByListChoiceContext _localctx = new GroupByListChoiceContext(Context, State);
		EnterRule(_localctx, 224, RULE_groupByListChoice);
		try {
			State = 1678;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,203,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1675; _localctx.e1 = expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1676; groupByCubeOrRollup();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1677; groupByGroupingSets();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByCubeOrRollupContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public GroupByCombinableExprContext[] groupByCombinableExpr() {
			return GetRuleContexts<GroupByCombinableExprContext>();
		}
		public GroupByCombinableExprContext groupByCombinableExpr(int i) {
			return GetRuleContext<GroupByCombinableExprContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode CUBE() { return GetToken(EsperEPL2GrammarParser.CUBE, 0); }
		public ITerminalNode ROLLUP() { return GetToken(EsperEPL2GrammarParser.ROLLUP, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GroupByCubeOrRollupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByCubeOrRollup; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByCubeOrRollup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByCubeOrRollup(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByCubeOrRollup(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByCubeOrRollupContext groupByCubeOrRollup() {
		GroupByCubeOrRollupContext _localctx = new GroupByCubeOrRollupContext(Context, State);
		EnterRule(_localctx, 226, RULE_groupByCubeOrRollup);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1680;
			_la = TokenStream.LA(1);
			if ( !(_la==CUBE || _la==ROLLUP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1681; Match(LPAREN);
			State = 1682; groupByCombinableExpr();
			State = 1687;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1683; Match(COMMA);
				State = 1684; groupByCombinableExpr();
				}
				}
				State = 1689;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1690; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByGroupingSetsContext : ParserRuleContext {
		public ITerminalNode GROUPING() { return GetToken(EsperEPL2GrammarParser.GROUPING, 0); }
		public ITerminalNode SETS() { return GetToken(EsperEPL2GrammarParser.SETS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public GroupBySetsChoiceContext[] groupBySetsChoice() {
			return GetRuleContexts<GroupBySetsChoiceContext>();
		}
		public GroupBySetsChoiceContext groupBySetsChoice(int i) {
			return GetRuleContext<GroupBySetsChoiceContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GroupByGroupingSetsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByGroupingSets; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByGroupingSets(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByGroupingSets(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByGroupingSets(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByGroupingSetsContext groupByGroupingSets() {
		GroupByGroupingSetsContext _localctx = new GroupByGroupingSetsContext(Context, State);
		EnterRule(_localctx, 228, RULE_groupByGroupingSets);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1692; Match(GROUPING);
			State = 1693; Match(SETS);
			State = 1694; Match(LPAREN);
			State = 1695; groupBySetsChoice();
			State = 1700;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1696; Match(COMMA);
				State = 1697; groupBySetsChoice();
				}
				}
				State = 1702;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1703; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupBySetsChoiceContext : ParserRuleContext {
		public GroupByCubeOrRollupContext groupByCubeOrRollup() {
			return GetRuleContext<GroupByCubeOrRollupContext>(0);
		}
		public GroupByCombinableExprContext groupByCombinableExpr() {
			return GetRuleContext<GroupByCombinableExprContext>(0);
		}
		public GroupBySetsChoiceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupBySetsChoice; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupBySetsChoice(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupBySetsChoice(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupBySetsChoice(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupBySetsChoiceContext groupBySetsChoice() {
		GroupBySetsChoiceContext _localctx = new GroupBySetsChoiceContext(Context, State);
		EnterRule(_localctx, 230, RULE_groupBySetsChoice);
		try {
			State = 1707;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CUBE:
			case ROLLUP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1705; groupByCubeOrRollup();
				}
				break;
			case WINDOW:
			case ESCAPE:
			case NOT_EXPR:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case CASE:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case ISTREAM:
			case SCHEMA:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PREVIOUSCOUNT:
			case PREVIOUSWINDOW:
			case PRIOR:
			case EXISTS:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case CURRENT_TIMESTAMP:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case NEWKW:
			case CONTEXT:
			case GROUPING:
			case GROUPING_ID:
			case QUESTION:
			case LPAREN:
			case LCURLY:
			case PLUS:
			case MINUS:
			case TICKED_STRING_LITERAL:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IDENT:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1706; groupByCombinableExpr();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByCombinableExprContext : ParserRuleContext {
		public ExpressionContext e1;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GroupByCombinableExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByCombinableExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByCombinableExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByCombinableExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByCombinableExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByCombinableExprContext groupByCombinableExpr() {
		GroupByCombinableExprContext _localctx = new GroupByCombinableExprContext(Context, State);
		EnterRule(_localctx, 232, RULE_groupByCombinableExpr);
		int _la;
		try {
			State = 1722;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,209,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1709; _localctx.e1 = expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1710; Match(LPAREN);
				State = 1719;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 1711; expression();
					State = 1716;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1712; Match(COMMA);
						State = 1713; expression();
						}
						}
						State = 1718;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 1721; Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByListExprContext : ParserRuleContext {
		public OrderByListElementContext[] orderByListElement() {
			return GetRuleContexts<OrderByListElementContext>();
		}
		public OrderByListElementContext orderByListElement(int i) {
			return GetRuleContext<OrderByListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public OrderByListExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByListExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOrderByListExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOrderByListExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderByListExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrderByListExprContext orderByListExpr() {
		OrderByListExprContext _localctx = new OrderByListExprContext(Context, State);
		EnterRule(_localctx, 234, RULE_orderByListExpr);
		 paraphrases.Push("order by clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1724; orderByListElement();
			State = 1729;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1725; Match(COMMA);
				State = 1726; orderByListElement();
				}
				}
				State = 1731;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByListElementContext : ParserRuleContext {
		public IToken a;
		public IToken d;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(EsperEPL2GrammarParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(EsperEPL2GrammarParser.DESC, 0); }
		public OrderByListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOrderByListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOrderByListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderByListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrderByListElementContext orderByListElement() {
		OrderByListElementContext _localctx = new OrderByListElementContext(Context, State);
		EnterRule(_localctx, 236, RULE_orderByListElement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1732; expression();
			State = 1735;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ASC:
				{
				State = 1733; _localctx.a = Match(ASC);
				}
				break;
			case DESC:
				{
				State = 1734; _localctx.d = Match(DESC);
				}
				break;
			case Eof:
			case INSERT:
			case ROW_LIMIT_EXPR:
			case FOR:
			case RPAREN:
			case COMMA:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HavingClauseContext : ParserRuleContext {
		public EvalOrExpressionContext evalOrExpression() {
			return GetRuleContext<EvalOrExpressionContext>(0);
		}
		public HavingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_havingClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterHavingClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitHavingClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHavingClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HavingClauseContext havingClause() {
		HavingClauseContext _localctx = new HavingClauseContext(Context, State);
		EnterRule(_localctx, 238, RULE_havingClause);
		 paraphrases.Push("having clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1737; evalOrExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OutputLimitContext : ParserRuleContext {
		public IToken k;
		public IToken ev;
		public IToken i;
		public IToken e;
		public IToken at;
		public IToken wh;
		public IToken t;
		public OutputLimitAfterContext outputLimitAfter() {
			return GetRuleContext<OutputLimitAfterContext>(0);
		}
		public OutputLimitAndTermContext outputLimitAndTerm() {
			return GetRuleContext<OutputLimitAndTermContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(EsperEPL2GrammarParser.SNAPSHOT, 0); }
		public CrontabLimitParameterSetContext crontabLimitParameterSet() {
			return GetRuleContext<CrontabLimitParameterSetContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TERMINATED() { return GetToken(EsperEPL2GrammarParser.TERMINATED, 0); }
		public ITerminalNode EVERY_EXPR() { return GetToken(EsperEPL2GrammarParser.EVERY_EXPR, 0); }
		public ITerminalNode AT() { return GetToken(EsperEPL2GrammarParser.AT, 0); }
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public OnSetExprContext onSetExpr() {
			return GetRuleContext<OnSetExprContext>(0);
		}
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode EVENTS() { return GetToken(EsperEPL2GrammarParser.EVENTS, 0); }
		public OutputLimitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outputLimit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOutputLimit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOutputLimit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOutputLimit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OutputLimitContext outputLimit() {
		OutputLimitContext _localctx = new OutputLimitContext(Context, State);
		EnterRule(_localctx, 240, RULE_outputLimit);
		 paraphrases.Push("output rate clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1740;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AFTER) {
				{
				State = 1739; outputLimitAfter();
				}
			}

			State = 1746;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				{
				State = 1742; _localctx.k = Match(ALL);
				}
				break;
			case FIRST:
				{
				State = 1743; _localctx.k = Match(FIRST);
				}
				break;
			case LAST:
				{
				State = 1744; _localctx.k = Match(LAST);
				}
				break;
			case SNAPSHOT:
				{
				State = 1745; _localctx.k = Match(SNAPSHOT);
				}
				break;
			case Eof:
			case AND_EXPR:
			case EVERY_EXPR:
			case WHEN:
			case ORDER:
			case AT:
			case ROW_LIMIT_EXPR:
			case FOR:
			case RPAREN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1776;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,219,Context) ) {
			case 1:
				{
				{
				State = 1748; _localctx.ev = Match(EVERY_EXPR);
				State = 1755;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,215,Context) ) {
				case 1:
					{
					State = 1749; timePeriod();
					}
					break;
				case 2:
					{
					State = 1752;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case IntegerLiteral:
					case FloatingPointLiteral:
						{
						State = 1750; number();
						}
						break;
					case IDENT:
						{
						State = 1751; _localctx.i = Match(IDENT);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					{
					State = 1754; _localctx.e = Match(EVENTS);
					}
					}
					break;
				}
				}
				}
				break;
			case 2:
				{
				{
				State = 1757; _localctx.at = Match(AT);
				State = 1758; crontabLimitParameterSet();
				}
				}
				break;
			case 3:
				{
				{
				State = 1759; _localctx.wh = Match(WHEN);
				State = 1760; expression();
				State = 1763;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==THEN) {
					{
					State = 1761; Match(THEN);
					State = 1762; onSetExpr();
					}
				}

				}
				}
				break;
			case 4:
				{
				{
				State = 1765; _localctx.t = Match(WHEN);
				State = 1766; Match(TERMINATED);
				State = 1769;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,217,Context) ) {
				case 1:
					{
					State = 1767; Match(AND_EXPR);
					State = 1768; expression();
					}
					break;
				}
				State = 1773;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==THEN) {
					{
					State = 1771; Match(THEN);
					State = 1772; onSetExpr();
					}
				}

				}
				}
				break;
			case 5:
				{
				}
				break;
			}
			State = 1779;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND_EXPR) {
				{
				State = 1778; outputLimitAndTerm();
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OutputLimitAndTermContext : ParserRuleContext {
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public ITerminalNode TERMINATED() { return GetToken(EsperEPL2GrammarParser.TERMINATED, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public OnSetExprContext onSetExpr() {
			return GetRuleContext<OnSetExprContext>(0);
		}
		public OutputLimitAndTermContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outputLimitAndTerm; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOutputLimitAndTerm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOutputLimitAndTerm(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOutputLimitAndTerm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OutputLimitAndTermContext outputLimitAndTerm() {
		OutputLimitAndTermContext _localctx = new OutputLimitAndTermContext(Context, State);
		EnterRule(_localctx, 242, RULE_outputLimitAndTerm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1781; Match(AND_EXPR);
			State = 1782; Match(WHEN);
			State = 1783; Match(TERMINATED);
			State = 1786;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AND_EXPR) {
				{
				State = 1784; Match(AND_EXPR);
				State = 1785; expression();
				}
			}

			State = 1790;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==THEN) {
				{
				State = 1788; Match(THEN);
				State = 1789; onSetExpr();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OutputLimitAfterContext : ParserRuleContext {
		public IToken a;
		public ITerminalNode AFTER() { return GetToken(EsperEPL2GrammarParser.AFTER, 0); }
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode EVENTS() { return GetToken(EsperEPL2GrammarParser.EVENTS, 0); }
		public OutputLimitAfterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outputLimitAfter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOutputLimitAfter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOutputLimitAfter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOutputLimitAfter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OutputLimitAfterContext outputLimitAfter() {
		OutputLimitAfterContext _localctx = new OutputLimitAfterContext(Context, State);
		EnterRule(_localctx, 244, RULE_outputLimitAfter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1792; _localctx.a = Match(AFTER);
			State = 1797;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,223,Context) ) {
			case 1:
				{
				State = 1793; timePeriod();
				}
				break;
			case 2:
				{
				State = 1794; number();
				State = 1795; Match(EVENTS);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RowLimitContext : ParserRuleContext {
		public NumberconstantContext n1;
		public IToken i1;
		public IToken c;
		public IToken o;
		public NumberconstantContext n2;
		public IToken i2;
		public NumberconstantContext[] numberconstant() {
			return GetRuleContexts<NumberconstantContext>();
		}
		public NumberconstantContext numberconstant(int i) {
			return GetRuleContext<NumberconstantContext>(i);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public ITerminalNode OFFSET() { return GetToken(EsperEPL2GrammarParser.OFFSET, 0); }
		public RowLimitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rowLimit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterRowLimit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitRowLimit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRowLimit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RowLimitContext rowLimit() {
		RowLimitContext _localctx = new RowLimitContext(Context, State);
		EnterRule(_localctx, 246, RULE_rowLimit);
		 paraphrases.Push("row limit clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1801;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 1799; _localctx.n1 = numberconstant();
				}
				break;
			case IDENT:
				{
				State = 1800; _localctx.i1 = Match(IDENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1811;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OFFSET || _la==COMMA) {
				{
				State = 1805;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case COMMA:
					{
					State = 1803; _localctx.c = Match(COMMA);
					}
					break;
				case OFFSET:
					{
					State = 1804; _localctx.o = Match(OFFSET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1809;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case PLUS:
				case MINUS:
				case IntegerLiteral:
				case FloatingPointLiteral:
					{
					State = 1807; _localctx.n2 = numberconstant();
					}
					break;
				case IDENT:
					{
					State = 1808; _localctx.i2 = Match(IDENT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CrontabLimitParameterSetContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionWithTimeListContext expressionWithTimeList() {
			return GetRuleContext<ExpressionWithTimeListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public CrontabLimitParameterSetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_crontabLimitParameterSet; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCrontabLimitParameterSet(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCrontabLimitParameterSet(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCrontabLimitParameterSet(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CrontabLimitParameterSetContext crontabLimitParameterSet() {
		CrontabLimitParameterSetContext _localctx = new CrontabLimitParameterSetContext(Context, State);
		EnterRule(_localctx, 248, RULE_crontabLimitParameterSet);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1813; Match(LPAREN);
			State = 1814; expressionWithTimeList();
			State = 1815; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhenClauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public WhenClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whenClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterWhenClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitWhenClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhenClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhenClauseContext whenClause() {
		WhenClauseContext _localctx = new WhenClauseContext(Context, State);
		EnterRule(_localctx, 250, RULE_whenClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 1817; Match(WHEN);
			State = 1818; expression();
			State = 1819; Match(THEN);
			State = 1820; expression();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseClauseContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(EsperEPL2GrammarParser.ELSE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ElseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElseClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElseClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseClauseContext elseClause() {
		ElseClauseContext _localctx = new ElseClauseContext(Context, State);
		EnterRule(_localctx, 252, RULE_elseClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 1822; Match(ELSE);
			State = 1823; expression();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogContext : ParserRuleContext {
		public ITerminalNode MATCH_RECOGNIZE() { return GetToken(EsperEPL2GrammarParser.MATCH_RECOGNIZE, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public MatchRecogMeasuresContext matchRecogMeasures() {
			return GetRuleContext<MatchRecogMeasuresContext>(0);
		}
		public MatchRecogPatternContext matchRecogPattern() {
			return GetRuleContext<MatchRecogPatternContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public MatchRecogPartitionByContext matchRecogPartitionBy() {
			return GetRuleContext<MatchRecogPartitionByContext>(0);
		}
		public MatchRecogMatchesSelectionContext matchRecogMatchesSelection() {
			return GetRuleContext<MatchRecogMatchesSelectionContext>(0);
		}
		public MatchRecogMatchesAfterSkipContext matchRecogMatchesAfterSkip() {
			return GetRuleContext<MatchRecogMatchesAfterSkipContext>(0);
		}
		public MatchRecogMatchesIntervalContext matchRecogMatchesInterval() {
			return GetRuleContext<MatchRecogMatchesIntervalContext>(0);
		}
		public MatchRecogDefineContext matchRecogDefine() {
			return GetRuleContext<MatchRecogDefineContext>(0);
		}
		public MatchRecogContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecog; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecog(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecog(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecog(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogContext matchRecog() {
		MatchRecogContext _localctx = new MatchRecogContext(Context, State);
		EnterRule(_localctx, 254, RULE_matchRecog);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1825; Match(MATCH_RECOGNIZE);
			State = 1826; Match(LPAREN);
			State = 1828;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 1827; matchRecogPartitionBy();
				}
			}

			State = 1830; matchRecogMeasures();
			State = 1832;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL) {
				{
				State = 1831; matchRecogMatchesSelection();
				}
			}

			State = 1835;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AFTER) {
				{
				State = 1834; matchRecogMatchesAfterSkip();
				}
			}

			State = 1837; matchRecogPattern();
			State = 1839;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENT) {
				{
				State = 1838; matchRecogMatchesInterval();
				}
			}

			State = 1842;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFINE) {
				{
				State = 1841; matchRecogDefine();
				}
			}

			State = 1844; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPartitionByContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(EsperEPL2GrammarParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(EsperEPL2GrammarParser.BY, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public MatchRecogPartitionByContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPartitionBy; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPartitionBy(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPartitionBy(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPartitionBy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPartitionByContext matchRecogPartitionBy() {
		MatchRecogPartitionByContext _localctx = new MatchRecogPartitionByContext(Context, State);
		EnterRule(_localctx, 256, RULE_matchRecogPartitionBy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1846; Match(PARTITION);
			State = 1847; Match(BY);
			State = 1848; expression();
			State = 1853;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1849; Match(COMMA);
				State = 1850; expression();
				}
				}
				State = 1855;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMeasuresContext : ParserRuleContext {
		public ITerminalNode MEASURES() { return GetToken(EsperEPL2GrammarParser.MEASURES, 0); }
		public MatchRecogMeasureItemContext[] matchRecogMeasureItem() {
			return GetRuleContexts<MatchRecogMeasureItemContext>();
		}
		public MatchRecogMeasureItemContext matchRecogMeasureItem(int i) {
			return GetRuleContext<MatchRecogMeasureItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public MatchRecogMeasuresContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMeasures; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMeasures(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMeasures(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMeasures(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMeasuresContext matchRecogMeasures() {
		MatchRecogMeasuresContext _localctx = new MatchRecogMeasuresContext(Context, State);
		EnterRule(_localctx, 258, RULE_matchRecogMeasures);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1856; Match(MEASURES);
			State = 1857; matchRecogMeasureItem();
			State = 1862;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1858; Match(COMMA);
				State = 1859; matchRecogMeasureItem();
				}
				}
				State = 1864;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMeasureItemContext : ParserRuleContext {
		public IToken i;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MatchRecogMeasureItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMeasureItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMeasureItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMeasureItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMeasureItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMeasureItemContext matchRecogMeasureItem() {
		MatchRecogMeasureItemContext _localctx = new MatchRecogMeasureItemContext(Context, State);
		EnterRule(_localctx, 260, RULE_matchRecogMeasureItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1865; expression();
			State = 1870;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1866; Match(AS);
				State = 1868;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IDENT) {
					{
					State = 1867; _localctx.i = Match(IDENT);
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMatchesSelectionContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode MATCHES() { return GetToken(EsperEPL2GrammarParser.MATCHES, 0); }
		public MatchRecogMatchesSelectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMatchesSelection; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMatchesSelection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMatchesSelection(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMatchesSelection(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMatchesSelectionContext matchRecogMatchesSelection() {
		MatchRecogMatchesSelectionContext _localctx = new MatchRecogMatchesSelectionContext(Context, State);
		EnterRule(_localctx, 262, RULE_matchRecogMatchesSelection);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1872; Match(ALL);
			State = 1873; Match(MATCHES);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternContext : ParserRuleContext {
		public ITerminalNode PATTERN() { return GetToken(EsperEPL2GrammarParser.PATTERN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public MatchRecogPatternAlterationContext matchRecogPatternAlteration() {
			return GetRuleContext<MatchRecogPatternAlterationContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public MatchRecogPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPattern(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternContext matchRecogPattern() {
		MatchRecogPatternContext _localctx = new MatchRecogPatternContext(Context, State);
		EnterRule(_localctx, 264, RULE_matchRecogPattern);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1875; Match(PATTERN);
			State = 1876; Match(LPAREN);
			State = 1877; matchRecogPatternAlteration();
			State = 1878; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMatchesAfterSkipContext : ParserRuleContext {
		public KeywordAllowedIdentContext i1;
		public KeywordAllowedIdentContext i2;
		public KeywordAllowedIdentContext i3;
		public KeywordAllowedIdentContext i4;
		public KeywordAllowedIdentContext i5;
		public ITerminalNode AFTER() { return GetToken(EsperEPL2GrammarParser.AFTER, 0); }
		public KeywordAllowedIdentContext[] keywordAllowedIdent() {
			return GetRuleContexts<KeywordAllowedIdentContext>();
		}
		public KeywordAllowedIdentContext keywordAllowedIdent(int i) {
			return GetRuleContext<KeywordAllowedIdentContext>(i);
		}
		public MatchRecogMatchesAfterSkipContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMatchesAfterSkip; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMatchesAfterSkip(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMatchesAfterSkip(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMatchesAfterSkip(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMatchesAfterSkipContext matchRecogMatchesAfterSkip() {
		MatchRecogMatchesAfterSkipContext _localctx = new MatchRecogMatchesAfterSkipContext(Context, State);
		EnterRule(_localctx, 266, RULE_matchRecogMatchesAfterSkip);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1880; Match(AFTER);
			State = 1881; _localctx.i1 = keywordAllowedIdent();
			State = 1882; _localctx.i2 = keywordAllowedIdent();
			State = 1883; _localctx.i3 = keywordAllowedIdent();
			State = 1884; _localctx.i4 = keywordAllowedIdent();
			State = 1885; _localctx.i5 = keywordAllowedIdent();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMatchesIntervalContext : ParserRuleContext {
		public IToken i;
		public IToken t;
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode OR_EXPR() { return GetToken(EsperEPL2GrammarParser.OR_EXPR, 0); }
		public ITerminalNode TERMINATED() { return GetToken(EsperEPL2GrammarParser.TERMINATED, 0); }
		public MatchRecogMatchesIntervalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMatchesInterval; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMatchesInterval(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMatchesInterval(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMatchesInterval(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMatchesIntervalContext matchRecogMatchesInterval() {
		MatchRecogMatchesIntervalContext _localctx = new MatchRecogMatchesIntervalContext(Context, State);
		EnterRule(_localctx, 268, RULE_matchRecogMatchesInterval);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1887; _localctx.i = Match(IDENT);
			State = 1888; timePeriod();
			State = 1891;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR_EXPR) {
				{
				State = 1889; Match(OR_EXPR);
				State = 1890; _localctx.t = Match(TERMINATED);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternAlterationContext : ParserRuleContext {
		public IToken o;
		public MatchRecogPatternConcatContext[] matchRecogPatternConcat() {
			return GetRuleContexts<MatchRecogPatternConcatContext>();
		}
		public MatchRecogPatternConcatContext matchRecogPatternConcat(int i) {
			return GetRuleContext<MatchRecogPatternConcatContext>(i);
		}
		public ITerminalNode[] BOR() { return GetTokens(EsperEPL2GrammarParser.BOR); }
		public ITerminalNode BOR(int i) {
			return GetToken(EsperEPL2GrammarParser.BOR, i);
		}
		public MatchRecogPatternAlterationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternAlteration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternAlteration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternAlteration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternAlteration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternAlterationContext matchRecogPatternAlteration() {
		MatchRecogPatternAlterationContext _localctx = new MatchRecogPatternAlterationContext(Context, State);
		EnterRule(_localctx, 270, RULE_matchRecogPatternAlteration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1893; matchRecogPatternConcat();
			State = 1898;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==BOR) {
				{
				{
				State = 1894; _localctx.o = Match(BOR);
				State = 1895; matchRecogPatternConcat();
				}
				}
				State = 1900;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternConcatContext : ParserRuleContext {
		public MatchRecogPatternUnaryContext[] matchRecogPatternUnary() {
			return GetRuleContexts<MatchRecogPatternUnaryContext>();
		}
		public MatchRecogPatternUnaryContext matchRecogPatternUnary(int i) {
			return GetRuleContext<MatchRecogPatternUnaryContext>(i);
		}
		public MatchRecogPatternConcatContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternConcat; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternConcat(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternConcat(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternConcat(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternConcatContext matchRecogPatternConcat() {
		MatchRecogPatternConcatContext _localctx = new MatchRecogPatternConcatContext(Context, State);
		EnterRule(_localctx, 272, RULE_matchRecogPatternConcat);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1902;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1901; matchRecogPatternUnary();
				}
				}
				State = 1904;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==MATCH_RECOGNIZE_PERMUTE || _la==LPAREN || _la==IDENT );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternUnaryContext : ParserRuleContext {
		public MatchRecogPatternPermuteContext matchRecogPatternPermute() {
			return GetRuleContext<MatchRecogPatternPermuteContext>(0);
		}
		public MatchRecogPatternNestedContext matchRecogPatternNested() {
			return GetRuleContext<MatchRecogPatternNestedContext>(0);
		}
		public MatchRecogPatternAtomContext matchRecogPatternAtom() {
			return GetRuleContext<MatchRecogPatternAtomContext>(0);
		}
		public MatchRecogPatternUnaryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternUnary; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternUnary(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternUnary(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternUnary(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternUnaryContext matchRecogPatternUnary() {
		MatchRecogPatternUnaryContext _localctx = new MatchRecogPatternUnaryContext(Context, State);
		EnterRule(_localctx, 274, RULE_matchRecogPatternUnary);
		try {
			State = 1909;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MATCH_RECOGNIZE_PERMUTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1906; matchRecogPatternPermute();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1907; matchRecogPatternNested();
				}
				break;
			case IDENT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1908; matchRecogPatternAtom();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternNestedContext : ParserRuleContext {
		public IToken s;
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public MatchRecogPatternAlterationContext matchRecogPatternAlteration() {
			return GetRuleContext<MatchRecogPatternAlterationContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public MatchRecogPatternRepeatContext matchRecogPatternRepeat() {
			return GetRuleContext<MatchRecogPatternRepeatContext>(0);
		}
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode PLUS() { return GetToken(EsperEPL2GrammarParser.PLUS, 0); }
		public ITerminalNode QUESTION() { return GetToken(EsperEPL2GrammarParser.QUESTION, 0); }
		public MatchRecogPatternNestedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternNested; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternNested(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternNested(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternNested(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternNestedContext matchRecogPatternNested() {
		MatchRecogPatternNestedContext _localctx = new MatchRecogPatternNestedContext(Context, State);
		EnterRule(_localctx, 276, RULE_matchRecogPatternNested);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1911; Match(LPAREN);
			State = 1912; matchRecogPatternAlteration();
			State = 1913; Match(RPAREN);
			State = 1917;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STAR:
				{
				State = 1914; _localctx.s = Match(STAR);
				}
				break;
			case PLUS:
				{
				State = 1915; _localctx.s = Match(PLUS);
				}
				break;
			case QUESTION:
				{
				State = 1916; _localctx.s = Match(QUESTION);
				}
				break;
			case MATCH_RECOGNIZE_PERMUTE:
			case LPAREN:
			case RPAREN:
			case LCURLY:
			case COMMA:
			case BOR:
			case IDENT:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1920;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LCURLY) {
				{
				State = 1919; matchRecogPatternRepeat();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternPermuteContext : ParserRuleContext {
		public ITerminalNode MATCH_RECOGNIZE_PERMUTE() { return GetToken(EsperEPL2GrammarParser.MATCH_RECOGNIZE_PERMUTE, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public MatchRecogPatternAlterationContext[] matchRecogPatternAlteration() {
			return GetRuleContexts<MatchRecogPatternAlterationContext>();
		}
		public MatchRecogPatternAlterationContext matchRecogPatternAlteration(int i) {
			return GetRuleContext<MatchRecogPatternAlterationContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public MatchRecogPatternPermuteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternPermute; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternPermute(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternPermute(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternPermute(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternPermuteContext matchRecogPatternPermute() {
		MatchRecogPatternPermuteContext _localctx = new MatchRecogPatternPermuteContext(Context, State);
		EnterRule(_localctx, 278, RULE_matchRecogPatternPermute);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1922; Match(MATCH_RECOGNIZE_PERMUTE);
			State = 1923; Match(LPAREN);
			State = 1924; matchRecogPatternAlteration();
			State = 1929;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1925; Match(COMMA);
				State = 1926; matchRecogPatternAlteration();
				}
				}
				State = 1931;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1932; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternAtomContext : ParserRuleContext {
		public IToken i;
		public IToken s;
		public IToken reluctant;
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MatchRecogPatternRepeatContext matchRecogPatternRepeat() {
			return GetRuleContext<MatchRecogPatternRepeatContext>(0);
		}
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode PLUS() { return GetToken(EsperEPL2GrammarParser.PLUS, 0); }
		public ITerminalNode[] QUESTION() { return GetTokens(EsperEPL2GrammarParser.QUESTION); }
		public ITerminalNode QUESTION(int i) {
			return GetToken(EsperEPL2GrammarParser.QUESTION, i);
		}
		public MatchRecogPatternAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternAtom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternAtomContext matchRecogPatternAtom() {
		MatchRecogPatternAtomContext _localctx = new MatchRecogPatternAtomContext(Context, State);
		EnterRule(_localctx, 280, RULE_matchRecogPatternAtom);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1934; _localctx.i = Match(IDENT);
			State = 1943;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (QUESTION - 143)) | (1L << (PLUS - 143)) | (1L << (STAR - 143)))) != 0)) {
				{
				State = 1938;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STAR:
					{
					State = 1935; _localctx.s = Match(STAR);
					}
					break;
				case PLUS:
					{
					State = 1936; _localctx.s = Match(PLUS);
					}
					break;
				case QUESTION:
					{
					State = 1937; _localctx.s = Match(QUESTION);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1941;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==QUESTION) {
					{
					State = 1940; _localctx.reluctant = Match(QUESTION);
					}
				}

				}
			}

			State = 1946;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LCURLY) {
				{
				State = 1945; matchRecogPatternRepeat();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternRepeatContext : ParserRuleContext {
		public ExpressionContext e1;
		public IToken comma;
		public ExpressionContext e2;
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public MatchRecogPatternRepeatContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternRepeat; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternRepeat(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternRepeat(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternRepeat(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternRepeatContext matchRecogPatternRepeat() {
		MatchRecogPatternRepeatContext _localctx = new MatchRecogPatternRepeatContext(Context, State);
		EnterRule(_localctx, 282, RULE_matchRecogPatternRepeat);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1948; Match(LCURLY);
			State = 1950;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,248,Context) ) {
			case 1:
				{
				State = 1949; _localctx.e1 = expression();
				}
				break;
			}
			State = 1953;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1952; _localctx.comma = Match(COMMA);
				}
			}

			State = 1956;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
				{
				State = 1955; _localctx.e2 = expression();
				}
			}

			State = 1958; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogDefineContext : ParserRuleContext {
		public ITerminalNode DEFINE() { return GetToken(EsperEPL2GrammarParser.DEFINE, 0); }
		public MatchRecogDefineItemContext[] matchRecogDefineItem() {
			return GetRuleContexts<MatchRecogDefineItemContext>();
		}
		public MatchRecogDefineItemContext matchRecogDefineItem(int i) {
			return GetRuleContext<MatchRecogDefineItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public MatchRecogDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogDefine; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogDefine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogDefine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogDefineContext matchRecogDefine() {
		MatchRecogDefineContext _localctx = new MatchRecogDefineContext(Context, State);
		EnterRule(_localctx, 284, RULE_matchRecogDefine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1960; Match(DEFINE);
			State = 1961; matchRecogDefineItem();
			State = 1966;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1962; Match(COMMA);
				State = 1963; matchRecogDefineItem();
				}
				}
				State = 1968;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogDefineItemContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MatchRecogDefineItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogDefineItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogDefineItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogDefineItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogDefineItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogDefineItemContext matchRecogDefineItem() {
		MatchRecogDefineItemContext _localctx = new MatchRecogDefineItemContext(Context, State);
		EnterRule(_localctx, 286, RULE_matchRecogDefineItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1969; _localctx.i = Match(IDENT);
			State = 1970; Match(AS);
			State = 1971; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public CaseExpressionContext caseExpression() {
			return GetRuleContext<CaseExpressionContext>(0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 288, RULE_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1973; caseExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseExpressionContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(EsperEPL2GrammarParser.CASE, 0); }
		public ITerminalNode END() { return GetToken(EsperEPL2GrammarParser.END, 0); }
		public WhenClauseContext[] whenClause() {
			return GetRuleContexts<WhenClauseContext>();
		}
		public WhenClauseContext whenClause(int i) {
			return GetRuleContext<WhenClauseContext>(i);
		}
		public ElseClauseContext elseClause() {
			return GetRuleContext<ElseClauseContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public EvalOrExpressionContext evalOrExpression() {
			return GetRuleContext<EvalOrExpressionContext>(0);
		}
		public CaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCaseExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCaseExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseExpressionContext caseExpression() {
		CaseExpressionContext _localctx = new CaseExpressionContext(Context, State);
		EnterRule(_localctx, 290, RULE_caseExpression);
		int _la;
		try {
			State = 2003;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,256,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				 paraphrases.Push("case expression"); 
				State = 1976; Match(CASE);
				State = 1978;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 1977; whenClause();
					}
					}
					State = 1980;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==WHEN );
				State = 1983;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELSE) {
					{
					State = 1982; elseClause();
					}
				}

				State = 1985; Match(END);
				 paraphrases.Pop(); 
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				 paraphrases.Push("case expression"); 
				State = 1989; Match(CASE);
				State = 1990; expression();
				State = 1992;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 1991; whenClause();
					}
					}
					State = 1994;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==WHEN );
				State = 1997;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELSE) {
					{
					State = 1996; elseClause();
					}
				}

				State = 1999; Match(END);
				 paraphrases.Pop(); 
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2002; evalOrExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvalOrExpressionContext : ParserRuleContext {
		public IToken op;
		public EvalAndExpressionContext[] evalAndExpression() {
			return GetRuleContexts<EvalAndExpressionContext>();
		}
		public EvalAndExpressionContext evalAndExpression(int i) {
			return GetRuleContext<EvalAndExpressionContext>(i);
		}
		public ITerminalNode[] OR_EXPR() { return GetTokens(EsperEPL2GrammarParser.OR_EXPR); }
		public ITerminalNode OR_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.OR_EXPR, i);
		}
		public EvalOrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evalOrExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEvalOrExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEvalOrExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvalOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EvalOrExpressionContext evalOrExpression() {
		EvalOrExpressionContext _localctx = new EvalOrExpressionContext(Context, State);
		EnterRule(_localctx, 292, RULE_evalOrExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2005; evalAndExpression();
			State = 2010;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR_EXPR) {
				{
				{
				State = 2006; _localctx.op = Match(OR_EXPR);
				State = 2007; evalAndExpression();
				}
				}
				State = 2012;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvalAndExpressionContext : ParserRuleContext {
		public IToken op;
		public BitWiseExpressionContext[] bitWiseExpression() {
			return GetRuleContexts<BitWiseExpressionContext>();
		}
		public BitWiseExpressionContext bitWiseExpression(int i) {
			return GetRuleContext<BitWiseExpressionContext>(i);
		}
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public EvalAndExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evalAndExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEvalAndExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEvalAndExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvalAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EvalAndExpressionContext evalAndExpression() {
		EvalAndExpressionContext _localctx = new EvalAndExpressionContext(Context, State);
		EnterRule(_localctx, 294, RULE_evalAndExpression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2013; bitWiseExpression();
			State = 2018;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,258,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2014; _localctx.op = Match(AND_EXPR);
					State = 2015; bitWiseExpression();
					}
					} 
				}
				State = 2020;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,258,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitWiseExpressionContext : ParserRuleContext {
		public NegatedExpressionContext[] negatedExpression() {
			return GetRuleContexts<NegatedExpressionContext>();
		}
		public NegatedExpressionContext negatedExpression(int i) {
			return GetRuleContext<NegatedExpressionContext>(i);
		}
		public ITerminalNode[] BAND() { return GetTokens(EsperEPL2GrammarParser.BAND); }
		public ITerminalNode BAND(int i) {
			return GetToken(EsperEPL2GrammarParser.BAND, i);
		}
		public ITerminalNode[] BOR() { return GetTokens(EsperEPL2GrammarParser.BOR); }
		public ITerminalNode BOR(int i) {
			return GetToken(EsperEPL2GrammarParser.BOR, i);
		}
		public ITerminalNode[] BXOR() { return GetTokens(EsperEPL2GrammarParser.BXOR); }
		public ITerminalNode BXOR(int i) {
			return GetToken(EsperEPL2GrammarParser.BXOR, i);
		}
		public BitWiseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitWiseExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBitWiseExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBitWiseExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitWiseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BitWiseExpressionContext bitWiseExpression() {
		BitWiseExpressionContext _localctx = new BitWiseExpressionContext(Context, State);
		EnterRule(_localctx, 296, RULE_bitWiseExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2021; negatedExpression();
			State = 2026;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 172)) & ~0x3f) == 0 && ((1L << (_la - 172)) & ((1L << (BXOR - 172)) | (1L << (BOR - 172)) | (1L << (BAND - 172)))) != 0)) {
				{
				{
				State = 2022;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 172)) & ~0x3f) == 0 && ((1L << (_la - 172)) & ((1L << (BXOR - 172)) | (1L << (BOR - 172)) | (1L << (BAND - 172)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2023; negatedExpression();
				}
				}
				State = 2028;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NegatedExpressionContext : ParserRuleContext {
		public EvalEqualsExpressionContext evalEqualsExpression() {
			return GetRuleContext<EvalEqualsExpressionContext>(0);
		}
		public ITerminalNode NOT_EXPR() { return GetToken(EsperEPL2GrammarParser.NOT_EXPR, 0); }
		public NegatedExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_negatedExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNegatedExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNegatedExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNegatedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NegatedExpressionContext negatedExpression() {
		NegatedExpressionContext _localctx = new NegatedExpressionContext(Context, State);
		EnterRule(_localctx, 298, RULE_negatedExpression);
		try {
			State = 2032;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WINDOW:
			case ESCAPE:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case ISTREAM:
			case SCHEMA:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PREVIOUSCOUNT:
			case PREVIOUSWINDOW:
			case PRIOR:
			case EXISTS:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case CURRENT_TIMESTAMP:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case NEWKW:
			case CONTEXT:
			case GROUPING:
			case GROUPING_ID:
			case QUESTION:
			case LPAREN:
			case LCURLY:
			case PLUS:
			case MINUS:
			case TICKED_STRING_LITERAL:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IDENT:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2029; evalEqualsExpression();
				}
				break;
			case NOT_EXPR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2030; Match(NOT_EXPR);
				State = 2031; evalEqualsExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvalEqualsExpressionContext : ParserRuleContext {
		public IToken eq;
		public IToken @is;
		public IToken isnot;
		public IToken sqlne;
		public IToken ne;
		public IToken a;
		public EvalRelationalExpressionContext[] evalRelationalExpression() {
			return GetRuleContexts<EvalRelationalExpressionContext>();
		}
		public EvalRelationalExpressionContext evalRelationalExpression(int i) {
			return GetRuleContext<EvalRelationalExpressionContext>(i);
		}
		public ITerminalNode[] NOT_EXPR() { return GetTokens(EsperEPL2GrammarParser.NOT_EXPR); }
		public ITerminalNode NOT_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.NOT_EXPR, i);
		}
		public ITerminalNode[] EQUALS() { return GetTokens(EsperEPL2GrammarParser.EQUALS); }
		public ITerminalNode EQUALS(int i) {
			return GetToken(EsperEPL2GrammarParser.EQUALS, i);
		}
		public ITerminalNode[] IS() { return GetTokens(EsperEPL2GrammarParser.IS); }
		public ITerminalNode IS(int i) {
			return GetToken(EsperEPL2GrammarParser.IS, i);
		}
		public ITerminalNode[] SQL_NE() { return GetTokens(EsperEPL2GrammarParser.SQL_NE); }
		public ITerminalNode SQL_NE(int i) {
			return GetToken(EsperEPL2GrammarParser.SQL_NE, i);
		}
		public ITerminalNode[] NOT_EQUAL() { return GetTokens(EsperEPL2GrammarParser.NOT_EQUAL); }
		public ITerminalNode NOT_EQUAL(int i) {
			return GetToken(EsperEPL2GrammarParser.NOT_EQUAL, i);
		}
		public SubSelectGroupExpressionContext[] subSelectGroupExpression() {
			return GetRuleContexts<SubSelectGroupExpressionContext>();
		}
		public SubSelectGroupExpressionContext subSelectGroupExpression(int i) {
			return GetRuleContext<SubSelectGroupExpressionContext>(i);
		}
		public ITerminalNode[] ANY() { return GetTokens(EsperEPL2GrammarParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(EsperEPL2GrammarParser.ANY, i);
		}
		public ITerminalNode[] SOME() { return GetTokens(EsperEPL2GrammarParser.SOME); }
		public ITerminalNode SOME(int i) {
			return GetToken(EsperEPL2GrammarParser.SOME, i);
		}
		public ITerminalNode[] ALL() { return GetTokens(EsperEPL2GrammarParser.ALL); }
		public ITerminalNode ALL(int i) {
			return GetToken(EsperEPL2GrammarParser.ALL, i);
		}
		public ITerminalNode[] LPAREN() { return GetTokens(EsperEPL2GrammarParser.LPAREN); }
		public ITerminalNode LPAREN(int i) {
			return GetToken(EsperEPL2GrammarParser.LPAREN, i);
		}
		public ITerminalNode[] RPAREN() { return GetTokens(EsperEPL2GrammarParser.RPAREN); }
		public ITerminalNode RPAREN(int i) {
			return GetToken(EsperEPL2GrammarParser.RPAREN, i);
		}
		public ExpressionListContext[] expressionList() {
			return GetRuleContexts<ExpressionListContext>();
		}
		public ExpressionListContext expressionList(int i) {
			return GetRuleContext<ExpressionListContext>(i);
		}
		public EvalEqualsExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evalEqualsExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEvalEqualsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEvalEqualsExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvalEqualsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EvalEqualsExpressionContext evalEqualsExpression() {
		EvalEqualsExpressionContext _localctx = new EvalEqualsExpressionContext(Context, State);
		EnterRule(_localctx, 300, RULE_evalEqualsExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2034; evalRelationalExpression();
			State = 2061;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==IS || ((((_la - 141)) & ~0x3f) == 0 && ((1L << (_la - 141)) & ((1L << (EQUALS - 141)) | (1L << (SQL_NE - 141)) | (1L << (NOT_EQUAL - 141)))) != 0)) {
				{
				{
				State = 2041;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,261,Context) ) {
				case 1:
					{
					State = 2035; _localctx.eq = Match(EQUALS);
					}
					break;
				case 2:
					{
					State = 2036; _localctx.@is = Match(IS);
					}
					break;
				case 3:
					{
					State = 2037; _localctx.isnot = Match(IS);
					State = 2038; Match(NOT_EXPR);
					}
					break;
				case 4:
					{
					State = 2039; _localctx.sqlne = Match(SQL_NE);
					}
					break;
				case 5:
					{
					State = 2040; _localctx.ne = Match(NOT_EQUAL);
					}
					break;
				}
				State = 2057;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case WINDOW:
				case ESCAPE:
				case EVERY_EXPR:
				case SUM:
				case AVG:
				case MAX:
				case MIN:
				case COALESCE:
				case MEDIAN:
				case STDDEV:
				case AVEDEV:
				case COUNT:
				case OUTER:
				case JOIN:
				case LEFT:
				case RIGHT:
				case FULL:
				case EVENTS:
				case FIRST:
				case LAST:
				case ISTREAM:
				case SCHEMA:
				case UNIDIRECTIONAL:
				case RETAINUNION:
				case RETAININTERSECTION:
				case PATTERN:
				case SQL:
				case METADATASQL:
				case PREVIOUS:
				case PREVIOUSTAIL:
				case PREVIOUSCOUNT:
				case PREVIOUSWINDOW:
				case PRIOR:
				case EXISTS:
				case WEEKDAY:
				case LW:
				case INSTANCEOF:
				case TYPEOF:
				case CAST:
				case CURRENT_TIMESTAMP:
				case SNAPSHOT:
				case VARIABLE:
				case TABLE:
				case UNTIL:
				case AT:
				case INDEX:
				case BOOLEAN_TRUE:
				case BOOLEAN_FALSE:
				case VALUE_NULL:
				case DEFINE:
				case PARTITION:
				case MATCHES:
				case FOR:
				case WHILE:
				case USING:
				case MERGE:
				case MATCHED:
				case NEWKW:
				case CONTEXT:
				case GROUPING:
				case GROUPING_ID:
				case QUESTION:
				case LPAREN:
				case LCURLY:
				case PLUS:
				case MINUS:
				case TICKED_STRING_LITERAL:
				case QUOTED_STRING_LITERAL:
				case STRING_LITERAL:
				case IDENT:
				case IntegerLiteral:
				case FloatingPointLiteral:
					{
					State = 2043; evalRelationalExpression();
					}
					break;
				case ALL:
				case ANY:
				case SOME:
					{
					State = 2047;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ANY:
						{
						State = 2044; _localctx.a = Match(ANY);
						}
						break;
					case SOME:
						{
						State = 2045; _localctx.a = Match(SOME);
						}
						break;
					case ALL:
						{
						State = 2046; _localctx.a = Match(ALL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2055;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,264,Context) ) {
					case 1:
						{
						{
						State = 2049; Match(LPAREN);
						State = 2051;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
							{
							State = 2050; expressionList();
							}
						}

						State = 2053; Match(RPAREN);
						}
						}
						break;
					case 2:
						{
						State = 2054; subSelectGroupExpression();
						}
						break;
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				}
				State = 2063;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvalRelationalExpressionContext : ParserRuleContext {
		public IToken r;
		public IToken g;
		public IToken n;
		public IToken @in;
		public IToken l;
		public IToken col;
		public IToken inset;
		public IToken between;
		public IToken like;
		public IToken regex;
		public ConcatenationExprContext[] concatenationExpr() {
			return GetRuleContexts<ConcatenationExprContext>();
		}
		public ConcatenationExprContext concatenationExpr(int i) {
			return GetRuleContext<ConcatenationExprContext>(i);
		}
		public InSubSelectQueryContext inSubSelectQuery() {
			return GetRuleContext<InSubSelectQueryContext>(0);
		}
		public BetweenListContext betweenList() {
			return GetRuleContext<BetweenListContext>(0);
		}
		public ITerminalNode IN_SET() { return GetToken(EsperEPL2GrammarParser.IN_SET, 0); }
		public ITerminalNode BETWEEN() { return GetToken(EsperEPL2GrammarParser.BETWEEN, 0); }
		public ITerminalNode LIKE() { return GetToken(EsperEPL2GrammarParser.LIKE, 0); }
		public ITerminalNode REGEXP() { return GetToken(EsperEPL2GrammarParser.REGEXP, 0); }
		public ITerminalNode NOT_EXPR() { return GetToken(EsperEPL2GrammarParser.NOT_EXPR, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode ESCAPE() { return GetToken(EsperEPL2GrammarParser.ESCAPE, 0); }
		public StringconstantContext stringconstant() {
			return GetRuleContext<StringconstantContext>(0);
		}
		public ITerminalNode[] LPAREN() { return GetTokens(EsperEPL2GrammarParser.LPAREN); }
		public ITerminalNode LPAREN(int i) {
			return GetToken(EsperEPL2GrammarParser.LPAREN, i);
		}
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode[] RPAREN() { return GetTokens(EsperEPL2GrammarParser.RPAREN); }
		public ITerminalNode RPAREN(int i) {
			return GetToken(EsperEPL2GrammarParser.RPAREN, i);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode[] LT() { return GetTokens(EsperEPL2GrammarParser.LT); }
		public ITerminalNode LT(int i) {
			return GetToken(EsperEPL2GrammarParser.LT, i);
		}
		public ITerminalNode[] GT() { return GetTokens(EsperEPL2GrammarParser.GT); }
		public ITerminalNode GT(int i) {
			return GetToken(EsperEPL2GrammarParser.GT, i);
		}
		public ITerminalNode[] LE() { return GetTokens(EsperEPL2GrammarParser.LE); }
		public ITerminalNode LE(int i) {
			return GetToken(EsperEPL2GrammarParser.LE, i);
		}
		public ITerminalNode[] GE() { return GetTokens(EsperEPL2GrammarParser.GE); }
		public ITerminalNode GE(int i) {
			return GetToken(EsperEPL2GrammarParser.GE, i);
		}
		public SubSelectGroupExpressionContext[] subSelectGroupExpression() {
			return GetRuleContexts<SubSelectGroupExpressionContext>();
		}
		public SubSelectGroupExpressionContext subSelectGroupExpression(int i) {
			return GetRuleContext<SubSelectGroupExpressionContext>(i);
		}
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode[] ANY() { return GetTokens(EsperEPL2GrammarParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(EsperEPL2GrammarParser.ANY, i);
		}
		public ITerminalNode[] SOME() { return GetTokens(EsperEPL2GrammarParser.SOME); }
		public ITerminalNode SOME(int i) {
			return GetToken(EsperEPL2GrammarParser.SOME, i);
		}
		public ITerminalNode[] ALL() { return GetTokens(EsperEPL2GrammarParser.ALL); }
		public ITerminalNode ALL(int i) {
			return GetToken(EsperEPL2GrammarParser.ALL, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionListContext[] expressionList() {
			return GetRuleContexts<ExpressionListContext>();
		}
		public ExpressionListContext expressionList(int i) {
			return GetRuleContext<ExpressionListContext>(i);
		}
		public EvalRelationalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evalRelationalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEvalRelationalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEvalRelationalExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvalRelationalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EvalRelationalExpressionContext evalRelationalExpression() {
		EvalRelationalExpressionContext _localctx = new EvalRelationalExpressionContext(Context, State);
		EnterRule(_localctx, 302, RULE_evalRelationalExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2064; concatenationExpr();
			State = 2130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,280,Context) ) {
			case 1:
				{
				{
				State = 2089;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (((((_la - 168)) & ~0x3f) == 0 && ((1L << (_la - 168)) & ((1L << (GE - 168)) | (1L << (GT - 168)) | (1L << (LE - 168)) | (1L << (LT - 168)))) != 0)) {
					{
					{
					State = 2069;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case LT:
						{
						State = 2065; _localctx.r = Match(LT);
						}
						break;
					case GT:
						{
						State = 2066; _localctx.r = Match(GT);
						}
						break;
					case LE:
						{
						State = 2067; _localctx.r = Match(LE);
						}
						break;
					case GE:
						{
						State = 2068; _localctx.r = Match(GE);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2085;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case WINDOW:
					case ESCAPE:
					case EVERY_EXPR:
					case SUM:
					case AVG:
					case MAX:
					case MIN:
					case COALESCE:
					case MEDIAN:
					case STDDEV:
					case AVEDEV:
					case COUNT:
					case OUTER:
					case JOIN:
					case LEFT:
					case RIGHT:
					case FULL:
					case EVENTS:
					case FIRST:
					case LAST:
					case ISTREAM:
					case SCHEMA:
					case UNIDIRECTIONAL:
					case RETAINUNION:
					case RETAININTERSECTION:
					case PATTERN:
					case SQL:
					case METADATASQL:
					case PREVIOUS:
					case PREVIOUSTAIL:
					case PREVIOUSCOUNT:
					case PREVIOUSWINDOW:
					case PRIOR:
					case EXISTS:
					case WEEKDAY:
					case LW:
					case INSTANCEOF:
					case TYPEOF:
					case CAST:
					case CURRENT_TIMESTAMP:
					case SNAPSHOT:
					case VARIABLE:
					case TABLE:
					case UNTIL:
					case AT:
					case INDEX:
					case BOOLEAN_TRUE:
					case BOOLEAN_FALSE:
					case VALUE_NULL:
					case DEFINE:
					case PARTITION:
					case MATCHES:
					case FOR:
					case WHILE:
					case USING:
					case MERGE:
					case MATCHED:
					case NEWKW:
					case CONTEXT:
					case GROUPING:
					case GROUPING_ID:
					case QUESTION:
					case LPAREN:
					case LCURLY:
					case PLUS:
					case MINUS:
					case TICKED_STRING_LITERAL:
					case QUOTED_STRING_LITERAL:
					case STRING_LITERAL:
					case IDENT:
					case IntegerLiteral:
					case FloatingPointLiteral:
						{
						State = 2071; concatenationExpr();
						}
						break;
					case ALL:
					case ANY:
					case SOME:
						{
						State = 2075;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case ANY:
							{
							State = 2072; _localctx.g = Match(ANY);
							}
							break;
						case SOME:
							{
							State = 2073; _localctx.g = Match(SOME);
							}
							break;
						case ALL:
							{
							State = 2074; _localctx.g = Match(ALL);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 2083;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,270,Context) ) {
						case 1:
							{
							{
							State = 2077; Match(LPAREN);
							State = 2079;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
								{
								State = 2078; expressionList();
								}
							}

							State = 2081; Match(RPAREN);
							}
							}
							break;
						case 2:
							{
							State = 2082; subSelectGroupExpression();
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					}
					State = 2091;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				}
				break;
			case 2:
				{
				State = 2093;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT_EXPR) {
					{
					State = 2092; _localctx.n = Match(NOT_EXPR);
					}
				}

				State = 2128;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,279,Context) ) {
				case 1:
					{
					{
					State = 2095; _localctx.@in = Match(IN_SET);
					State = 2098;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case LPAREN:
						{
						State = 2096; _localctx.l = Match(LPAREN);
						}
						break;
					case LBRACK:
						{
						State = 2097; _localctx.l = Match(LBRACK);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2100; expression();
					State = 2110;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case COLON:
						{
						{
						State = 2101; _localctx.col = Match(COLON);
						{
						State = 2102; expression();
						}
						}
						}
						break;
					case RPAREN:
					case RBRACK:
					case COMMA:
						{
						{
						State = 2107;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==COMMA) {
							{
							{
							State = 2103; Match(COMMA);
							State = 2104; expression();
							}
							}
							State = 2109;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2114;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case RPAREN:
						{
						State = 2112; _localctx.r = Match(RPAREN);
						}
						break;
					case RBRACK:
						{
						State = 2113; _localctx.r = Match(RBRACK);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					}
					break;
				case 2:
					{
					State = 2116; _localctx.inset = Match(IN_SET);
					State = 2117; inSubSelectQuery();
					}
					break;
				case 3:
					{
					State = 2118; _localctx.between = Match(BETWEEN);
					State = 2119; betweenList();
					}
					break;
				case 4:
					{
					State = 2120; _localctx.like = Match(LIKE);
					State = 2121; concatenationExpr();
					State = 2124;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,278,Context) ) {
					case 1:
						{
						State = 2122; Match(ESCAPE);
						State = 2123; stringconstant();
						}
						break;
					}
					}
					break;
				case 5:
					{
					State = 2126; _localctx.regex = Match(REGEXP);
					State = 2127; concatenationExpr();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InSubSelectQueryContext : ParserRuleContext {
		public SubQueryExprContext subQueryExpr() {
			return GetRuleContext<SubQueryExprContext>(0);
		}
		public InSubSelectQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inSubSelectQuery; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterInSubSelectQuery(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitInSubSelectQuery(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInSubSelectQuery(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InSubSelectQueryContext inSubSelectQuery() {
		InSubSelectQueryContext _localctx = new InSubSelectQueryContext(Context, State);
		EnterRule(_localctx, 304, RULE_inSubSelectQuery);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2132; subQueryExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConcatenationExprContext : ParserRuleContext {
		public IToken c;
		public AdditiveExpressionContext[] additiveExpression() {
			return GetRuleContexts<AdditiveExpressionContext>();
		}
		public AdditiveExpressionContext additiveExpression(int i) {
			return GetRuleContext<AdditiveExpressionContext>(i);
		}
		public ITerminalNode[] LOR() { return GetTokens(EsperEPL2GrammarParser.LOR); }
		public ITerminalNode LOR(int i) {
			return GetToken(EsperEPL2GrammarParser.LOR, i);
		}
		public ConcatenationExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenationExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterConcatenationExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitConcatenationExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatenationExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConcatenationExprContext concatenationExpr() {
		ConcatenationExprContext _localctx = new ConcatenationExprContext(Context, State);
		EnterRule(_localctx, 306, RULE_concatenationExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2134; additiveExpression();
			State = 2144;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LOR) {
				{
				State = 2135; _localctx.c = Match(LOR);
				State = 2136; additiveExpression();
				State = 2141;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==LOR) {
					{
					{
					State = 2137; Match(LOR);
					State = 2138; additiveExpression();
					}
					}
					State = 2143;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AdditiveExpressionContext : ParserRuleContext {
		public MultiplyExpressionContext[] multiplyExpression() {
			return GetRuleContexts<MultiplyExpressionContext>();
		}
		public MultiplyExpressionContext multiplyExpression(int i) {
			return GetRuleContext<MultiplyExpressionContext>(i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(EsperEPL2GrammarParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(EsperEPL2GrammarParser.PLUS, i);
		}
		public ITerminalNode[] MINUS() { return GetTokens(EsperEPL2GrammarParser.MINUS); }
		public ITerminalNode MINUS(int i) {
			return GetToken(EsperEPL2GrammarParser.MINUS, i);
		}
		public AdditiveExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additiveExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterAdditiveExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitAdditiveExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditiveExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdditiveExpressionContext additiveExpression() {
		AdditiveExpressionContext _localctx = new AdditiveExpressionContext(Context, State);
		EnterRule(_localctx, 308, RULE_additiveExpression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2146; multiplyExpression();
			State = 2151;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,283,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2147;
					_la = TokenStream.LA(1);
					if ( !(_la==PLUS || _la==MINUS) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 2148; multiplyExpression();
					}
					} 
				}
				State = 2153;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,283,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplyExpressionContext : ParserRuleContext {
		public UnaryExpressionContext[] unaryExpression() {
			return GetRuleContexts<UnaryExpressionContext>();
		}
		public UnaryExpressionContext unaryExpression(int i) {
			return GetRuleContext<UnaryExpressionContext>(i);
		}
		public ITerminalNode[] STAR() { return GetTokens(EsperEPL2GrammarParser.STAR); }
		public ITerminalNode STAR(int i) {
			return GetToken(EsperEPL2GrammarParser.STAR, i);
		}
		public ITerminalNode[] DIV() { return GetTokens(EsperEPL2GrammarParser.DIV); }
		public ITerminalNode DIV(int i) {
			return GetToken(EsperEPL2GrammarParser.DIV, i);
		}
		public ITerminalNode[] MOD() { return GetTokens(EsperEPL2GrammarParser.MOD); }
		public ITerminalNode MOD(int i) {
			return GetToken(EsperEPL2GrammarParser.MOD, i);
		}
		public MultiplyExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplyExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMultiplyExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMultiplyExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplyExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplyExpressionContext multiplyExpression() {
		MultiplyExpressionContext _localctx = new MultiplyExpressionContext(Context, State);
		EnterRule(_localctx, 310, RULE_multiplyExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2154; unaryExpression();
			State = 2159;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 156)) & ~0x3f) == 0 && ((1L << (_la - 156)) & ((1L << (DIV - 156)) | (1L << (STAR - 156)) | (1L << (MOD - 156)))) != 0)) {
				{
				{
				State = 2155;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 156)) & ~0x3f) == 0 && ((1L << (_la - 156)) & ((1L << (DIV - 156)) | (1L << (STAR - 156)) | (1L << (MOD - 156)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2156; unaryExpression();
				}
				}
				State = 2161;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryExpressionContext : ParserRuleContext {
		public IToken inner;
		public IToken b;
		public ITerminalNode MINUS() { return GetToken(EsperEPL2GrammarParser.MINUS, 0); }
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public SubstitutionCanChainContext substitutionCanChain() {
			return GetRuleContext<SubstitutionCanChainContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public BuiltinFuncContext builtinFunc() {
			return GetRuleContext<BuiltinFuncContext>(0);
		}
		public EventPropertyOrLibFunctionContext eventPropertyOrLibFunction() {
			return GetRuleContext<EventPropertyOrLibFunctionContext>(0);
		}
		public ArrayExpressionContext arrayExpression() {
			return GetRuleContext<ArrayExpressionContext>(0);
		}
		public RowSubSelectExpressionContext rowSubSelectExpression() {
			return GetRuleContext<RowSubSelectExpressionContext>(0);
		}
		public ExistsSubSelectExpressionContext existsSubSelectExpression() {
			return GetRuleContext<ExistsSubSelectExpressionContext>(0);
		}
		public ITerminalNode NEWKW() { return GetToken(EsperEPL2GrammarParser.NEWKW, 0); }
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public NewAssignContext[] newAssign() {
			return GetRuleContexts<NewAssignContext>();
		}
		public NewAssignContext newAssign(int i) {
			return GetRuleContext<NewAssignContext>(i);
		}
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public JsonobjectContext jsonobject() {
			return GetRuleContext<JsonobjectContext>(0);
		}
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryExpressionContext unaryExpression() {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(Context, State);
		EnterRule(_localctx, 312, RULE_unaryExpression);
		int _la;
		try {
			State = 2221;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,292,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2162; Match(MINUS);
				State = 2163; eventProperty();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2164; constant();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2165; substitutionCanChain();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2166; _localctx.inner = Match(LPAREN);
				State = 2167; expression();
				State = 2168; Match(RPAREN);
				State = 2170;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 2169; chainedFunction();
					}
				}

				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2172; builtinFunc();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2173; eventPropertyOrLibFunction();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2174; arrayExpression();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2175; rowSubSelectExpression();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2176; existsSubSelectExpression();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2177; Match(NEWKW);
				State = 2178; Match(LCURLY);
				State = 2179; newAssign();
				State = 2184;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2180; Match(COMMA);
					State = 2181; newAssign();
					}
					}
					State = 2186;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2187; Match(RCURLY);
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2189; Match(NEWKW);
				State = 2190; classIdentifier();
				State = 2191; Match(LPAREN);
				State = 2200;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 2192; expression();
					State = 2197;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 2193; Match(COMMA);
						State = 2194; expression();
						}
						}
						State = 2199;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 2202; Match(RPAREN);
				State = 2204;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 2203; chainedFunction();
					}
				}

				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2206; _localctx.b = Match(IDENT);
				State = 2207; Match(LBRACK);
				State = 2208; expression();
				State = 2213;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2209; Match(COMMA);
					State = 2210; expression();
					}
					}
					State = 2215;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2216; Match(RBRACK);
				State = 2218;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 2217; chainedFunction();
					}
				}

				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2220; jsonobject();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubstitutionCanChainContext : ParserRuleContext {
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public SubstitutionCanChainContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_substitutionCanChain; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubstitutionCanChain(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubstitutionCanChain(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubstitutionCanChain(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubstitutionCanChainContext substitutionCanChain() {
		SubstitutionCanChainContext _localctx = new SubstitutionCanChainContext(Context, State);
		EnterRule(_localctx, 314, RULE_substitutionCanChain);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2223; substitution();
			State = 2225;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOT) {
				{
				State = 2224; chainedFunction();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChainedFunctionContext : ParserRuleContext {
		public IToken d;
		public LibFunctionNoClassContext[] libFunctionNoClass() {
			return GetRuleContexts<LibFunctionNoClassContext>();
		}
		public LibFunctionNoClassContext libFunctionNoClass(int i) {
			return GetRuleContext<LibFunctionNoClassContext>(i);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public ChainedFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_chainedFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterChainedFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitChainedFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChainedFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ChainedFunctionContext chainedFunction() {
		ChainedFunctionContext _localctx = new ChainedFunctionContext(Context, State);
		EnterRule(_localctx, 316, RULE_chainedFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2227; _localctx.d = Match(DOT);
			State = 2228; libFunctionNoClass();
			State = 2233;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DOT) {
				{
				{
				State = 2229; _localctx.d = Match(DOT);
				State = 2230; libFunctionNoClass();
				}
				}
				State = 2235;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewAssignContext : ParserRuleContext {
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public NewAssignContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newAssign; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNewAssign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNewAssign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewAssignContext newAssign() {
		NewAssignContext _localctx = new NewAssignContext(Context, State);
		EnterRule(_localctx, 318, RULE_newAssign);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2236; eventProperty();
			State = 2239;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUALS) {
				{
				State = 2237; Match(EQUALS);
				State = 2238; expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RowSubSelectExpressionContext : ParserRuleContext {
		public SubQueryExprContext subQueryExpr() {
			return GetRuleContext<SubQueryExprContext>(0);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public RowSubSelectExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rowSubSelectExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterRowSubSelectExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitRowSubSelectExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRowSubSelectExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RowSubSelectExpressionContext rowSubSelectExpression() {
		RowSubSelectExpressionContext _localctx = new RowSubSelectExpressionContext(Context, State);
		EnterRule(_localctx, 320, RULE_rowSubSelectExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2241; subQueryExpr();
			State = 2243;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOT) {
				{
				State = 2242; chainedFunction();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubSelectGroupExpressionContext : ParserRuleContext {
		public SubQueryExprContext subQueryExpr() {
			return GetRuleContext<SubQueryExprContext>(0);
		}
		public SubSelectGroupExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subSelectGroupExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubSelectGroupExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubSelectGroupExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubSelectGroupExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubSelectGroupExpressionContext subSelectGroupExpression() {
		SubSelectGroupExpressionContext _localctx = new SubSelectGroupExpressionContext(Context, State);
		EnterRule(_localctx, 322, RULE_subSelectGroupExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2245; subQueryExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExistsSubSelectExpressionContext : ParserRuleContext {
		public ITerminalNode EXISTS() { return GetToken(EsperEPL2GrammarParser.EXISTS, 0); }
		public SubQueryExprContext subQueryExpr() {
			return GetRuleContext<SubQueryExprContext>(0);
		}
		public ExistsSubSelectExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_existsSubSelectExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExistsSubSelectExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExistsSubSelectExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExistsSubSelectExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExistsSubSelectExpressionContext existsSubSelectExpression() {
		ExistsSubSelectExpressionContext _localctx = new ExistsSubSelectExpressionContext(Context, State);
		EnterRule(_localctx, 324, RULE_existsSubSelectExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2247; Match(EXISTS);
			State = 2248; subQueryExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubQueryExprContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public SubSelectFilterExprContext subSelectFilterExpr() {
			return GetRuleContext<SubSelectFilterExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode GROUP() { return GetToken(EsperEPL2GrammarParser.GROUP, 0); }
		public ITerminalNode BY() { return GetToken(EsperEPL2GrammarParser.BY, 0); }
		public GroupByListExprContext groupByListExpr() {
			return GetRuleContext<GroupByListExprContext>(0);
		}
		public ITerminalNode HAVING() { return GetToken(EsperEPL2GrammarParser.HAVING, 0); }
		public HavingClauseContext havingClause() {
			return GetRuleContext<HavingClauseContext>(0);
		}
		public SubQueryExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subQueryExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubQueryExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubQueryExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubQueryExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubQueryExprContext subQueryExpr() {
		SubQueryExprContext _localctx = new SubQueryExprContext(Context, State);
		EnterRule(_localctx, 326, RULE_subQueryExpr);
		 paraphrases.Push("subquery"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2250; Match(LPAREN);
			State = 2251; Match(SELECT);
			State = 2253;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISTINCT) {
				{
				State = 2252; Match(DISTINCT);
				}
			}

			State = 2255; selectionList();
			State = 2256; Match(FROM);
			State = 2257; subSelectFilterExpr();
			State = 2260;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 2258; Match(WHERE);
				State = 2259; whereClause();
				}
			}

			State = 2265;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GROUP) {
				{
				State = 2262; Match(GROUP);
				State = 2263; Match(BY);
				State = 2264; groupByListExpr();
				}
			}

			State = 2269;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==HAVING) {
				{
				State = 2267; Match(HAVING);
				State = 2268; havingClause();
				}
			}

			State = 2271; Match(RPAREN);
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubSelectFilterExprContext : ParserRuleContext {
		public IToken i;
		public IToken ru;
		public IToken ri;
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public ViewExpressionsContext viewExpressions() {
			return GetRuleContext<ViewExpressionsContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode RETAINUNION() { return GetToken(EsperEPL2GrammarParser.RETAINUNION, 0); }
		public ITerminalNode RETAININTERSECTION() { return GetToken(EsperEPL2GrammarParser.RETAININTERSECTION, 0); }
		public SubSelectFilterExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subSelectFilterExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubSelectFilterExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubSelectFilterExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubSelectFilterExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubSelectFilterExprContext subSelectFilterExpr() {
		SubSelectFilterExprContext _localctx = new SubSelectFilterExprContext(Context, State);
		EnterRule(_localctx, 328, RULE_subSelectFilterExpr);
		 paraphrases.Push("subquery filter specification"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2273; eventFilterExpression();
			State = 2275;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOT || _la==HASHCHAR) {
				{
				State = 2274; viewExpressions();
				}
			}

			State = 2280;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AS:
				{
				State = 2277; Match(AS);
				State = 2278; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 2279; _localctx.i = Match(IDENT);
				}
				break;
			case WHERE:
			case GROUP:
			case HAVING:
			case RETAINUNION:
			case RETAININTERSECTION:
			case RPAREN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2284;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RETAINUNION:
				{
				State = 2282; _localctx.ru = Match(RETAINUNION);
				}
				break;
			case RETAININTERSECTION:
				{
				State = 2283; _localctx.ri = Match(RETAININTERSECTION);
				}
				break;
			case WHERE:
			case GROUP:
			case HAVING:
			case RPAREN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayExpressionContext : ParserRuleContext {
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ArrayExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterArrayExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitArrayExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayExpressionContext arrayExpression() {
		ArrayExpressionContext _localctx = new ArrayExpressionContext(Context, State);
		EnterRule(_localctx, 330, RULE_arrayExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2286; Match(LCURLY);
			State = 2295;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
				{
				State = 2287; expression();
				State = 2292;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2288; Match(COMMA);
					State = 2289; expression();
					}
					}
					State = 2294;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 2297; Match(RCURLY);
			State = 2299;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOT) {
				{
				State = 2298; chainedFunction();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltinFuncContext : ParserRuleContext {
		public BuiltinFuncContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtinFunc; } }
	 
		public BuiltinFuncContext() { }
		public virtual void CopyFrom(BuiltinFuncContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Builtin_castContext : BuiltinFuncContext {
		public ITerminalNode CAST() { return GetToken(EsperEPL2GrammarParser.CAST, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ExpressionNamedParameterContext expressionNamedParameter() {
			return GetRuleContext<ExpressionNamedParameterContext>(0);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_castContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_cast(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_cast(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_cast(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_cntContext : BuiltinFuncContext {
		public IToken a;
		public IToken d;
		public ITerminalNode COUNT() { return GetToken(EsperEPL2GrammarParser.COUNT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_cntContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_cnt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_cnt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_cnt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_sumContext : BuiltinFuncContext {
		public ITerminalNode SUM() { return GetToken(EsperEPL2GrammarParser.SUM, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_sumContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_sum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_sum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_sum(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_priorContext : BuiltinFuncContext {
		public ITerminalNode PRIOR() { return GetToken(EsperEPL2GrammarParser.PRIOR, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_priorContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prior(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prior(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prior(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_existsContext : BuiltinFuncContext {
		public ITerminalNode EXISTS() { return GetToken(EsperEPL2GrammarParser.EXISTS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_existsContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_exists(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_exists(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_exists(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_prevtailContext : BuiltinFuncContext {
		public ITerminalNode PREVIOUSTAIL() { return GetToken(EsperEPL2GrammarParser.PREVIOUSTAIL, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_prevtailContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prevtail(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prevtail(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prevtail(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_istreamContext : BuiltinFuncContext {
		public ITerminalNode ISTREAM() { return GetToken(EsperEPL2GrammarParser.ISTREAM, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_istreamContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_istream(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_istream(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_istream(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_medianContext : BuiltinFuncContext {
		public ITerminalNode MEDIAN() { return GetToken(EsperEPL2GrammarParser.MEDIAN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_medianContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_median(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_median(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_median(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_currtsContext : BuiltinFuncContext {
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(EsperEPL2GrammarParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_currtsContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_currts(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_currts(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_currts(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_coalesceContext : BuiltinFuncContext {
		public ITerminalNode COALESCE() { return GetToken(EsperEPL2GrammarParser.COALESCE, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_coalesceContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_coalesce(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_coalesce(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_coalesce(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_prevContext : BuiltinFuncContext {
		public ITerminalNode PREVIOUS() { return GetToken(EsperEPL2GrammarParser.PREVIOUS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_prevContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prev(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prev(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prev(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_prevcountContext : BuiltinFuncContext {
		public ITerminalNode PREVIOUSCOUNT() { return GetToken(EsperEPL2GrammarParser.PREVIOUSCOUNT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_prevcountContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prevcount(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prevcount(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prevcount(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_groupingidContext : BuiltinFuncContext {
		public ITerminalNode GROUPING_ID() { return GetToken(EsperEPL2GrammarParser.GROUPING_ID, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_groupingidContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_groupingid(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_groupingid(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_groupingid(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_prevwindowContext : BuiltinFuncContext {
		public ITerminalNode PREVIOUSWINDOW() { return GetToken(EsperEPL2GrammarParser.PREVIOUSWINDOW, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_prevwindowContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prevwindow(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prevwindow(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prevwindow(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_stddevContext : BuiltinFuncContext {
		public ITerminalNode STDDEV() { return GetToken(EsperEPL2GrammarParser.STDDEV, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_stddevContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_stddev(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_stddev(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_stddev(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_groupingContext : BuiltinFuncContext {
		public ITerminalNode GROUPING() { return GetToken(EsperEPL2GrammarParser.GROUPING, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_groupingContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_grouping(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_grouping(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_grouping(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_typeofContext : BuiltinFuncContext {
		public ITerminalNode TYPEOF() { return GetToken(EsperEPL2GrammarParser.TYPEOF, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_typeofContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_typeof(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_typeof(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_typeof(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_firstlastwindowContext : BuiltinFuncContext {
		public FirstLastWindowAggregationContext firstLastWindowAggregation() {
			return GetRuleContext<FirstLastWindowAggregationContext>(0);
		}
		public Builtin_firstlastwindowContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_firstlastwindow(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_firstlastwindow(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_firstlastwindow(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_instanceofContext : BuiltinFuncContext {
		public ITerminalNode INSTANCEOF() { return GetToken(EsperEPL2GrammarParser.INSTANCEOF, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ClassIdentifierContext[] classIdentifier() {
			return GetRuleContexts<ClassIdentifierContext>();
		}
		public ClassIdentifierContext classIdentifier(int i) {
			return GetRuleContext<ClassIdentifierContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_instanceofContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_instanceof(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_instanceof(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_instanceof(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_avgContext : BuiltinFuncContext {
		public ITerminalNode AVG() { return GetToken(EsperEPL2GrammarParser.AVG, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_avgContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_avg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_avg(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_avg(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_avedevContext : BuiltinFuncContext {
		public ITerminalNode AVEDEV() { return GetToken(EsperEPL2GrammarParser.AVEDEV, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_avedevContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_avedev(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_avedev(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_avedev(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BuiltinFuncContext builtinFunc() {
		BuiltinFuncContext _localctx = new BuiltinFuncContext(Context, State);
		EnterRule(_localctx, 332, RULE_builtinFunc);
		int _la;
		try {
			State = 2464;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SUM:
				_localctx = new Builtin_sumContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2301; Match(SUM);
				State = 2302; Match(LPAREN);
				State = 2304;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2303;
					_la = TokenStream.LA(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2306; expressionListWithNamed();
				State = 2307; Match(RPAREN);
				}
				break;
			case AVG:
				_localctx = new Builtin_avgContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2309; Match(AVG);
				State = 2310; Match(LPAREN);
				State = 2312;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2311;
					_la = TokenStream.LA(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2314; expressionListWithNamed();
				State = 2315; Match(RPAREN);
				}
				break;
			case COUNT:
				_localctx = new Builtin_cntContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2317; Match(COUNT);
				State = 2318; Match(LPAREN);
				State = 2321;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ALL:
					{
					State = 2319; ((Builtin_cntContext)_localctx).a = Match(ALL);
					}
					break;
				case DISTINCT:
					{
					State = 2320; ((Builtin_cntContext)_localctx).d = Match(DISTINCT);
					}
					break;
				case WINDOW:
				case ESCAPE:
				case NOT_EXPR:
				case EVERY_EXPR:
				case SUM:
				case AVG:
				case MAX:
				case MIN:
				case COALESCE:
				case MEDIAN:
				case STDDEV:
				case AVEDEV:
				case COUNT:
				case CASE:
				case OUTER:
				case JOIN:
				case LEFT:
				case RIGHT:
				case FULL:
				case EVENTS:
				case FIRST:
				case LAST:
				case ISTREAM:
				case SCHEMA:
				case UNIDIRECTIONAL:
				case RETAINUNION:
				case RETAININTERSECTION:
				case PATTERN:
				case SQL:
				case METADATASQL:
				case PREVIOUS:
				case PREVIOUSTAIL:
				case PREVIOUSCOUNT:
				case PREVIOUSWINDOW:
				case PRIOR:
				case EXISTS:
				case WEEKDAY:
				case LW:
				case INSTANCEOF:
				case TYPEOF:
				case CAST:
				case CURRENT_TIMESTAMP:
				case SNAPSHOT:
				case VARIABLE:
				case TABLE:
				case UNTIL:
				case AT:
				case INDEX:
				case BOOLEAN_TRUE:
				case BOOLEAN_FALSE:
				case VALUE_NULL:
				case DEFINE:
				case PARTITION:
				case MATCHES:
				case FOR:
				case WHILE:
				case USING:
				case MERGE:
				case MATCHED:
				case NEWKW:
				case CONTEXT:
				case GROUPING:
				case GROUPING_ID:
				case QUESTION:
				case LPAREN:
				case LBRACK:
				case LCURLY:
				case PLUS:
				case MINUS:
				case STAR:
				case TICKED_STRING_LITERAL:
				case QUOTED_STRING_LITERAL:
				case STRING_LITERAL:
				case IDENT:
				case IntegerLiteral:
				case FloatingPointLiteral:
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2323; expressionListWithNamed();
				State = 2324; Match(RPAREN);
				}
				break;
			case MEDIAN:
				_localctx = new Builtin_medianContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2326; Match(MEDIAN);
				State = 2327; Match(LPAREN);
				State = 2329;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2328;
					_la = TokenStream.LA(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2331; expressionListWithNamed();
				State = 2332; Match(RPAREN);
				}
				break;
			case STDDEV:
				_localctx = new Builtin_stddevContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 2334; Match(STDDEV);
				State = 2335; Match(LPAREN);
				State = 2337;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2336;
					_la = TokenStream.LA(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2339; expressionListWithNamed();
				State = 2340; Match(RPAREN);
				}
				break;
			case AVEDEV:
				_localctx = new Builtin_avedevContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 2342; Match(AVEDEV);
				State = 2343; Match(LPAREN);
				State = 2345;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2344;
					_la = TokenStream.LA(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2347; expressionListWithNamed();
				State = 2348; Match(RPAREN);
				}
				break;
			case WINDOW:
			case FIRST:
			case LAST:
				_localctx = new Builtin_firstlastwindowContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 2350; firstLastWindowAggregation();
				}
				break;
			case COALESCE:
				_localctx = new Builtin_coalesceContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 2351; Match(COALESCE);
				State = 2352; Match(LPAREN);
				State = 2353; expression();
				State = 2354; Match(COMMA);
				State = 2355; expression();
				State = 2360;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2356; Match(COMMA);
					State = 2357; expression();
					}
					}
					State = 2362;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2363; Match(RPAREN);
				}
				break;
			case PREVIOUS:
				_localctx = new Builtin_prevContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 2365; Match(PREVIOUS);
				State = 2366; Match(LPAREN);
				State = 2367; expression();
				State = 2370;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2368; Match(COMMA);
					State = 2369; expression();
					}
				}

				State = 2372; Match(RPAREN);
				State = 2374;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 2373; chainedFunction();
					}
				}

				}
				break;
			case PREVIOUSTAIL:
				_localctx = new Builtin_prevtailContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 2376; Match(PREVIOUSTAIL);
				State = 2377; Match(LPAREN);
				State = 2378; expression();
				State = 2381;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2379; Match(COMMA);
					State = 2380; expression();
					}
				}

				State = 2383; Match(RPAREN);
				State = 2385;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 2384; chainedFunction();
					}
				}

				}
				break;
			case PREVIOUSCOUNT:
				_localctx = new Builtin_prevcountContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 2387; Match(PREVIOUSCOUNT);
				State = 2388; Match(LPAREN);
				State = 2389; expression();
				State = 2390; Match(RPAREN);
				}
				break;
			case PREVIOUSWINDOW:
				_localctx = new Builtin_prevwindowContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 2392; Match(PREVIOUSWINDOW);
				State = 2393; Match(LPAREN);
				State = 2394; expression();
				State = 2395; Match(RPAREN);
				State = 2397;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 2396; chainedFunction();
					}
				}

				}
				break;
			case PRIOR:
				_localctx = new Builtin_priorContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 2399; Match(PRIOR);
				State = 2400; Match(LPAREN);
				State = 2401; expression();
				State = 2402; Match(COMMA);
				State = 2403; eventProperty();
				State = 2404; Match(RPAREN);
				}
				break;
			case GROUPING:
				_localctx = new Builtin_groupingContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 2406; Match(GROUPING);
				State = 2407; Match(LPAREN);
				State = 2408; expression();
				State = 2409; Match(RPAREN);
				}
				break;
			case GROUPING_ID:
				_localctx = new Builtin_groupingidContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 2411; Match(GROUPING_ID);
				State = 2412; Match(LPAREN);
				State = 2413; expressionList();
				State = 2414; Match(RPAREN);
				}
				break;
			case INSTANCEOF:
				_localctx = new Builtin_instanceofContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 2416; Match(INSTANCEOF);
				State = 2417; Match(LPAREN);
				State = 2418; expression();
				State = 2419; Match(COMMA);
				State = 2420; classIdentifier();
				State = 2425;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2421; Match(COMMA);
					State = 2422; classIdentifier();
					}
					}
					State = 2427;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2428; Match(RPAREN);
				}
				break;
			case TYPEOF:
				_localctx = new Builtin_typeofContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 2430; Match(TYPEOF);
				State = 2431; Match(LPAREN);
				State = 2432; expression();
				State = 2433; Match(RPAREN);
				}
				break;
			case CAST:
				_localctx = new Builtin_castContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 2435; Match(CAST);
				State = 2436; Match(LPAREN);
				State = 2437; expression();
				State = 2438;
				_la = TokenStream.LA(1);
				if ( !(_la==AS || _la==COMMA) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2439; classIdentifier();
				State = 2442;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2440; Match(COMMA);
					State = 2441; expressionNamedParameter();
					}
				}

				State = 2444; Match(RPAREN);
				State = 2446;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 2445; chainedFunction();
					}
				}

				}
				break;
			case EXISTS:
				_localctx = new Builtin_existsContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 2448; Match(EXISTS);
				State = 2449; Match(LPAREN);
				State = 2450; eventProperty();
				State = 2451; Match(RPAREN);
				}
				break;
			case CURRENT_TIMESTAMP:
				_localctx = new Builtin_currtsContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 2453; Match(CURRENT_TIMESTAMP);
				State = 2456;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,322,Context) ) {
				case 1:
					{
					State = 2454; Match(LPAREN);
					State = 2455; Match(RPAREN);
					}
					break;
				}
				State = 2459;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOT) {
					{
					State = 2458; chainedFunction();
					}
				}

				}
				break;
			case ISTREAM:
				_localctx = new Builtin_istreamContext(_localctx);
				EnterOuterAlt(_localctx, 21);
				{
				State = 2461; Match(ISTREAM);
				State = 2462; Match(LPAREN);
				State = 2463; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FirstLastWindowAggregationContext : ParserRuleContext {
		public IToken q;
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public FirstLastWindowAggregationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_firstLastWindowAggregation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFirstLastWindowAggregation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFirstLastWindowAggregation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFirstLastWindowAggregation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FirstLastWindowAggregationContext firstLastWindowAggregation() {
		FirstLastWindowAggregationContext _localctx = new FirstLastWindowAggregationContext(Context, State);
		EnterRule(_localctx, 334, RULE_firstLastWindowAggregation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2469;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FIRST:
				{
				State = 2466; _localctx.q = Match(FIRST);
				}
				break;
			case LAST:
				{
				State = 2467; _localctx.q = Match(LAST);
				}
				break;
			case WINDOW:
				{
				State = 2468; _localctx.q = Match(WINDOW);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2471; Match(LPAREN);
			State = 2473;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LBRACK - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (STAR - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
				{
				State = 2472; expressionListWithNamed();
				}
			}

			State = 2475; Match(RPAREN);
			State = 2477;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOT) {
				{
				State = 2476; chainedFunction();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventPropertyOrLibFunctionContext : ParserRuleContext {
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public LibFunctionContext libFunction() {
			return GetRuleContext<LibFunctionContext>(0);
		}
		public EventPropertyOrLibFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventPropertyOrLibFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventPropertyOrLibFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventPropertyOrLibFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventPropertyOrLibFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventPropertyOrLibFunctionContext eventPropertyOrLibFunction() {
		EventPropertyOrLibFunctionContext _localctx = new EventPropertyOrLibFunctionContext(Context, State);
		EnterRule(_localctx, 336, RULE_eventPropertyOrLibFunction);
		try {
			State = 2481;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,328,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2479; eventProperty();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2480; libFunction();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionContext : ParserRuleContext {
		public LibFunctionWithClassContext libFunctionWithClass() {
			return GetRuleContext<LibFunctionWithClassContext>(0);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public LibFunctionNoClassContext[] libFunctionNoClass() {
			return GetRuleContexts<LibFunctionNoClassContext>();
		}
		public LibFunctionNoClassContext libFunctionNoClass(int i) {
			return GetRuleContext<LibFunctionNoClassContext>(i);
		}
		public LibFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionContext libFunction() {
		LibFunctionContext _localctx = new LibFunctionContext(Context, State);
		EnterRule(_localctx, 338, RULE_libFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2483; libFunctionWithClass();
			State = 2488;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DOT) {
				{
				{
				State = 2484; Match(DOT);
				State = 2485; libFunctionNoClass();
				}
				}
				State = 2490;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionWithClassContext : ParserRuleContext {
		public IToken l;
		public FuncIdentTopContext funcIdentTop() {
			return GetRuleContext<FuncIdentTopContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(EsperEPL2GrammarParser.DOT, 0); }
		public FuncIdentInnerContext funcIdentInner() {
			return GetRuleContext<FuncIdentInnerContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public LibFunctionArgsContext libFunctionArgs() {
			return GetRuleContext<LibFunctionArgsContext>(0);
		}
		public LibFunctionWithClassContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunctionWithClass; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunctionWithClass(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunctionWithClass(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunctionWithClass(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionWithClassContext libFunctionWithClass() {
		LibFunctionWithClassContext _localctx = new LibFunctionWithClassContext(Context, State);
		EnterRule(_localctx, 340, RULE_libFunctionWithClass);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2496;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,330,Context) ) {
			case 1:
				{
				{
				State = 2491; classIdentifier();
				State = 2492; Match(DOT);
				State = 2493; funcIdentInner();
				}
				}
				break;
			case 2:
				{
				State = 2495; funcIdentTop();
				}
				break;
			}
			State = 2503;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,332,Context) ) {
			case 1:
				{
				State = 2498; _localctx.l = Match(LPAREN);
				State = 2500;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (DISTINCT - 2)) | (1L << (ALL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LBRACK - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (STAR - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 2499; libFunctionArgs();
					}
				}

				State = 2502; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionNoClassContext : ParserRuleContext {
		public IToken l;
		public FuncIdentChainedContext funcIdentChained() {
			return GetRuleContext<FuncIdentChainedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public LibFunctionArgsContext libFunctionArgs() {
			return GetRuleContext<LibFunctionArgsContext>(0);
		}
		public LibFunctionNoClassContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunctionNoClass; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunctionNoClass(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunctionNoClass(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunctionNoClass(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionNoClassContext libFunctionNoClass() {
		LibFunctionNoClassContext _localctx = new LibFunctionNoClassContext(Context, State);
		EnterRule(_localctx, 342, RULE_libFunctionNoClass);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2505; funcIdentChained();
			State = 2511;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,334,Context) ) {
			case 1:
				{
				State = 2506; _localctx.l = Match(LPAREN);
				State = 2508;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (DISTINCT - 2)) | (1L << (ALL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LBRACK - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (STAR - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 2507; libFunctionArgs();
					}
				}

				State = 2510; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncIdentTopContext : ParserRuleContext {
		public EscapableIdentContext escapableIdent() {
			return GetRuleContext<EscapableIdentContext>(0);
		}
		public ITerminalNode MAX() { return GetToken(EsperEPL2GrammarParser.MAX, 0); }
		public ITerminalNode MIN() { return GetToken(EsperEPL2GrammarParser.MIN, 0); }
		public FuncIdentTopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcIdentTop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFuncIdentTop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFuncIdentTop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncIdentTop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncIdentTopContext funcIdentTop() {
		FuncIdentTopContext _localctx = new FuncIdentTopContext(Context, State);
		EnterRule(_localctx, 344, RULE_funcIdentTop);
		try {
			State = 2516;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2513; escapableIdent();
				}
				break;
			case MAX:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2514; Match(MAX);
				}
				break;
			case MIN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2515; Match(MIN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncIdentInnerContext : ParserRuleContext {
		public EscapableIdentContext escapableIdent() {
			return GetRuleContext<EscapableIdentContext>(0);
		}
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public FuncIdentInnerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcIdentInner; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFuncIdentInner(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFuncIdentInner(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncIdentInner(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncIdentInnerContext funcIdentInner() {
		FuncIdentInnerContext _localctx = new FuncIdentInnerContext(Context, State);
		EnterRule(_localctx, 346, RULE_funcIdentInner);
		try {
			State = 2522;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2518; escapableIdent();
				}
				break;
			case LAST:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2519; Match(LAST);
				}
				break;
			case FIRST:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2520; Match(FIRST);
				}
				break;
			case WINDOW:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2521; Match(WINDOW);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncIdentChainedContext : ParserRuleContext {
		public EscapableIdentContext escapableIdent() {
			return GetRuleContext<EscapableIdentContext>(0);
		}
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public ITerminalNode MAX() { return GetToken(EsperEPL2GrammarParser.MAX, 0); }
		public ITerminalNode MIN() { return GetToken(EsperEPL2GrammarParser.MIN, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public ITerminalNode AFTER() { return GetToken(EsperEPL2GrammarParser.AFTER, 0); }
		public ITerminalNode BETWEEN() { return GetToken(EsperEPL2GrammarParser.BETWEEN, 0); }
		public FuncIdentChainedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcIdentChained; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFuncIdentChained(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFuncIdentChained(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncIdentChained(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncIdentChainedContext funcIdentChained() {
		FuncIdentChainedContext _localctx = new FuncIdentChainedContext(Context, State);
		EnterRule(_localctx, 348, RULE_funcIdentChained);
		try {
			State = 2534;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2524; escapableIdent();
				}
				break;
			case LAST:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2525; Match(LAST);
				}
				break;
			case FIRST:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2526; Match(FIRST);
				}
				break;
			case WINDOW:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2527; Match(WINDOW);
				}
				break;
			case MAX:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2528; Match(MAX);
				}
				break;
			case MIN:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2529; Match(MIN);
				}
				break;
			case WHERE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2530; Match(WHERE);
				}
				break;
			case SET:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2531; Match(SET);
				}
				break;
			case AFTER:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2532; Match(AFTER);
				}
				break;
			case BETWEEN:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2533; Match(BETWEEN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionArgsContext : ParserRuleContext {
		public LibFunctionArgItemContext[] libFunctionArgItem() {
			return GetRuleContexts<LibFunctionArgItemContext>();
		}
		public LibFunctionArgItemContext libFunctionArgItem(int i) {
			return GetRuleContext<LibFunctionArgItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public LibFunctionArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunctionArgs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunctionArgs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunctionArgs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunctionArgs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionArgsContext libFunctionArgs() {
		LibFunctionArgsContext _localctx = new LibFunctionArgsContext(Context, State);
		EnterRule(_localctx, 350, RULE_libFunctionArgs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2537;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DISTINCT || _la==ALL) {
				{
				State = 2536;
				_la = TokenStream.LA(1);
				if ( !(_la==DISTINCT || _la==ALL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2539; libFunctionArgItem();
			State = 2544;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2540; Match(COMMA);
				State = 2541; libFunctionArgItem();
				}
				}
				State = 2546;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionArgItemContext : ParserRuleContext {
		public ExpressionWithNamedContext expressionWithNamed() {
			return GetRuleContext<ExpressionWithNamedContext>(0);
		}
		public ExpressionLambdaDeclContext expressionLambdaDecl() {
			return GetRuleContext<ExpressionLambdaDeclContext>(0);
		}
		public LibFunctionArgItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunctionArgItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunctionArgItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunctionArgItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunctionArgItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionArgItemContext libFunctionArgItem() {
		LibFunctionArgItemContext _localctx = new LibFunctionArgItemContext(Context, State);
		EnterRule(_localctx, 352, RULE_libFunctionArgItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2548;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,340,Context) ) {
			case 1:
				{
				State = 2547; expressionLambdaDecl();
				}
				break;
			}
			State = 2550; expressionWithNamed();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BetweenListContext : ParserRuleContext {
		public ConcatenationExprContext[] concatenationExpr() {
			return GetRuleContexts<ConcatenationExprContext>();
		}
		public ConcatenationExprContext concatenationExpr(int i) {
			return GetRuleContext<ConcatenationExprContext>(i);
		}
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public BetweenListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_betweenList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBetweenList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBetweenList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBetweenList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BetweenListContext betweenList() {
		BetweenListContext _localctx = new BetweenListContext(Context, State);
		EnterRule(_localctx, 354, RULE_betweenList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2552; concatenationExpr();
			State = 2553; Match(AND_EXPR);
			State = 2554; concatenationExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternExpressionContext : ParserRuleContext {
		public FollowedByExpressionContext followedByExpression() {
			return GetRuleContext<FollowedByExpressionContext>(0);
		}
		public PatternExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPatternExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPatternExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternExpressionContext patternExpression() {
		PatternExpressionContext _localctx = new PatternExpressionContext(Context, State);
		EnterRule(_localctx, 356, RULE_patternExpression);
		 paraphrases.Push("pattern expression"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2556; followedByExpression();
			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FollowedByExpressionContext : ParserRuleContext {
		public OrExpressionContext orExpression() {
			return GetRuleContext<OrExpressionContext>(0);
		}
		public FollowedByRepeatContext[] followedByRepeat() {
			return GetRuleContexts<FollowedByRepeatContext>();
		}
		public FollowedByRepeatContext followedByRepeat(int i) {
			return GetRuleContext<FollowedByRepeatContext>(i);
		}
		public FollowedByExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_followedByExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFollowedByExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFollowedByExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFollowedByExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FollowedByExpressionContext followedByExpression() {
		FollowedByExpressionContext _localctx = new FollowedByExpressionContext(Context, State);
		EnterRule(_localctx, 358, RULE_followedByExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2558; orExpression();
			State = 2562;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==FOLLOWMAX_BEGIN || _la==FOLLOWED_BY) {
				{
				{
				State = 2559; followedByRepeat();
				}
				}
				State = 2564;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FollowedByRepeatContext : ParserRuleContext {
		public IToken f;
		public IToken g;
		public OrExpressionContext orExpression() {
			return GetRuleContext<OrExpressionContext>(0);
		}
		public ITerminalNode FOLLOWED_BY() { return GetToken(EsperEPL2GrammarParser.FOLLOWED_BY, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode FOLLOWMAX_END() { return GetToken(EsperEPL2GrammarParser.FOLLOWMAX_END, 0); }
		public ITerminalNode FOLLOWMAX_BEGIN() { return GetToken(EsperEPL2GrammarParser.FOLLOWMAX_BEGIN, 0); }
		public FollowedByRepeatContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_followedByRepeat; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFollowedByRepeat(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFollowedByRepeat(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFollowedByRepeat(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FollowedByRepeatContext followedByRepeat() {
		FollowedByRepeatContext _localctx = new FollowedByRepeatContext(Context, State);
		EnterRule(_localctx, 360, RULE_followedByRepeat);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2570;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FOLLOWED_BY:
				{
				State = 2565; _localctx.f = Match(FOLLOWED_BY);
				}
				break;
			case FOLLOWMAX_BEGIN:
				{
				{
				State = 2566; _localctx.g = Match(FOLLOWMAX_BEGIN);
				State = 2567; expression();
				State = 2568; Match(FOLLOWMAX_END);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2572; orExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrExpressionContext : ParserRuleContext {
		public IToken o;
		public AndExpressionContext[] andExpression() {
			return GetRuleContexts<AndExpressionContext>();
		}
		public AndExpressionContext andExpression(int i) {
			return GetRuleContext<AndExpressionContext>(i);
		}
		public ITerminalNode[] OR_EXPR() { return GetTokens(EsperEPL2GrammarParser.OR_EXPR); }
		public ITerminalNode OR_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.OR_EXPR, i);
		}
		public OrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOrExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOrExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrExpressionContext orExpression() {
		OrExpressionContext _localctx = new OrExpressionContext(Context, State);
		EnterRule(_localctx, 362, RULE_orExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2574; andExpression();
			State = 2579;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR_EXPR) {
				{
				{
				State = 2575; _localctx.o = Match(OR_EXPR);
				State = 2576; andExpression();
				}
				}
				State = 2581;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AndExpressionContext : ParserRuleContext {
		public IToken a;
		public MatchUntilExpressionContext[] matchUntilExpression() {
			return GetRuleContexts<MatchUntilExpressionContext>();
		}
		public MatchUntilExpressionContext matchUntilExpression(int i) {
			return GetRuleContext<MatchUntilExpressionContext>(i);
		}
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public AndExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_andExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterAndExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitAndExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AndExpressionContext andExpression() {
		AndExpressionContext _localctx = new AndExpressionContext(Context, State);
		EnterRule(_localctx, 364, RULE_andExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2582; matchUntilExpression();
			State = 2587;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AND_EXPR) {
				{
				{
				State = 2583; _localctx.a = Match(AND_EXPR);
				State = 2584; matchUntilExpression();
				}
				}
				State = 2589;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchUntilExpressionContext : ParserRuleContext {
		public MatchUntilRangeContext r;
		public QualifyExpressionContext until;
		public QualifyExpressionContext[] qualifyExpression() {
			return GetRuleContexts<QualifyExpressionContext>();
		}
		public QualifyExpressionContext qualifyExpression(int i) {
			return GetRuleContext<QualifyExpressionContext>(i);
		}
		public ITerminalNode UNTIL() { return GetToken(EsperEPL2GrammarParser.UNTIL, 0); }
		public MatchUntilRangeContext matchUntilRange() {
			return GetRuleContext<MatchUntilRangeContext>(0);
		}
		public MatchUntilExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchUntilExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchUntilExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchUntilExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchUntilExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchUntilExpressionContext matchUntilExpression() {
		MatchUntilExpressionContext _localctx = new MatchUntilExpressionContext(Context, State);
		EnterRule(_localctx, 366, RULE_matchUntilExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2591;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LBRACK) {
				{
				State = 2590; _localctx.r = matchUntilRange();
				}
			}

			State = 2593; qualifyExpression();
			State = 2596;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNTIL) {
				{
				State = 2594; Match(UNTIL);
				State = 2595; _localctx.until = qualifyExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifyExpressionContext : ParserRuleContext {
		public IToken e;
		public IToken n;
		public IToken d;
		public GuardPostFixContext guardPostFix() {
			return GetRuleContext<GuardPostFixContext>(0);
		}
		public DistinctExpressionListContext distinctExpressionList() {
			return GetRuleContext<DistinctExpressionListContext>(0);
		}
		public ITerminalNode EVERY_EXPR() { return GetToken(EsperEPL2GrammarParser.EVERY_EXPR, 0); }
		public ITerminalNode NOT_EXPR() { return GetToken(EsperEPL2GrammarParser.NOT_EXPR, 0); }
		public ITerminalNode EVERY_DISTINCT_EXPR() { return GetToken(EsperEPL2GrammarParser.EVERY_DISTINCT_EXPR, 0); }
		public MatchUntilRangeContext matchUntilRange() {
			return GetRuleContext<MatchUntilRangeContext>(0);
		}
		public QualifyExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifyExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterQualifyExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitQualifyExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQualifyExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QualifyExpressionContext qualifyExpression() {
		QualifyExpressionContext _localctx = new QualifyExpressionContext(Context, State);
		EnterRule(_localctx, 368, RULE_qualifyExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2607;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << EVERY_DISTINCT_EXPR))) != 0)) {
				{
				State = 2602;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case EVERY_EXPR:
					{
					State = 2598; _localctx.e = Match(EVERY_EXPR);
					}
					break;
				case NOT_EXPR:
					{
					State = 2599; _localctx.n = Match(NOT_EXPR);
					}
					break;
				case EVERY_DISTINCT_EXPR:
					{
					State = 2600; _localctx.d = Match(EVERY_DISTINCT_EXPR);
					State = 2601; distinctExpressionList();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2605;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LBRACK) {
					{
					State = 2604; matchUntilRange();
					}
				}

				}
			}

			State = 2609; guardPostFix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GuardPostFixContext : ParserRuleContext {
		public IToken l;
		public IToken wh;
		public IToken wi;
		public AtomicExpressionContext atomicExpression() {
			return GetRuleContext<AtomicExpressionContext>(0);
		}
		public PatternExpressionContext patternExpression() {
			return GetRuleContext<PatternExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public GuardWhereExpressionContext guardWhereExpression() {
			return GetRuleContext<GuardWhereExpressionContext>(0);
		}
		public GuardWhileExpressionContext guardWhileExpression() {
			return GetRuleContext<GuardWhileExpressionContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public ITerminalNode WHILE() { return GetToken(EsperEPL2GrammarParser.WHILE, 0); }
		public GuardPostFixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_guardPostFix; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGuardPostFix(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGuardPostFix(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGuardPostFix(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GuardPostFixContext guardPostFix() {
		GuardPostFixContext _localctx = new GuardPostFixContext(Context, State);
		EnterRule(_localctx, 370, RULE_guardPostFix);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2616;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 2611; atomicExpression();
				}
				break;
			case LPAREN:
				{
				State = 2612; _localctx.l = Match(LPAREN);
				State = 2613; patternExpression();
				State = 2614; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2622;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WHERE:
				{
				{
				State = 2618; _localctx.wh = Match(WHERE);
				State = 2619; guardWhereExpression();
				}
				}
				break;
			case WHILE:
				{
				{
				State = 2620; _localctx.wi = Match(WHILE);
				State = 2621; guardWhileExpression();
				}
				}
				break;
			case Eof:
			case OR_EXPR:
			case AND_EXPR:
			case UNTIL:
			case FOLLOWMAX_BEGIN:
			case FOLLOWED_BY:
			case RPAREN:
			case RBRACK:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DistinctExpressionListContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public DistinctExpressionAtomContext[] distinctExpressionAtom() {
			return GetRuleContexts<DistinctExpressionAtomContext>();
		}
		public DistinctExpressionAtomContext distinctExpressionAtom(int i) {
			return GetRuleContext<DistinctExpressionAtomContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public DistinctExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_distinctExpressionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterDistinctExpressionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitDistinctExpressionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDistinctExpressionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DistinctExpressionListContext distinctExpressionList() {
		DistinctExpressionListContext _localctx = new DistinctExpressionListContext(Context, State);
		EnterRule(_localctx, 372, RULE_distinctExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2624; Match(LPAREN);
			State = 2625; distinctExpressionAtom();
			State = 2630;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2626; Match(COMMA);
				State = 2627; distinctExpressionAtom();
				}
				}
				State = 2632;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2633; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DistinctExpressionAtomContext : ParserRuleContext {
		public ExpressionWithTimeContext expressionWithTime() {
			return GetRuleContext<ExpressionWithTimeContext>(0);
		}
		public DistinctExpressionAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_distinctExpressionAtom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterDistinctExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitDistinctExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDistinctExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DistinctExpressionAtomContext distinctExpressionAtom() {
		DistinctExpressionAtomContext _localctx = new DistinctExpressionAtomContext(Context, State);
		EnterRule(_localctx, 374, RULE_distinctExpressionAtom);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2635; expressionWithTime();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomicExpressionContext : ParserRuleContext {
		public ObserverExpressionContext observerExpression() {
			return GetRuleContext<ObserverExpressionContext>(0);
		}
		public PatternFilterExpressionContext patternFilterExpression() {
			return GetRuleContext<PatternFilterExpressionContext>(0);
		}
		public AtomicExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atomicExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterAtomicExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitAtomicExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtomicExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomicExpressionContext atomicExpression() {
		AtomicExpressionContext _localctx = new AtomicExpressionContext(Context, State);
		EnterRule(_localctx, 376, RULE_atomicExpression);
		try {
			State = 2639;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,353,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2637; observerExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2638; patternFilterExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObserverExpressionContext : ParserRuleContext {
		public IToken ns;
		public IToken nm;
		public IToken a;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AT() { return GetToken(EsperEPL2GrammarParser.AT, 0); }
		public ExpressionListWithNamedWithTimeContext expressionListWithNamedWithTime() {
			return GetRuleContext<ExpressionListWithNamedWithTimeContext>(0);
		}
		public ObserverExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_observerExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterObserverExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitObserverExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObserverExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObserverExpressionContext observerExpression() {
		ObserverExpressionContext _localctx = new ObserverExpressionContext(Context, State);
		EnterRule(_localctx, 378, RULE_observerExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2641; _localctx.ns = Match(IDENT);
			State = 2642; Match(COLON);
			State = 2645;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENT:
				{
				State = 2643; _localctx.nm = Match(IDENT);
				}
				break;
			case AT:
				{
				State = 2644; _localctx.a = Match(AT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2647; Match(LPAREN);
			State = 2649;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LBRACK - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (STAR - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
				{
				State = 2648; expressionListWithNamedWithTime();
				}
			}

			State = 2651; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GuardWhereExpressionContext : ParserRuleContext {
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionWithTimeListContext expressionWithTimeList() {
			return GetRuleContext<ExpressionWithTimeListContext>(0);
		}
		public GuardWhereExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_guardWhereExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGuardWhereExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGuardWhereExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGuardWhereExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GuardWhereExpressionContext guardWhereExpression() {
		GuardWhereExpressionContext _localctx = new GuardWhereExpressionContext(Context, State);
		EnterRule(_localctx, 380, RULE_guardWhereExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2653; Match(IDENT);
			State = 2654; Match(COLON);
			State = 2655; Match(IDENT);
			State = 2656; Match(LPAREN);
			State = 2658;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LBRACK - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (STAR - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
				{
				State = 2657; expressionWithTimeList();
				}
			}

			State = 2660; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GuardWhileExpressionContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public GuardWhileExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_guardWhileExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGuardWhileExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGuardWhileExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGuardWhileExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GuardWhileExpressionContext guardWhileExpression() {
		GuardWhileExpressionContext _localctx = new GuardWhileExpressionContext(Context, State);
		EnterRule(_localctx, 382, RULE_guardWhileExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2662; Match(LPAREN);
			State = 2663; expression();
			State = 2664; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchUntilRangeContext : ParserRuleContext {
		public ExpressionContext low;
		public IToken c1;
		public ExpressionContext high;
		public IToken c2;
		public ExpressionContext upper;
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public MatchUntilRangeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchUntilRange; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchUntilRange(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchUntilRange(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchUntilRange(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchUntilRangeContext matchUntilRange() {
		MatchUntilRangeContext _localctx = new MatchUntilRangeContext(Context, State);
		EnterRule(_localctx, 384, RULE_matchUntilRange);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2666; Match(LBRACK);
			State = 2676;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WINDOW:
			case ESCAPE:
			case NOT_EXPR:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case CASE:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case ISTREAM:
			case SCHEMA:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PREVIOUSCOUNT:
			case PREVIOUSWINDOW:
			case PRIOR:
			case EXISTS:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case CURRENT_TIMESTAMP:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case NEWKW:
			case CONTEXT:
			case GROUPING:
			case GROUPING_ID:
			case QUESTION:
			case LPAREN:
			case LCURLY:
			case PLUS:
			case MINUS:
			case TICKED_STRING_LITERAL:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IDENT:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2667; _localctx.low = expression();
				State = 2672;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLON) {
					{
					State = 2668; _localctx.c1 = Match(COLON);
					State = 2670;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
						{
						State = 2669; _localctx.high = expression();
						}
					}

					}
				}

				}
				break;
			case COLON:
				{
				State = 2674; _localctx.c2 = Match(COLON);
				State = 2675; _localctx.upper = expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2678; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventFilterExpressionContext : ParserRuleContext {
		public IToken i;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public PropertyExpressionContext propertyExpression() {
			return GetRuleContext<PropertyExpressionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public EventFilterExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventFilterExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventFilterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventFilterExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventFilterExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventFilterExpressionContext eventFilterExpression() {
		EventFilterExpressionContext _localctx = new EventFilterExpressionContext(Context, State);
		EnterRule(_localctx, 386, RULE_eventFilterExpression);
		 paraphrases.Push("filter specification"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2682;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,360,Context) ) {
			case 1:
				{
				State = 2680; _localctx.i = Match(IDENT);
				State = 2681; Match(EQUALS);
				}
				break;
			}
			State = 2684; classIdentifier();
			State = 2690;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2685; Match(LPAREN);
				State = 2687;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 2686; expressionList();
					}
				}

				State = 2689; Match(RPAREN);
				}
			}

			State = 2693;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LBRACK) {
				{
				State = 2692; propertyExpression();
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyExpressionContext : ParserRuleContext {
		public PropertyExpressionAtomicContext[] propertyExpressionAtomic() {
			return GetRuleContexts<PropertyExpressionAtomicContext>();
		}
		public PropertyExpressionAtomicContext propertyExpressionAtomic(int i) {
			return GetRuleContext<PropertyExpressionAtomicContext>(i);
		}
		public PropertyExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertyExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertyExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyExpressionContext propertyExpression() {
		PropertyExpressionContext _localctx = new PropertyExpressionContext(Context, State);
		EnterRule(_localctx, 388, RULE_propertyExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2695; propertyExpressionAtomic();
			State = 2699;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==LBRACK) {
				{
				{
				State = 2696; propertyExpressionAtomic();
				}
				}
				State = 2701;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyExpressionAtomicContext : ParserRuleContext {
		public IToken n;
		public ExpressionContext where;
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public PropertyExpressionSelectContext propertyExpressionSelect() {
			return GetRuleContext<PropertyExpressionSelectContext>(0);
		}
		public TypeExpressionAnnotationContext typeExpressionAnnotation() {
			return GetRuleContext<TypeExpressionAnnotationContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public PropertyExpressionAtomicContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyExpressionAtomic; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertyExpressionAtomic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertyExpressionAtomic(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyExpressionAtomic(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyExpressionAtomicContext propertyExpressionAtomic() {
		PropertyExpressionAtomicContext _localctx = new PropertyExpressionAtomicContext(Context, State);
		EnterRule(_localctx, 390, RULE_propertyExpressionAtomic);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2702; Match(LBRACK);
			State = 2704;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SELECT) {
				{
				State = 2703; propertyExpressionSelect();
				}
			}

			State = 2706; expression();
			State = 2708;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ATCHAR) {
				{
				State = 2707; typeExpressionAnnotation();
				}
			}

			State = 2712;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2710; Match(AS);
				State = 2711; _localctx.n = Match(IDENT);
				}
			}

			State = 2716;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 2714; Match(WHERE);
				State = 2715; _localctx.where = expression();
				}
			}

			State = 2718; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyExpressionSelectContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public PropertySelectionListContext propertySelectionList() {
			return GetRuleContext<PropertySelectionListContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public PropertyExpressionSelectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyExpressionSelect; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertyExpressionSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertyExpressionSelect(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyExpressionSelect(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyExpressionSelectContext propertyExpressionSelect() {
		PropertyExpressionSelectContext _localctx = new PropertyExpressionSelectContext(Context, State);
		EnterRule(_localctx, 392, RULE_propertyExpressionSelect);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2720; Match(SELECT);
			State = 2721; propertySelectionList();
			State = 2722; Match(FROM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertySelectionListContext : ParserRuleContext {
		public PropertySelectionListElementContext[] propertySelectionListElement() {
			return GetRuleContexts<PropertySelectionListElementContext>();
		}
		public PropertySelectionListElementContext propertySelectionListElement(int i) {
			return GetRuleContext<PropertySelectionListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public PropertySelectionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertySelectionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertySelectionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertySelectionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertySelectionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertySelectionListContext propertySelectionList() {
		PropertySelectionListContext _localctx = new PropertySelectionListContext(Context, State);
		EnterRule(_localctx, 394, RULE_propertySelectionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2724; propertySelectionListElement();
			State = 2729;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2725; Match(COMMA);
				State = 2726; propertySelectionListElement();
				}
				}
				State = 2731;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertySelectionListElementContext : ParserRuleContext {
		public IToken s;
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public PropertyStreamSelectorContext propertyStreamSelector() {
			return GetRuleContext<PropertyStreamSelectorContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public KeywordAllowedIdentContext keywordAllowedIdent() {
			return GetRuleContext<KeywordAllowedIdentContext>(0);
		}
		public PropertySelectionListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertySelectionListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertySelectionListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertySelectionListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertySelectionListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertySelectionListElementContext propertySelectionListElement() {
		PropertySelectionListElementContext _localctx = new PropertySelectionListElementContext(Context, State);
		EnterRule(_localctx, 396, RULE_propertySelectionListElement);
		int _la;
		try {
			State = 2739;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,371,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2732; _localctx.s = Match(STAR);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2733; propertyStreamSelector();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2734; expression();
				State = 2737;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 2735; Match(AS);
					State = 2736; keywordAllowedIdent();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyStreamSelectorContext : ParserRuleContext {
		public IToken s;
		public IToken i;
		public ITerminalNode DOT() { return GetToken(EsperEPL2GrammarParser.DOT, 0); }
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public PropertyStreamSelectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyStreamSelector; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertyStreamSelector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertyStreamSelector(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyStreamSelector(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyStreamSelectorContext propertyStreamSelector() {
		PropertyStreamSelectorContext _localctx = new PropertyStreamSelectorContext(Context, State);
		EnterRule(_localctx, 398, RULE_propertyStreamSelector);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2741; _localctx.s = Match(IDENT);
			State = 2742; Match(DOT);
			State = 2743; Match(STAR);
			State = 2746;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2744; Match(AS);
				State = 2745; _localctx.i = Match(IDENT);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeExpressionAnnotationContext : ParserRuleContext {
		public IToken n;
		public IToken v;
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public TypeExpressionAnnotationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeExpressionAnnotation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterTypeExpressionAnnotation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitTypeExpressionAnnotation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeExpressionAnnotation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeExpressionAnnotationContext typeExpressionAnnotation() {
		TypeExpressionAnnotationContext _localctx = new TypeExpressionAnnotationContext(Context, State);
		EnterRule(_localctx, 400, RULE_typeExpressionAnnotation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2748; Match(ATCHAR);
			State = 2749; _localctx.n = Match(IDENT);
			{
			State = 2750; Match(LPAREN);
			State = 2751; _localctx.v = Match(IDENT);
			State = 2752; Match(RPAREN);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternFilterExpressionContext : ParserRuleContext {
		public IToken i;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public PropertyExpressionContext propertyExpression() {
			return GetRuleContext<PropertyExpressionContext>(0);
		}
		public PatternFilterAnnotationContext patternFilterAnnotation() {
			return GetRuleContext<PatternFilterAnnotationContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public PatternFilterExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternFilterExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPatternFilterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPatternFilterExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternFilterExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternFilterExpressionContext patternFilterExpression() {
		PatternFilterExpressionContext _localctx = new PatternFilterExpressionContext(Context, State);
		EnterRule(_localctx, 402, RULE_patternFilterExpression);
		 paraphrases.Push("filter specification"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2756;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,373,Context) ) {
			case 1:
				{
				State = 2754; _localctx.i = Match(IDENT);
				State = 2755; Match(EQUALS);
				}
				break;
			}
			State = 2758; classIdentifier();
			State = 2764;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2759; Match(LPAREN);
				State = 2761;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 2760; expressionList();
					}
				}

				State = 2763; Match(RPAREN);
				}
			}

			State = 2767;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LBRACK) {
				{
				State = 2766; propertyExpression();
				}
			}

			State = 2770;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ATCHAR) {
				{
				State = 2769; patternFilterAnnotation();
				}
			}

			}
			Context.Stop = TokenStream.LT(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternFilterAnnotationContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public PatternFilterAnnotationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternFilterAnnotation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPatternFilterAnnotation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPatternFilterAnnotation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternFilterAnnotation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternFilterAnnotationContext patternFilterAnnotation() {
		PatternFilterAnnotationContext _localctx = new PatternFilterAnnotationContext(Context, State);
		EnterRule(_localctx, 404, RULE_patternFilterAnnotation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2772; Match(ATCHAR);
			State = 2773; _localctx.i = Match(IDENT);
			State = 2778;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 2774; Match(LPAREN);
				State = 2775; number();
				State = 2776; Match(RPAREN);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClassIdentifierContext : ParserRuleContext {
		public EscapableStrContext i1;
		public EscapableStrContext i2;
		public EscapableStrContext[] escapableStr() {
			return GetRuleContexts<EscapableStrContext>();
		}
		public EscapableStrContext escapableStr(int i) {
			return GetRuleContext<EscapableStrContext>(i);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public ClassIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_classIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterClassIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitClassIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClassIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ClassIdentifierContext classIdentifier() {
		ClassIdentifierContext _localctx = new ClassIdentifierContext(Context, State);
		EnterRule(_localctx, 406, RULE_classIdentifier);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2780; _localctx.i1 = escapableStr();
			State = 2785;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,379,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2781; Match(DOT);
					State = 2782; _localctx.i2 = escapableStr();
					}
					} 
				}
				State = 2787;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,379,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SlashIdentifierContext : ParserRuleContext {
		public IToken d;
		public EscapableStrContext i1;
		public EscapableStrContext i2;
		public EscapableStrContext[] escapableStr() {
			return GetRuleContexts<EscapableStrContext>();
		}
		public EscapableStrContext escapableStr(int i) {
			return GetRuleContext<EscapableStrContext>(i);
		}
		public ITerminalNode[] DIV() { return GetTokens(EsperEPL2GrammarParser.DIV); }
		public ITerminalNode DIV(int i) {
			return GetToken(EsperEPL2GrammarParser.DIV, i);
		}
		public SlashIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_slashIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSlashIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSlashIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSlashIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SlashIdentifierContext slashIdentifier() {
		SlashIdentifierContext _localctx = new SlashIdentifierContext(Context, State);
		EnterRule(_localctx, 408, RULE_slashIdentifier);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2789;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DIV) {
				{
				State = 2788; _localctx.d = Match(DIV);
				}
			}

			State = 2791; _localctx.i1 = escapableStr();
			State = 2796;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,381,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2792; Match(DIV);
					State = 2793; _localctx.i2 = escapableStr();
					}
					} 
				}
				State = 2798;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,381,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListWithNamedContext : ParserRuleContext {
		public ExpressionWithNamedContext[] expressionWithNamed() {
			return GetRuleContexts<ExpressionWithNamedContext>();
		}
		public ExpressionWithNamedContext expressionWithNamed(int i) {
			return GetRuleContext<ExpressionWithNamedContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionListWithNamedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionListWithNamed; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionListWithNamed(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionListWithNamed(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionListWithNamed(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListWithNamedContext expressionListWithNamed() {
		ExpressionListWithNamedContext _localctx = new ExpressionListWithNamedContext(Context, State);
		EnterRule(_localctx, 410, RULE_expressionListWithNamed);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2799; expressionWithNamed();
			State = 2804;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2800; Match(COMMA);
				State = 2801; expressionWithNamed();
				}
				}
				State = 2806;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListWithNamedWithTimeContext : ParserRuleContext {
		public ExpressionWithNamedWithTimeContext[] expressionWithNamedWithTime() {
			return GetRuleContexts<ExpressionWithNamedWithTimeContext>();
		}
		public ExpressionWithNamedWithTimeContext expressionWithNamedWithTime(int i) {
			return GetRuleContext<ExpressionWithNamedWithTimeContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionListWithNamedWithTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionListWithNamedWithTime; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionListWithNamedWithTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionListWithNamedWithTime(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionListWithNamedWithTime(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListWithNamedWithTimeContext expressionListWithNamedWithTime() {
		ExpressionListWithNamedWithTimeContext _localctx = new ExpressionListWithNamedWithTimeContext(Context, State);
		EnterRule(_localctx, 412, RULE_expressionListWithNamedWithTime);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2807; expressionWithNamedWithTime();
			State = 2812;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2808; Match(COMMA);
				State = 2809; expressionWithNamedWithTime();
				}
				}
				State = 2814;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithNamedContext : ParserRuleContext {
		public ExpressionNamedParameterContext expressionNamedParameter() {
			return GetRuleContext<ExpressionNamedParameterContext>(0);
		}
		public ExpressionWithTimeContext expressionWithTime() {
			return GetRuleContext<ExpressionWithTimeContext>(0);
		}
		public ExpressionWithNamedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithNamed; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithNamed(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithNamed(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithNamed(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithNamedContext expressionWithNamed() {
		ExpressionWithNamedContext _localctx = new ExpressionWithNamedContext(Context, State);
		EnterRule(_localctx, 414, RULE_expressionWithNamed);
		try {
			State = 2817;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,384,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2815; expressionNamedParameter();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2816; expressionWithTime();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithNamedWithTimeContext : ParserRuleContext {
		public ExpressionNamedParameterWithTimeContext expressionNamedParameterWithTime() {
			return GetRuleContext<ExpressionNamedParameterWithTimeContext>(0);
		}
		public ExpressionWithTimeInclLastContext expressionWithTimeInclLast() {
			return GetRuleContext<ExpressionWithTimeInclLastContext>(0);
		}
		public ExpressionWithNamedWithTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithNamedWithTime; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithNamedWithTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithNamedWithTime(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithNamedWithTime(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithNamedWithTimeContext expressionWithNamedWithTime() {
		ExpressionWithNamedWithTimeContext _localctx = new ExpressionWithNamedWithTimeContext(Context, State);
		EnterRule(_localctx, 416, RULE_expressionWithNamedWithTime);
		try {
			State = 2821;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,385,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2819; expressionNamedParameterWithTime();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2820; expressionWithTimeInclLast();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionNamedParameterContext : ParserRuleContext {
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ExpressionNamedParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionNamedParameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionNamedParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionNamedParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionNamedParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionNamedParameterContext expressionNamedParameter() {
		ExpressionNamedParameterContext _localctx = new ExpressionNamedParameterContext(Context, State);
		EnterRule(_localctx, 418, RULE_expressionNamedParameter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2823; Match(IDENT);
			State = 2824; Match(COLON);
			State = 2831;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,387,Context) ) {
			case 1:
				{
				State = 2825; expression();
				}
				break;
			case 2:
				{
				State = 2826; Match(LPAREN);
				State = 2828;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 2827; expressionList();
					}
				}

				State = 2830; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionNamedParameterWithTimeContext : ParserRuleContext {
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ExpressionWithTimeContext expressionWithTime() {
			return GetRuleContext<ExpressionWithTimeContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionWithTimeListContext expressionWithTimeList() {
			return GetRuleContext<ExpressionWithTimeListContext>(0);
		}
		public ExpressionNamedParameterWithTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionNamedParameterWithTime; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionNamedParameterWithTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionNamedParameterWithTime(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionNamedParameterWithTime(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionNamedParameterWithTimeContext expressionNamedParameterWithTime() {
		ExpressionNamedParameterWithTimeContext _localctx = new ExpressionNamedParameterWithTimeContext(Context, State);
		EnterRule(_localctx, 420, RULE_expressionNamedParameterWithTime);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2833; Match(IDENT);
			State = 2834; Match(COLON);
			State = 2841;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,389,Context) ) {
			case 1:
				{
				State = 2835; expressionWithTime();
				}
				break;
			case 2:
				{
				State = 2836; Match(LPAREN);
				State = 2838;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 2)) & ~0x3f) == 0 && ((1L << (_la - 2)) & ((1L << (WINDOW - 2)) | (1L << (ESCAPE - 2)) | (1L << (NOT_EXPR - 2)) | (1L << (EVERY_EXPR - 2)) | (1L << (SUM - 2)) | (1L << (AVG - 2)) | (1L << (MAX - 2)) | (1L << (MIN - 2)) | (1L << (COALESCE - 2)) | (1L << (MEDIAN - 2)) | (1L << (STDDEV - 2)) | (1L << (AVEDEV - 2)) | (1L << (COUNT - 2)) | (1L << (CASE - 2)) | (1L << (OUTER - 2)) | (1L << (JOIN - 2)) | (1L << (LEFT - 2)) | (1L << (RIGHT - 2)) | (1L << (FULL - 2)) | (1L << (EVENTS - 2)) | (1L << (FIRST - 2)) | (1L << (LAST - 2)) | (1L << (ISTREAM - 2)) | (1L << (SCHEMA - 2)) | (1L << (UNIDIRECTIONAL - 2)) | (1L << (RETAINUNION - 2)) | (1L << (RETAININTERSECTION - 2)) | (1L << (PATTERN - 2)) | (1L << (SQL - 2)) | (1L << (METADATASQL - 2)))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (PREVIOUS - 66)) | (1L << (PREVIOUSTAIL - 66)) | (1L << (PREVIOUSCOUNT - 66)) | (1L << (PREVIOUSWINDOW - 66)) | (1L << (PRIOR - 66)) | (1L << (EXISTS - 66)) | (1L << (WEEKDAY - 66)) | (1L << (LW - 66)) | (1L << (INSTANCEOF - 66)) | (1L << (TYPEOF - 66)) | (1L << (CAST - 66)) | (1L << (CURRENT_TIMESTAMP - 66)) | (1L << (SNAPSHOT - 66)) | (1L << (VARIABLE - 66)) | (1L << (TABLE - 66)) | (1L << (UNTIL - 66)) | (1L << (AT - 66)) | (1L << (INDEX - 66)) | (1L << (BOOLEAN_TRUE - 66)) | (1L << (BOOLEAN_FALSE - 66)) | (1L << (VALUE_NULL - 66)) | (1L << (DEFINE - 66)) | (1L << (PARTITION - 66)) | (1L << (MATCHES - 66)) | (1L << (FOR - 66)) | (1L << (WHILE - 66)) | (1L << (USING - 66)) | (1L << (MERGE - 66)) | (1L << (MATCHED - 66)) | (1L << (NEWKW - 66)) | (1L << (CONTEXT - 66)))) != 0) || ((((_la - 134)) & ~0x3f) == 0 && ((1L << (_la - 134)) & ((1L << (GROUPING - 134)) | (1L << (GROUPING_ID - 134)) | (1L << (QUESTION - 134)) | (1L << (LPAREN - 134)) | (1L << (LBRACK - 134)) | (1L << (LCURLY - 134)) | (1L << (PLUS - 134)) | (1L << (MINUS - 134)) | (1L << (STAR - 134)) | (1L << (TICKED_STRING_LITERAL - 134)) | (1L << (QUOTED_STRING_LITERAL - 134)) | (1L << (STRING_LITERAL - 134)) | (1L << (IDENT - 134)) | (1L << (IntegerLiteral - 134)) | (1L << (FloatingPointLiteral - 134)))) != 0)) {
					{
					State = 2837; expressionWithTimeList();
					}
				}

				State = 2840; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListContext expressionList() {
		ExpressionListContext _localctx = new ExpressionListContext(Context, State);
		EnterRule(_localctx, 422, RULE_expressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2843; expression();
			State = 2848;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2844; Match(COMMA);
				State = 2845; expression();
				}
				}
				State = 2850;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithTimeListContext : ParserRuleContext {
		public ExpressionWithTimeInclLastContext[] expressionWithTimeInclLast() {
			return GetRuleContexts<ExpressionWithTimeInclLastContext>();
		}
		public ExpressionWithTimeInclLastContext expressionWithTimeInclLast(int i) {
			return GetRuleContext<ExpressionWithTimeInclLastContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionWithTimeListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithTimeList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithTimeList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithTimeList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithTimeList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithTimeListContext expressionWithTimeList() {
		ExpressionWithTimeListContext _localctx = new ExpressionWithTimeListContext(Context, State);
		EnterRule(_localctx, 424, RULE_expressionWithTimeList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2851; expressionWithTimeInclLast();
			State = 2856;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2852; Match(COMMA);
				State = 2853; expressionWithTimeInclLast();
				}
				}
				State = 2858;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithTimeContext : ParserRuleContext {
		public LastWeekdayOperandContext lastWeekdayOperand() {
			return GetRuleContext<LastWeekdayOperandContext>(0);
		}
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public ExpressionQualifyableContext expressionQualifyable() {
			return GetRuleContext<ExpressionQualifyableContext>(0);
		}
		public RangeOperandContext rangeOperand() {
			return GetRuleContext<RangeOperandContext>(0);
		}
		public FrequencyOperandContext frequencyOperand() {
			return GetRuleContext<FrequencyOperandContext>(0);
		}
		public LastOperatorContext lastOperator() {
			return GetRuleContext<LastOperatorContext>(0);
		}
		public WeekDayOperatorContext weekDayOperator() {
			return GetRuleContext<WeekDayOperatorContext>(0);
		}
		public NumericParameterListContext numericParameterList() {
			return GetRuleContext<NumericParameterListContext>(0);
		}
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public PropertyStreamSelectorContext propertyStreamSelector() {
			return GetRuleContext<PropertyStreamSelectorContext>(0);
		}
		public ExpressionWithTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithTime; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithTime(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithTime(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithTimeContext expressionWithTime() {
		ExpressionWithTimeContext _localctx = new ExpressionWithTimeContext(Context, State);
		EnterRule(_localctx, 426, RULE_expressionWithTime);
		try {
			State = 2869;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,392,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2859; lastWeekdayOperand();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2860; timePeriod();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2861; expressionQualifyable();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2862; rangeOperand();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2863; frequencyOperand();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2864; lastOperator();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2865; weekDayOperator();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2866; numericParameterList();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2867; Match(STAR);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2868; propertyStreamSelector();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithTimeInclLastContext : ParserRuleContext {
		public LastOperandContext lastOperand() {
			return GetRuleContext<LastOperandContext>(0);
		}
		public ExpressionWithTimeContext expressionWithTime() {
			return GetRuleContext<ExpressionWithTimeContext>(0);
		}
		public ExpressionWithTimeInclLastContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithTimeInclLast; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithTimeInclLast(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithTimeInclLast(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithTimeInclLast(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithTimeInclLastContext expressionWithTimeInclLast() {
		ExpressionWithTimeInclLastContext _localctx = new ExpressionWithTimeInclLastContext(Context, State);
		EnterRule(_localctx, 428, RULE_expressionWithTimeInclLast);
		try {
			State = 2873;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,393,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2871; lastOperand();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2872; expressionWithTime();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionQualifyableContext : ParserRuleContext {
		public IToken a;
		public IToken d;
		public IToken s;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(EsperEPL2GrammarParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(EsperEPL2GrammarParser.DESC, 0); }
		public ITerminalNode TIMEPERIOD_SECONDS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SECONDS, 0); }
		public ITerminalNode TIMEPERIOD_SECOND() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SECOND, 0); }
		public ITerminalNode TIMEPERIOD_SEC() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SEC, 0); }
		public ExpressionQualifyableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionQualifyable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionQualifyable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionQualifyable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionQualifyable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionQualifyableContext expressionQualifyable() {
		ExpressionQualifyableContext _localctx = new ExpressionQualifyableContext(Context, State);
		EnterRule(_localctx, 430, RULE_expressionQualifyable);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2875; expression();
			State = 2881;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ASC:
				{
				State = 2876; _localctx.a = Match(ASC);
				}
				break;
			case DESC:
				{
				State = 2877; _localctx.d = Match(DESC);
				}
				break;
			case TIMEPERIOD_SECONDS:
				{
				State = 2878; _localctx.s = Match(TIMEPERIOD_SECONDS);
				}
				break;
			case TIMEPERIOD_SECOND:
				{
				State = 2879; _localctx.s = Match(TIMEPERIOD_SECOND);
				}
				break;
			case TIMEPERIOD_SEC:
				{
				State = 2880; _localctx.s = Match(TIMEPERIOD_SEC);
				}
				break;
			case RPAREN:
			case COMMA:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LastWeekdayOperandContext : ParserRuleContext {
		public ITerminalNode LW() { return GetToken(EsperEPL2GrammarParser.LW, 0); }
		public LastWeekdayOperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lastWeekdayOperand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLastWeekdayOperand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLastWeekdayOperand(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLastWeekdayOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LastWeekdayOperandContext lastWeekdayOperand() {
		LastWeekdayOperandContext _localctx = new LastWeekdayOperandContext(Context, State);
		EnterRule(_localctx, 432, RULE_lastWeekdayOperand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2883; Match(LW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LastOperandContext : ParserRuleContext {
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public LastOperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lastOperand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLastOperand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLastOperand(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLastOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LastOperandContext lastOperand() {
		LastOperandContext _localctx = new LastOperandContext(Context, State);
		EnterRule(_localctx, 434, RULE_lastOperand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2885; Match(LAST);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FrequencyOperandContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode DIV() { return GetToken(EsperEPL2GrammarParser.DIV, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public FrequencyOperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_frequencyOperand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFrequencyOperand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFrequencyOperand(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrequencyOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FrequencyOperandContext frequencyOperand() {
		FrequencyOperandContext _localctx = new FrequencyOperandContext(Context, State);
		EnterRule(_localctx, 436, RULE_frequencyOperand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2887; Match(STAR);
			State = 2888; Match(DIV);
			State = 2892;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2889; number();
				}
				break;
			case IDENT:
				{
				State = 2890; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2891; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeOperandContext : ParserRuleContext {
		public NumberContext n1;
		public IToken i1;
		public SubstitutionContext s1;
		public NumberContext n2;
		public IToken i2;
		public SubstitutionContext s2;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public NumberContext[] number() {
			return GetRuleContexts<NumberContext>();
		}
		public NumberContext number(int i) {
			return GetRuleContext<NumberContext>(i);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public SubstitutionContext[] substitution() {
			return GetRuleContexts<SubstitutionContext>();
		}
		public SubstitutionContext substitution(int i) {
			return GetRuleContext<SubstitutionContext>(i);
		}
		public RangeOperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rangeOperand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterRangeOperand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitRangeOperand(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRangeOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RangeOperandContext rangeOperand() {
		RangeOperandContext _localctx = new RangeOperandContext(Context, State);
		EnterRule(_localctx, 438, RULE_rangeOperand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2897;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2894; _localctx.n1 = number();
				}
				break;
			case IDENT:
				{
				State = 2895; _localctx.i1 = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2896; _localctx.s1 = substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2899; Match(COLON);
			State = 2903;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2900; _localctx.n2 = number();
				}
				break;
			case IDENT:
				{
				State = 2901; _localctx.i2 = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2902; _localctx.s2 = substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LastOperatorContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public LastOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lastOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLastOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLastOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLastOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LastOperatorContext lastOperator() {
		LastOperatorContext _localctx = new LastOperatorContext(Context, State);
		EnterRule(_localctx, 440, RULE_lastOperator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2908;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2905; number();
				}
				break;
			case IDENT:
				{
				State = 2906; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2907; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2910; Match(LAST);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WeekDayOperatorContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode WEEKDAY() { return GetToken(EsperEPL2GrammarParser.WEEKDAY, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public WeekDayOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_weekDayOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterWeekDayOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitWeekDayOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWeekDayOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WeekDayOperatorContext weekDayOperator() {
		WeekDayOperatorContext _localctx = new WeekDayOperatorContext(Context, State);
		EnterRule(_localctx, 442, RULE_weekDayOperator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2915;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2912; number();
				}
				break;
			case IDENT:
				{
				State = 2913; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2914; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2917; Match(WEEKDAY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericParameterListContext : ParserRuleContext {
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public NumericListParameterContext[] numericListParameter() {
			return GetRuleContexts<NumericListParameterContext>();
		}
		public NumericListParameterContext numericListParameter(int i) {
			return GetRuleContext<NumericListParameterContext>(i);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public NumericParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numericParameterList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNumericParameterList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNumericParameterList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumericParameterList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericParameterListContext numericParameterList() {
		NumericParameterListContext _localctx = new NumericParameterListContext(Context, State);
		EnterRule(_localctx, 444, RULE_numericParameterList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2919; Match(LBRACK);
			State = 2920; numericListParameter();
			State = 2925;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2921; Match(COMMA);
				State = 2922; numericListParameter();
				}
				}
				State = 2927;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2928; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericListParameterContext : ParserRuleContext {
		public RangeOperandContext rangeOperand() {
			return GetRuleContext<RangeOperandContext>(0);
		}
		public FrequencyOperandContext frequencyOperand() {
			return GetRuleContext<FrequencyOperandContext>(0);
		}
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public NumericListParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numericListParameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNumericListParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNumericListParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumericListParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericListParameterContext numericListParameter() {
		NumericListParameterContext _localctx = new NumericListParameterContext(Context, State);
		EnterRule(_localctx, 446, RULE_numericListParameter);
		try {
			State = 2933;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,401,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2930; rangeOperand();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2931; frequencyOperand();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2932; numberconstant();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventPropertyContext : ParserRuleContext {
		public EventPropertyAtomicContext[] eventPropertyAtomic() {
			return GetRuleContexts<EventPropertyAtomicContext>();
		}
		public EventPropertyAtomicContext eventPropertyAtomic(int i) {
			return GetRuleContext<EventPropertyAtomicContext>(i);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public EventPropertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventProperty; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventProperty(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventProperty(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventProperty(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventPropertyContext eventProperty() {
		EventPropertyContext _localctx = new EventPropertyContext(Context, State);
		EnterRule(_localctx, 448, RULE_eventProperty);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2935; eventPropertyAtomic();
			State = 2940;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DOT) {
				{
				{
				State = 2936; Match(DOT);
				State = 2937; eventPropertyAtomic();
				}
				}
				State = 2942;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventPropertyAtomicContext : ParserRuleContext {
		public IToken lb;
		public NumberContext ni;
		public IToken q;
		public IToken lp;
		public IToken s;
		public IToken q1;
		public EventPropertyIdentContext eventPropertyIdent() {
			return GetRuleContext<EventPropertyIdentContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode QUESTION() { return GetToken(EsperEPL2GrammarParser.QUESTION, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.STRING_LITERAL, 0); }
		public ITerminalNode QUOTED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.QUOTED_STRING_LITERAL, 0); }
		public EventPropertyAtomicContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventPropertyAtomic; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventPropertyAtomic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventPropertyAtomic(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventPropertyAtomic(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventPropertyAtomicContext eventPropertyAtomic() {
		EventPropertyAtomicContext _localctx = new EventPropertyAtomicContext(Context, State);
		EnterRule(_localctx, 450, RULE_eventPropertyAtomic);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2943; eventPropertyIdent();
			State = 2960;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,406,Context) ) {
			case 1:
				{
				State = 2944; _localctx.lb = Match(LBRACK);
				State = 2945; _localctx.ni = number();
				State = 2946; Match(RBRACK);
				State = 2948;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,403,Context) ) {
				case 1:
					{
					State = 2947; _localctx.q = Match(QUESTION);
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 2950; _localctx.lp = Match(LPAREN);
				State = 2953;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case STRING_LITERAL:
					{
					State = 2951; _localctx.s = Match(STRING_LITERAL);
					}
					break;
				case QUOTED_STRING_LITERAL:
					{
					State = 2952; _localctx.s = Match(QUOTED_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2955; Match(RPAREN);
				State = 2957;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,405,Context) ) {
				case 1:
					{
					State = 2956; _localctx.q = Match(QUESTION);
					}
					break;
				}
				}
				break;
			case 3:
				{
				State = 2959; _localctx.q1 = Match(QUESTION);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventPropertyIdentContext : ParserRuleContext {
		public KeywordAllowedIdentContext ipi;
		public KeywordAllowedIdentContext ipi2;
		public KeywordAllowedIdentContext[] keywordAllowedIdent() {
			return GetRuleContexts<KeywordAllowedIdentContext>();
		}
		public KeywordAllowedIdentContext keywordAllowedIdent(int i) {
			return GetRuleContext<KeywordAllowedIdentContext>(i);
		}
		public ITerminalNode[] ESCAPECHAR() { return GetTokens(EsperEPL2GrammarParser.ESCAPECHAR); }
		public ITerminalNode ESCAPECHAR(int i) {
			return GetToken(EsperEPL2GrammarParser.ESCAPECHAR, i);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public EventPropertyIdentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventPropertyIdent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventPropertyIdent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventPropertyIdent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventPropertyIdent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventPropertyIdentContext eventPropertyIdent() {
		EventPropertyIdentContext _localctx = new EventPropertyIdentContext(Context, State);
		EnterRule(_localctx, 452, RULE_eventPropertyIdent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2962; _localctx.ipi = keywordAllowedIdent();
			State = 2970;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ESCAPECHAR) {
				{
				{
				State = 2963; Match(ESCAPECHAR);
				State = 2964; Match(DOT);
				State = 2966;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,407,Context) ) {
				case 1:
					{
					State = 2965; _localctx.ipi2 = keywordAllowedIdent();
					}
					break;
				}
				}
				}
				State = 2972;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordAllowedIdentContext : ParserRuleContext {
		public IToken i1;
		public IToken i2;
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode TICKED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.TICKED_STRING_LITERAL, 0); }
		public ITerminalNode AT() { return GetToken(EsperEPL2GrammarParser.AT, 0); }
		public ITerminalNode COUNT() { return GetToken(EsperEPL2GrammarParser.COUNT, 0); }
		public ITerminalNode ESCAPE() { return GetToken(EsperEPL2GrammarParser.ESCAPE, 0); }
		public ITerminalNode EVERY_EXPR() { return GetToken(EsperEPL2GrammarParser.EVERY_EXPR, 0); }
		public ITerminalNode SCHEMA() { return GetToken(EsperEPL2GrammarParser.SCHEMA, 0); }
		public ITerminalNode SUM() { return GetToken(EsperEPL2GrammarParser.SUM, 0); }
		public ITerminalNode AVG() { return GetToken(EsperEPL2GrammarParser.AVG, 0); }
		public ITerminalNode MAX() { return GetToken(EsperEPL2GrammarParser.MAX, 0); }
		public ITerminalNode MIN() { return GetToken(EsperEPL2GrammarParser.MIN, 0); }
		public ITerminalNode COALESCE() { return GetToken(EsperEPL2GrammarParser.COALESCE, 0); }
		public ITerminalNode MEDIAN() { return GetToken(EsperEPL2GrammarParser.MEDIAN, 0); }
		public ITerminalNode STDDEV() { return GetToken(EsperEPL2GrammarParser.STDDEV, 0); }
		public ITerminalNode AVEDEV() { return GetToken(EsperEPL2GrammarParser.AVEDEV, 0); }
		public ITerminalNode EVENTS() { return GetToken(EsperEPL2GrammarParser.EVENTS, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode WHILE() { return GetToken(EsperEPL2GrammarParser.WHILE, 0); }
		public ITerminalNode MERGE() { return GetToken(EsperEPL2GrammarParser.MERGE, 0); }
		public ITerminalNode MATCHED() { return GetToken(EsperEPL2GrammarParser.MATCHED, 0); }
		public ITerminalNode UNIDIRECTIONAL() { return GetToken(EsperEPL2GrammarParser.UNIDIRECTIONAL, 0); }
		public ITerminalNode RETAINUNION() { return GetToken(EsperEPL2GrammarParser.RETAINUNION, 0); }
		public ITerminalNode RETAININTERSECTION() { return GetToken(EsperEPL2GrammarParser.RETAININTERSECTION, 0); }
		public ITerminalNode UNTIL() { return GetToken(EsperEPL2GrammarParser.UNTIL, 0); }
		public ITerminalNode PATTERN() { return GetToken(EsperEPL2GrammarParser.PATTERN, 0); }
		public ITerminalNode SQL() { return GetToken(EsperEPL2GrammarParser.SQL, 0); }
		public ITerminalNode METADATASQL() { return GetToken(EsperEPL2GrammarParser.METADATASQL, 0); }
		public ITerminalNode PREVIOUS() { return GetToken(EsperEPL2GrammarParser.PREVIOUS, 0); }
		public ITerminalNode PREVIOUSTAIL() { return GetToken(EsperEPL2GrammarParser.PREVIOUSTAIL, 0); }
		public ITerminalNode PRIOR() { return GetToken(EsperEPL2GrammarParser.PRIOR, 0); }
		public ITerminalNode WEEKDAY() { return GetToken(EsperEPL2GrammarParser.WEEKDAY, 0); }
		public ITerminalNode LW() { return GetToken(EsperEPL2GrammarParser.LW, 0); }
		public ITerminalNode INSTANCEOF() { return GetToken(EsperEPL2GrammarParser.INSTANCEOF, 0); }
		public ITerminalNode TYPEOF() { return GetToken(EsperEPL2GrammarParser.TYPEOF, 0); }
		public ITerminalNode CAST() { return GetToken(EsperEPL2GrammarParser.CAST, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(EsperEPL2GrammarParser.SNAPSHOT, 0); }
		public ITerminalNode VARIABLE() { return GetToken(EsperEPL2GrammarParser.VARIABLE, 0); }
		public ITerminalNode TABLE() { return GetToken(EsperEPL2GrammarParser.TABLE, 0); }
		public ITerminalNode INDEX() { return GetToken(EsperEPL2GrammarParser.INDEX, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public ITerminalNode LEFT() { return GetToken(EsperEPL2GrammarParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(EsperEPL2GrammarParser.RIGHT, 0); }
		public ITerminalNode OUTER() { return GetToken(EsperEPL2GrammarParser.OUTER, 0); }
		public ITerminalNode FULL() { return GetToken(EsperEPL2GrammarParser.FULL, 0); }
		public ITerminalNode JOIN() { return GetToken(EsperEPL2GrammarParser.JOIN, 0); }
		public ITerminalNode DEFINE() { return GetToken(EsperEPL2GrammarParser.DEFINE, 0); }
		public ITerminalNode PARTITION() { return GetToken(EsperEPL2GrammarParser.PARTITION, 0); }
		public ITerminalNode MATCHES() { return GetToken(EsperEPL2GrammarParser.MATCHES, 0); }
		public ITerminalNode CONTEXT() { return GetToken(EsperEPL2GrammarParser.CONTEXT, 0); }
		public ITerminalNode FOR() { return GetToken(EsperEPL2GrammarParser.FOR, 0); }
		public ITerminalNode USING() { return GetToken(EsperEPL2GrammarParser.USING, 0); }
		public KeywordAllowedIdentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keywordAllowedIdent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterKeywordAllowedIdent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitKeywordAllowedIdent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeywordAllowedIdent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordAllowedIdentContext keywordAllowedIdent() {
		KeywordAllowedIdentContext _localctx = new KeywordAllowedIdentContext(Context, State);
		EnterRule(_localctx, 454, RULE_keywordAllowedIdent);
		try {
			State = 3025;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2973; _localctx.i1 = Match(IDENT);
				}
				break;
			case TICKED_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2974; _localctx.i2 = Match(TICKED_STRING_LITERAL);
				}
				break;
			case AT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2975; Match(AT);
				}
				break;
			case COUNT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2976; Match(COUNT);
				}
				break;
			case ESCAPE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2977; Match(ESCAPE);
				}
				break;
			case EVERY_EXPR:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2978; Match(EVERY_EXPR);
				}
				break;
			case SCHEMA:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2979; Match(SCHEMA);
				}
				break;
			case SUM:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2980; Match(SUM);
				}
				break;
			case AVG:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2981; Match(AVG);
				}
				break;
			case MAX:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2982; Match(MAX);
				}
				break;
			case MIN:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2983; Match(MIN);
				}
				break;
			case COALESCE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2984; Match(COALESCE);
				}
				break;
			case MEDIAN:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2985; Match(MEDIAN);
				}
				break;
			case STDDEV:
				EnterOuterAlt(_localctx, 14);
				{
				State = 2986; Match(STDDEV);
				}
				break;
			case AVEDEV:
				EnterOuterAlt(_localctx, 15);
				{
				State = 2987; Match(AVEDEV);
				}
				break;
			case EVENTS:
				EnterOuterAlt(_localctx, 16);
				{
				State = 2988; Match(EVENTS);
				}
				break;
			case FIRST:
				EnterOuterAlt(_localctx, 17);
				{
				State = 2989; Match(FIRST);
				}
				break;
			case LAST:
				EnterOuterAlt(_localctx, 18);
				{
				State = 2990; Match(LAST);
				}
				break;
			case WHILE:
				EnterOuterAlt(_localctx, 19);
				{
				State = 2991; Match(WHILE);
				}
				break;
			case MERGE:
				EnterOuterAlt(_localctx, 20);
				{
				State = 2992; Match(MERGE);
				}
				break;
			case MATCHED:
				EnterOuterAlt(_localctx, 21);
				{
				State = 2993; Match(MATCHED);
				}
				break;
			case UNIDIRECTIONAL:
				EnterOuterAlt(_localctx, 22);
				{
				State = 2994; Match(UNIDIRECTIONAL);
				}
				break;
			case RETAINUNION:
				EnterOuterAlt(_localctx, 23);
				{
				State = 2995; Match(RETAINUNION);
				}
				break;
			case RETAININTERSECTION:
				EnterOuterAlt(_localctx, 24);
				{
				State = 2996; Match(RETAININTERSECTION);
				}
				break;
			case UNTIL:
				EnterOuterAlt(_localctx, 25);
				{
				State = 2997; Match(UNTIL);
				}
				break;
			case PATTERN:
				EnterOuterAlt(_localctx, 26);
				{
				State = 2998; Match(PATTERN);
				}
				break;
			case SQL:
				EnterOuterAlt(_localctx, 27);
				{
				State = 2999; Match(SQL);
				}
				break;
			case METADATASQL:
				EnterOuterAlt(_localctx, 28);
				{
				State = 3000; Match(METADATASQL);
				}
				break;
			case PREVIOUS:
				EnterOuterAlt(_localctx, 29);
				{
				State = 3001; Match(PREVIOUS);
				}
				break;
			case PREVIOUSTAIL:
				EnterOuterAlt(_localctx, 30);
				{
				State = 3002; Match(PREVIOUSTAIL);
				}
				break;
			case PRIOR:
				EnterOuterAlt(_localctx, 31);
				{
				State = 3003; Match(PRIOR);
				}
				break;
			case WEEKDAY:
				EnterOuterAlt(_localctx, 32);
				{
				State = 3004; Match(WEEKDAY);
				}
				break;
			case LW:
				EnterOuterAlt(_localctx, 33);
				{
				State = 3005; Match(LW);
				}
				break;
			case INSTANCEOF:
				EnterOuterAlt(_localctx, 34);
				{
				State = 3006; Match(INSTANCEOF);
				}
				break;
			case TYPEOF:
				EnterOuterAlt(_localctx, 35);
				{
				State = 3007; Match(TYPEOF);
				}
				break;
			case CAST:
				EnterOuterAlt(_localctx, 36);
				{
				State = 3008; Match(CAST);
				}
				break;
			case SNAPSHOT:
				EnterOuterAlt(_localctx, 37);
				{
				State = 3009; Match(SNAPSHOT);
				}
				break;
			case VARIABLE:
				EnterOuterAlt(_localctx, 38);
				{
				State = 3010; Match(VARIABLE);
				}
				break;
			case TABLE:
				EnterOuterAlt(_localctx, 39);
				{
				State = 3011; Match(TABLE);
				}
				break;
			case INDEX:
				EnterOuterAlt(_localctx, 40);
				{
				State = 3012; Match(INDEX);
				}
				break;
			case WINDOW:
				EnterOuterAlt(_localctx, 41);
				{
				State = 3013; Match(WINDOW);
				}
				break;
			case LEFT:
				EnterOuterAlt(_localctx, 42);
				{
				State = 3014; Match(LEFT);
				}
				break;
			case RIGHT:
				EnterOuterAlt(_localctx, 43);
				{
				State = 3015; Match(RIGHT);
				}
				break;
			case OUTER:
				EnterOuterAlt(_localctx, 44);
				{
				State = 3016; Match(OUTER);
				}
				break;
			case FULL:
				EnterOuterAlt(_localctx, 45);
				{
				State = 3017; Match(FULL);
				}
				break;
			case JOIN:
				EnterOuterAlt(_localctx, 46);
				{
				State = 3018; Match(JOIN);
				}
				break;
			case DEFINE:
				EnterOuterAlt(_localctx, 47);
				{
				State = 3019; Match(DEFINE);
				}
				break;
			case PARTITION:
				EnterOuterAlt(_localctx, 48);
				{
				State = 3020; Match(PARTITION);
				}
				break;
			case MATCHES:
				EnterOuterAlt(_localctx, 49);
				{
				State = 3021; Match(MATCHES);
				}
				break;
			case CONTEXT:
				EnterOuterAlt(_localctx, 50);
				{
				State = 3022; Match(CONTEXT);
				}
				break;
			case FOR:
				EnterOuterAlt(_localctx, 51);
				{
				State = 3023; Match(FOR);
				}
				break;
			case USING:
				EnterOuterAlt(_localctx, 52);
				{
				State = 3024; Match(USING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EscapableStrContext : ParserRuleContext {
		public IToken i1;
		public IToken i2;
		public IToken i3;
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode EVENTS() { return GetToken(EsperEPL2GrammarParser.EVENTS, 0); }
		public ITerminalNode TICKED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.TICKED_STRING_LITERAL, 0); }
		public EscapableStrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_escapableStr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEscapableStr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEscapableStr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEscapableStr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EscapableStrContext escapableStr() {
		EscapableStrContext _localctx = new EscapableStrContext(Context, State);
		EnterRule(_localctx, 456, RULE_escapableStr);
		try {
			State = 3030;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3027; _localctx.i1 = Match(IDENT);
				}
				break;
			case EVENTS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3028; _localctx.i2 = Match(EVENTS);
				}
				break;
			case TICKED_STRING_LITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3029; _localctx.i3 = Match(TICKED_STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EscapableIdentContext : ParserRuleContext {
		public IToken t;
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode TICKED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.TICKED_STRING_LITERAL, 0); }
		public EscapableIdentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_escapableIdent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEscapableIdent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEscapableIdent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEscapableIdent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EscapableIdentContext escapableIdent() {
		EscapableIdentContext _localctx = new EscapableIdentContext(Context, State);
		EnterRule(_localctx, 458, RULE_escapableIdent);
		try {
			State = 3034;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3032; Match(IDENT);
				}
				break;
			case TICKED_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3033; _localctx.t = Match(TICKED_STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimePeriodContext : ParserRuleContext {
		public YearPartContext yearPart() {
			return GetRuleContext<YearPartContext>(0);
		}
		public MonthPartContext monthPart() {
			return GetRuleContext<MonthPartContext>(0);
		}
		public WeekPartContext weekPart() {
			return GetRuleContext<WeekPartContext>(0);
		}
		public DayPartContext dayPart() {
			return GetRuleContext<DayPartContext>(0);
		}
		public HourPartContext hourPart() {
			return GetRuleContext<HourPartContext>(0);
		}
		public MinutePartContext minutePart() {
			return GetRuleContext<MinutePartContext>(0);
		}
		public SecondPartContext secondPart() {
			return GetRuleContext<SecondPartContext>(0);
		}
		public MillisecondPartContext millisecondPart() {
			return GetRuleContext<MillisecondPartContext>(0);
		}
		public MicrosecondPartContext microsecondPart() {
			return GetRuleContext<MicrosecondPartContext>(0);
		}
		public TimePeriodContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timePeriod; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterTimePeriod(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitTimePeriod(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimePeriod(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TimePeriodContext timePeriod() {
		TimePeriodContext _localctx = new TimePeriodContext(Context, State);
		EnterRule(_localctx, 460, RULE_timePeriod);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3153;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,448,Context) ) {
			case 1:
				{
				State = 3036; yearPart();
				State = 3038;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,412,Context) ) {
				case 1:
					{
					State = 3037; monthPart();
					}
					break;
				}
				State = 3041;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,413,Context) ) {
				case 1:
					{
					State = 3040; weekPart();
					}
					break;
				}
				State = 3044;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,414,Context) ) {
				case 1:
					{
					State = 3043; dayPart();
					}
					break;
				}
				State = 3047;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,415,Context) ) {
				case 1:
					{
					State = 3046; hourPart();
					}
					break;
				}
				State = 3050;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,416,Context) ) {
				case 1:
					{
					State = 3049; minutePart();
					}
					break;
				}
				State = 3053;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,417,Context) ) {
				case 1:
					{
					State = 3052; secondPart();
					}
					break;
				}
				State = 3056;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,418,Context) ) {
				case 1:
					{
					State = 3055; millisecondPart();
					}
					break;
				}
				State = 3059;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (QUESTION - 143)) | (1L << (PLUS - 143)) | (1L << (MINUS - 143)) | (1L << (IDENT - 143)) | (1L << (IntegerLiteral - 143)) | (1L << (FloatingPointLiteral - 143)))) != 0)) {
					{
					State = 3058; microsecondPart();
					}
				}

				}
				break;
			case 2:
				{
				State = 3061; monthPart();
				State = 3063;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,420,Context) ) {
				case 1:
					{
					State = 3062; weekPart();
					}
					break;
				}
				State = 3066;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,421,Context) ) {
				case 1:
					{
					State = 3065; dayPart();
					}
					break;
				}
				State = 3069;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,422,Context) ) {
				case 1:
					{
					State = 3068; hourPart();
					}
					break;
				}
				State = 3072;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,423,Context) ) {
				case 1:
					{
					State = 3071; minutePart();
					}
					break;
				}
				State = 3075;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,424,Context) ) {
				case 1:
					{
					State = 3074; secondPart();
					}
					break;
				}
				State = 3078;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,425,Context) ) {
				case 1:
					{
					State = 3077; millisecondPart();
					}
					break;
				}
				State = 3081;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (QUESTION - 143)) | (1L << (PLUS - 143)) | (1L << (MINUS - 143)) | (1L << (IDENT - 143)) | (1L << (IntegerLiteral - 143)) | (1L << (FloatingPointLiteral - 143)))) != 0)) {
					{
					State = 3080; microsecondPart();
					}
				}

				}
				break;
			case 3:
				{
				State = 3083; weekPart();
				State = 3085;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,427,Context) ) {
				case 1:
					{
					State = 3084; dayPart();
					}
					break;
				}
				State = 3088;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,428,Context) ) {
				case 1:
					{
					State = 3087; hourPart();
					}
					break;
				}
				State = 3091;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,429,Context) ) {
				case 1:
					{
					State = 3090; minutePart();
					}
					break;
				}
				State = 3094;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,430,Context) ) {
				case 1:
					{
					State = 3093; secondPart();
					}
					break;
				}
				State = 3097;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,431,Context) ) {
				case 1:
					{
					State = 3096; millisecondPart();
					}
					break;
				}
				State = 3100;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (QUESTION - 143)) | (1L << (PLUS - 143)) | (1L << (MINUS - 143)) | (1L << (IDENT - 143)) | (1L << (IntegerLiteral - 143)) | (1L << (FloatingPointLiteral - 143)))) != 0)) {
					{
					State = 3099; microsecondPart();
					}
				}

				}
				break;
			case 4:
				{
				State = 3102; dayPart();
				State = 3104;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,433,Context) ) {
				case 1:
					{
					State = 3103; hourPart();
					}
					break;
				}
				State = 3107;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,434,Context) ) {
				case 1:
					{
					State = 3106; minutePart();
					}
					break;
				}
				State = 3110;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,435,Context) ) {
				case 1:
					{
					State = 3109; secondPart();
					}
					break;
				}
				State = 3113;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,436,Context) ) {
				case 1:
					{
					State = 3112; millisecondPart();
					}
					break;
				}
				State = 3116;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (QUESTION - 143)) | (1L << (PLUS - 143)) | (1L << (MINUS - 143)) | (1L << (IDENT - 143)) | (1L << (IntegerLiteral - 143)) | (1L << (FloatingPointLiteral - 143)))) != 0)) {
					{
					State = 3115; microsecondPart();
					}
				}

				}
				break;
			case 5:
				{
				State = 3118; hourPart();
				State = 3120;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,438,Context) ) {
				case 1:
					{
					State = 3119; minutePart();
					}
					break;
				}
				State = 3123;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,439,Context) ) {
				case 1:
					{
					State = 3122; secondPart();
					}
					break;
				}
				State = 3126;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,440,Context) ) {
				case 1:
					{
					State = 3125; millisecondPart();
					}
					break;
				}
				State = 3129;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (QUESTION - 143)) | (1L << (PLUS - 143)) | (1L << (MINUS - 143)) | (1L << (IDENT - 143)) | (1L << (IntegerLiteral - 143)) | (1L << (FloatingPointLiteral - 143)))) != 0)) {
					{
					State = 3128; microsecondPart();
					}
				}

				}
				break;
			case 6:
				{
				State = 3131; minutePart();
				State = 3133;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,442,Context) ) {
				case 1:
					{
					State = 3132; secondPart();
					}
					break;
				}
				State = 3136;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,443,Context) ) {
				case 1:
					{
					State = 3135; millisecondPart();
					}
					break;
				}
				State = 3139;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (QUESTION - 143)) | (1L << (PLUS - 143)) | (1L << (MINUS - 143)) | (1L << (IDENT - 143)) | (1L << (IntegerLiteral - 143)) | (1L << (FloatingPointLiteral - 143)))) != 0)) {
					{
					State = 3138; microsecondPart();
					}
				}

				}
				break;
			case 7:
				{
				State = 3141; secondPart();
				State = 3143;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,445,Context) ) {
				case 1:
					{
					State = 3142; millisecondPart();
					}
					break;
				}
				State = 3146;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (QUESTION - 143)) | (1L << (PLUS - 143)) | (1L << (MINUS - 143)) | (1L << (IDENT - 143)) | (1L << (IntegerLiteral - 143)) | (1L << (FloatingPointLiteral - 143)))) != 0)) {
					{
					State = 3145; microsecondPart();
					}
				}

				}
				break;
			case 8:
				{
				State = 3148; millisecondPart();
				State = 3150;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 143)) & ~0x3f) == 0 && ((1L << (_la - 143)) & ((1L << (QUESTION - 143)) | (1L << (PLUS - 143)) | (1L << (MINUS - 143)) | (1L << (IDENT - 143)) | (1L << (IntegerLiteral - 143)) | (1L << (FloatingPointLiteral - 143)))) != 0)) {
					{
					State = 3149; microsecondPart();
					}
				}

				}
				break;
			case 9:
				{
				State = 3152; microsecondPart();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class YearPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_YEARS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_YEARS, 0); }
		public ITerminalNode TIMEPERIOD_YEAR() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_YEAR, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public YearPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_yearPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterYearPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitYearPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitYearPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public YearPartContext yearPart() {
		YearPartContext _localctx = new YearPartContext(Context, State);
		EnterRule(_localctx, 462, RULE_yearPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3158;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3155; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3156; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3157; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3160;
			_la = TokenStream.LA(1);
			if ( !(_la==TIMEPERIOD_YEAR || _la==TIMEPERIOD_YEARS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MonthPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_MONTHS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MONTHS, 0); }
		public ITerminalNode TIMEPERIOD_MONTH() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MONTH, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MonthPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_monthPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMonthPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMonthPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMonthPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MonthPartContext monthPart() {
		MonthPartContext _localctx = new MonthPartContext(Context, State);
		EnterRule(_localctx, 464, RULE_monthPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3165;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3162; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3163; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3164; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3167;
			_la = TokenStream.LA(1);
			if ( !(_la==TIMEPERIOD_MONTH || _la==TIMEPERIOD_MONTHS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WeekPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_WEEKS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_WEEKS, 0); }
		public ITerminalNode TIMEPERIOD_WEEK() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_WEEK, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public WeekPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_weekPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterWeekPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitWeekPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWeekPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WeekPartContext weekPart() {
		WeekPartContext _localctx = new WeekPartContext(Context, State);
		EnterRule(_localctx, 466, RULE_weekPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3172;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3169; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3170; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3171; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3174;
			_la = TokenStream.LA(1);
			if ( !(_la==TIMEPERIOD_WEEK || _la==TIMEPERIOD_WEEKS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DayPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_DAYS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_DAYS, 0); }
		public ITerminalNode TIMEPERIOD_DAY() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_DAY, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public DayPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dayPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterDayPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitDayPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDayPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DayPartContext dayPart() {
		DayPartContext _localctx = new DayPartContext(Context, State);
		EnterRule(_localctx, 468, RULE_dayPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3179;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3176; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3177; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3178; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3181;
			_la = TokenStream.LA(1);
			if ( !(_la==TIMEPERIOD_DAY || _la==TIMEPERIOD_DAYS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HourPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_HOURS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_HOURS, 0); }
		public ITerminalNode TIMEPERIOD_HOUR() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_HOUR, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public HourPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hourPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterHourPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitHourPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHourPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HourPartContext hourPart() {
		HourPartContext _localctx = new HourPartContext(Context, State);
		EnterRule(_localctx, 470, RULE_hourPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3186;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3183; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3184; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3185; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3188;
			_la = TokenStream.LA(1);
			if ( !(_la==TIMEPERIOD_HOUR || _la==TIMEPERIOD_HOURS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MinutePartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_MINUTES() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MINUTES, 0); }
		public ITerminalNode TIMEPERIOD_MINUTE() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MINUTE, 0); }
		public ITerminalNode MIN() { return GetToken(EsperEPL2GrammarParser.MIN, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MinutePartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_minutePart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMinutePart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMinutePart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMinutePart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MinutePartContext minutePart() {
		MinutePartContext _localctx = new MinutePartContext(Context, State);
		EnterRule(_localctx, 472, RULE_minutePart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3193;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3190; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3191; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3192; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3195;
			_la = TokenStream.LA(1);
			if ( !(_la==MIN || _la==TIMEPERIOD_MINUTE || _la==TIMEPERIOD_MINUTES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SecondPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_SECONDS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SECONDS, 0); }
		public ITerminalNode TIMEPERIOD_SECOND() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SECOND, 0); }
		public ITerminalNode TIMEPERIOD_SEC() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SEC, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public SecondPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_secondPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSecondPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSecondPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSecondPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SecondPartContext secondPart() {
		SecondPartContext _localctx = new SecondPartContext(Context, State);
		EnterRule(_localctx, 474, RULE_secondPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3200;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3197; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3198; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3199; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3202;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 98)) & ~0x3f) == 0 && ((1L << (_la - 98)) & ((1L << (TIMEPERIOD_SEC - 98)) | (1L << (TIMEPERIOD_SECOND - 98)) | (1L << (TIMEPERIOD_SECONDS - 98)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MillisecondPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_MILLISECONDS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MILLISECONDS, 0); }
		public ITerminalNode TIMEPERIOD_MILLISECOND() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MILLISECOND, 0); }
		public ITerminalNode TIMEPERIOD_MILLISEC() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MILLISEC, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MillisecondPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_millisecondPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMillisecondPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMillisecondPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMillisecondPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MillisecondPartContext millisecondPart() {
		MillisecondPartContext _localctx = new MillisecondPartContext(Context, State);
		EnterRule(_localctx, 476, RULE_millisecondPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3207;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3204; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3205; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3206; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3209;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 101)) & ~0x3f) == 0 && ((1L << (_la - 101)) & ((1L << (TIMEPERIOD_MILLISEC - 101)) | (1L << (TIMEPERIOD_MILLISECOND - 101)) | (1L << (TIMEPERIOD_MILLISECONDS - 101)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MicrosecondPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_MICROSECONDS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MICROSECONDS, 0); }
		public ITerminalNode TIMEPERIOD_MICROSECOND() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MICROSECOND, 0); }
		public ITerminalNode TIMEPERIOD_MICROSEC() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MICROSEC, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MicrosecondPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_microsecondPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMicrosecondPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMicrosecondPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMicrosecondPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MicrosecondPartContext microsecondPart() {
		MicrosecondPartContext _localctx = new MicrosecondPartContext(Context, State);
		EnterRule(_localctx, 478, RULE_microsecondPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3214;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3211; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3212; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3213; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3216;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 104)) & ~0x3f) == 0 && ((1L << (_la - 104)) & ((1L << (TIMEPERIOD_MICROSEC - 104)) | (1L << (TIMEPERIOD_MICROSECOND - 104)) | (1L << (TIMEPERIOD_MICROSECONDS - 104)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberContext : ParserRuleContext {
		public ITerminalNode IntegerLiteral() { return GetToken(EsperEPL2GrammarParser.IntegerLiteral, 0); }
		public ITerminalNode FloatingPointLiteral() { return GetToken(EsperEPL2GrammarParser.FloatingPointLiteral, 0); }
		public NumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_number; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberContext number() {
		NumberContext _localctx = new NumberContext(Context, State);
		EnterRule(_localctx, 480, RULE_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3218;
			_la = TokenStream.LA(1);
			if ( !(_la==IntegerLiteral || _la==FloatingPointLiteral) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubstitutionContext : ParserRuleContext {
		public IToken q;
		public ITerminalNode QUESTION() { return GetToken(EsperEPL2GrammarParser.QUESTION, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public SlashIdentifierContext slashIdentifier() {
			return GetRuleContext<SlashIdentifierContext>(0);
		}
		public SubstitutionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_substitution; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubstitution(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubstitution(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubstitution(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubstitutionContext substitution() {
		SubstitutionContext _localctx = new SubstitutionContext(Context, State);
		EnterRule(_localctx, 482, RULE_substitution);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3220; _localctx.q = Match(QUESTION);
			State = 3223;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,458,Context) ) {
			case 1:
				{
				State = 3221; Match(COLON);
				State = 3222; slashIdentifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public IToken t;
		public IToken f;
		public IToken nu;
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public StringconstantContext stringconstant() {
			return GetRuleContext<StringconstantContext>(0);
		}
		public ITerminalNode BOOLEAN_TRUE() { return GetToken(EsperEPL2GrammarParser.BOOLEAN_TRUE, 0); }
		public ITerminalNode BOOLEAN_FALSE() { return GetToken(EsperEPL2GrammarParser.BOOLEAN_FALSE, 0); }
		public ITerminalNode VALUE_NULL() { return GetToken(EsperEPL2GrammarParser.VALUE_NULL, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 484, RULE_constant);
		try {
			State = 3230;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3225; numberconstant();
				}
				break;
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3226; stringconstant();
				}
				break;
			case BOOLEAN_TRUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3227; _localctx.t = Match(BOOLEAN_TRUE);
				}
				break;
			case BOOLEAN_FALSE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3228; _localctx.f = Match(BOOLEAN_FALSE);
				}
				break;
			case VALUE_NULL:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3229; _localctx.nu = Match(VALUE_NULL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberconstantContext : ParserRuleContext {
		public IToken m;
		public IToken p;
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(EsperEPL2GrammarParser.MINUS, 0); }
		public ITerminalNode PLUS() { return GetToken(EsperEPL2GrammarParser.PLUS, 0); }
		public NumberconstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numberconstant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNumberconstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNumberconstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberconstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberconstantContext numberconstant() {
		NumberconstantContext _localctx = new NumberconstantContext(Context, State);
		EnterRule(_localctx, 486, RULE_numberconstant);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3234;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MINUS:
				{
				State = 3232; _localctx.m = Match(MINUS);
				}
				break;
			case PLUS:
				{
				State = 3233; _localctx.p = Match(PLUS);
				}
				break;
			case IntegerLiteral:
			case FloatingPointLiteral:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3236; number();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringconstantContext : ParserRuleContext {
		public IToken sl;
		public IToken qsl;
		public ITerminalNode STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.STRING_LITERAL, 0); }
		public ITerminalNode QUOTED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.QUOTED_STRING_LITERAL, 0); }
		public StringconstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringconstant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStringconstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStringconstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringconstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringconstantContext stringconstant() {
		StringconstantContext _localctx = new StringconstantContext(Context, State);
		EnterRule(_localctx, 488, RULE_stringconstant);
		try {
			State = 3240;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3238; _localctx.sl = Match(STRING_LITERAL);
				}
				break;
			case QUOTED_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3239; _localctx.qsl = Match(QUOTED_STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonvalueContext : ParserRuleContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public JsonobjectContext jsonobject() {
			return GetRuleContext<JsonobjectContext>(0);
		}
		public JsonarrayContext jsonarray() {
			return GetRuleContext<JsonarrayContext>(0);
		}
		public JsonvalueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonvalue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonvalue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonvalue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonvalue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonvalueContext jsonvalue() {
		JsonvalueContext _localctx = new JsonvalueContext(Context, State);
		EnterRule(_localctx, 490, RULE_jsonvalue);
		try {
			State = 3245;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case PLUS:
			case MINUS:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3242; constant();
				}
				break;
			case LCURLY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3243; jsonobject();
				}
				break;
			case LBRACK:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3244; jsonarray();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonobjectContext : ParserRuleContext {
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public JsonmembersContext jsonmembers() {
			return GetRuleContext<JsonmembersContext>(0);
		}
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public JsonobjectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonobject; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonobject(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonobject(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonobject(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonobjectContext jsonobject() {
		JsonobjectContext _localctx = new JsonobjectContext(Context, State);
		EnterRule(_localctx, 492, RULE_jsonobject);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3247; Match(LCURLY);
			State = 3248; jsonmembers();
			State = 3249; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonarrayContext : ParserRuleContext {
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public JsonelementsContext jsonelements() {
			return GetRuleContext<JsonelementsContext>(0);
		}
		public JsonarrayContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonarray; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonarray(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonarray(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonarray(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonarrayContext jsonarray() {
		JsonarrayContext _localctx = new JsonarrayContext(Context, State);
		EnterRule(_localctx, 494, RULE_jsonarray);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3251; Match(LBRACK);
			State = 3253;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 107)) & ~0x3f) == 0 && ((1L << (_la - 107)) & ((1L << (BOOLEAN_TRUE - 107)) | (1L << (BOOLEAN_FALSE - 107)) | (1L << (VALUE_NULL - 107)) | (1L << (LBRACK - 107)) | (1L << (LCURLY - 107)) | (1L << (PLUS - 107)) | (1L << (MINUS - 107)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (QUOTED_STRING_LITERAL - 193)) | (1L << (STRING_LITERAL - 193)) | (1L << (IntegerLiteral - 193)) | (1L << (FloatingPointLiteral - 193)))) != 0)) {
				{
				State = 3252; jsonelements();
				}
			}

			State = 3255; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonelementsContext : ParserRuleContext {
		public JsonvalueContext[] jsonvalue() {
			return GetRuleContexts<JsonvalueContext>();
		}
		public JsonvalueContext jsonvalue(int i) {
			return GetRuleContext<JsonvalueContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public JsonelementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonelements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonelements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonelements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonelements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonelementsContext jsonelements() {
		JsonelementsContext _localctx = new JsonelementsContext(Context, State);
		EnterRule(_localctx, 496, RULE_jsonelements);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3257; jsonvalue();
			State = 3262;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,464,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 3258; Match(COMMA);
					State = 3259; jsonvalue();
					}
					} 
				}
				State = 3264;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,464,Context);
			}
			State = 3266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 3265; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonmembersContext : ParserRuleContext {
		public JsonpairContext[] jsonpair() {
			return GetRuleContexts<JsonpairContext>();
		}
		public JsonpairContext jsonpair(int i) {
			return GetRuleContext<JsonpairContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public JsonmembersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonmembers; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonmembers(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonmembers(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonmembers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonmembersContext jsonmembers() {
		JsonmembersContext _localctx = new JsonmembersContext(Context, State);
		EnterRule(_localctx, 498, RULE_jsonmembers);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3268; jsonpair();
			State = 3273;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,466,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 3269; Match(COMMA);
					State = 3270; jsonpair();
					}
					} 
				}
				State = 3275;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,466,Context);
			}
			State = 3277;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 3276; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonpairContext : ParserRuleContext {
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public JsonvalueContext jsonvalue() {
			return GetRuleContext<JsonvalueContext>(0);
		}
		public StringconstantContext stringconstant() {
			return GetRuleContext<StringconstantContext>(0);
		}
		public KeywordAllowedIdentContext keywordAllowedIdent() {
			return GetRuleContext<KeywordAllowedIdentContext>(0);
		}
		public JsonpairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonpair; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonpair(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonpair(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonpair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonpairContext jsonpair() {
		JsonpairContext _localctx = new JsonpairContext(Context, State);
		EnterRule(_localctx, 500, RULE_jsonpair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3281;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
				{
				State = 3279; stringconstant();
				}
				break;
			case WINDOW:
			case ESCAPE:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case SCHEMA:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PRIOR:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case CONTEXT:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 3280; keywordAllowedIdent();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3283; Match(COLON);
			State = 3284; jsonvalue();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\xC7");
		sb.Append("\xCD9\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6");
		sb.Append("\x4\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r");
		sb.Append("\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x4\x12");
		sb.Append("\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15\x4\x16\t\x16\x4");
		sb.Append("\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B\t\x1B");
		sb.Append("\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t ");
		sb.Append("\x4!\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t");
		sb.Append("(\x4)\t)\x4*\t*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t");
		sb.Append("\x30\x4\x31\t\x31\x4\x32\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4");
		sb.Append("\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37\x4\x38\t\x38\x4\x39\t\x39");
		sb.Append("\x4:\t:\x4;\t;\x4<\t<\x4=\t=\x4>\t>\x4?\t?\x4@\t@\x4\x41\t\x41");
		sb.Append("\x4\x42\t\x42\x4\x43\t\x43\x4\x44\t\x44\x4\x45\t\x45\x4\x46");
		sb.Append("\t\x46\x4G\tG\x4H\tH\x4I\tI\x4J\tJ\x4K\tK\x4L\tL\x4M\tM\x4N");
		sb.Append("\tN\x4O\tO\x4P\tP\x4Q\tQ\x4R\tR\x4S\tS\x4T\tT\x4U\tU\x4V\tV");
		sb.Append("\x4W\tW\x4X\tX\x4Y\tY\x4Z\tZ\x4[\t[\x4\\\t\\\x4]\t]\x4^\t^\x4");
		sb.Append("_\t_\x4`\t`\x4\x61\t\x61\x4\x62\t\x62\x4\x63\t\x63\x4\x64\t");
		sb.Append("\x64\x4\x65\t\x65\x4\x66\t\x66\x4g\tg\x4h\th\x4i\ti\x4j\tj\x4");
		sb.Append("k\tk\x4l\tl\x4m\tm\x4n\tn\x4o\to\x4p\tp\x4q\tq\x4r\tr\x4s\t");
		sb.Append("s\x4t\tt\x4u\tu\x4v\tv\x4w\tw\x4x\tx\x4y\ty\x4z\tz\x4{\t{\x4");
		sb.Append("|\t|\x4}\t}\x4~\t~\x4\x7F\t\x7F\x4\x80\t\x80\x4\x81\t\x81\x4");
		sb.Append("\x82\t\x82\x4\x83\t\x83\x4\x84\t\x84\x4\x85\t\x85\x4\x86\t\x86");
		sb.Append("\x4\x87\t\x87\x4\x88\t\x88\x4\x89\t\x89\x4\x8A\t\x8A\x4\x8B");
		sb.Append("\t\x8B\x4\x8C\t\x8C\x4\x8D\t\x8D\x4\x8E\t\x8E\x4\x8F\t\x8F\x4");
		sb.Append("\x90\t\x90\x4\x91\t\x91\x4\x92\t\x92\x4\x93\t\x93\x4\x94\t\x94");
		sb.Append("\x4\x95\t\x95\x4\x96\t\x96\x4\x97\t\x97\x4\x98\t\x98\x4\x99");
		sb.Append("\t\x99\x4\x9A\t\x9A\x4\x9B\t\x9B\x4\x9C\t\x9C\x4\x9D\t\x9D\x4");
		sb.Append("\x9E\t\x9E\x4\x9F\t\x9F\x4\xA0\t\xA0\x4\xA1\t\xA1\x4\xA2\t\xA2");
		sb.Append("\x4\xA3\t\xA3\x4\xA4\t\xA4\x4\xA5\t\xA5\x4\xA6\t\xA6\x4\xA7");
		sb.Append("\t\xA7\x4\xA8\t\xA8\x4\xA9\t\xA9\x4\xAA\t\xAA\x4\xAB\t\xAB\x4");
		sb.Append("\xAC\t\xAC\x4\xAD\t\xAD\x4\xAE\t\xAE\x4\xAF\t\xAF\x4\xB0\t\xB0");
		sb.Append("\x4\xB1\t\xB1\x4\xB2\t\xB2\x4\xB3\t\xB3\x4\xB4\t\xB4\x4\xB5");
		sb.Append("\t\xB5\x4\xB6\t\xB6\x4\xB7\t\xB7\x4\xB8\t\xB8\x4\xB9\t\xB9\x4");
		sb.Append("\xBA\t\xBA\x4\xBB\t\xBB\x4\xBC\t\xBC\x4\xBD\t\xBD\x4\xBE\t\xBE");
		sb.Append("\x4\xBF\t\xBF\x4\xC0\t\xC0\x4\xC1\t\xC1\x4\xC2\t\xC2\x4\xC3");
		sb.Append("\t\xC3\x4\xC4\t\xC4\x4\xC5\t\xC5\x4\xC6\t\xC6\x4\xC7\t\xC7\x4");
		sb.Append("\xC8\t\xC8\x4\xC9\t\xC9\x4\xCA\t\xCA\x4\xCB\t\xCB\x4\xCC\t\xCC");
		sb.Append("\x4\xCD\t\xCD\x4\xCE\t\xCE\x4\xCF\t\xCF\x4\xD0\t\xD0\x4\xD1");
		sb.Append("\t\xD1\x4\xD2\t\xD2\x4\xD3\t\xD3\x4\xD4\t\xD4\x4\xD5\t\xD5\x4");
		sb.Append("\xD6\t\xD6\x4\xD7\t\xD7\x4\xD8\t\xD8\x4\xD9\t\xD9\x4\xDA\t\xDA");
		sb.Append("\x4\xDB\t\xDB\x4\xDC\t\xDC\x4\xDD\t\xDD\x4\xDE\t\xDE\x4\xDF");
		sb.Append("\t\xDF\x4\xE0\t\xE0\x4\xE1\t\xE1\x4\xE2\t\xE2\x4\xE3\t\xE3\x4");
		sb.Append("\xE4\t\xE4\x4\xE5\t\xE5\x4\xE6\t\xE6\x4\xE7\t\xE7\x4\xE8\t\xE8");
		sb.Append("\x4\xE9\t\xE9\x4\xEA\t\xEA\x4\xEB\t\xEB\x4\xEC\t\xEC\x4\xED");
		sb.Append("\t\xED\x4\xEE\t\xEE\x4\xEF\t\xEF\x4\xF0\t\xF0\x4\xF1\t\xF1\x4");
		sb.Append("\xF2\t\xF2\x4\xF3\t\xF3\x4\xF4\t\xF4\x4\xF5\t\xF5\x4\xF6\t\xF6");
		sb.Append("\x4\xF7\t\xF7\x4\xF8\t\xF8\x4\xF9\t\xF9\x4\xFA\t\xFA\x4\xFB");
		sb.Append("\t\xFB\x4\xFC\t\xFC\x3\x2\x3\x2\a\x2\x1FB\n\x2\f\x2\xE\x2\x1FE");
		sb.Append("\v\x2\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\a\x3\x205\n\x3\f\x3\xE\x3");
		sb.Append("\x208\v\x3\x3\x3\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3");
		sb.Append("\x5\x3\x6\x3\x6\x5\x6\x215\n\x6\x3\x6\x3\x6\x5\x6\x219\n\x6");
		sb.Append("\x3\x6\x5\x6\x21C\n\x6\x3\x6\x5\x6\x21F\n\x6\x3\x6\x3\x6\x3");
		sb.Append("\x6\x5\x6\x224\n\x6\x3\x6\x5\x6\x227\n\x6\x3\x6\x3\x6\x5\x6");
		sb.Append("\x22B\n\x6\x3\x6\x3\x6\x3\a\x3\a\x3\a\x3\b\x3\b\x5\b\x234\n");
		sb.Append("\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x5\b\x23D\n\b\x3\t\x3");
		sb.Append("\t\x3\t\x3\t\x3\t\x5\t\x244\n\t\x3\t\x3\t\x3\n\x3\n\x3\n\x3");
		sb.Append("\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x5\v\x253\n\v\x3\v\x5");
		sb.Append("\v\x256\n\v\x3\f\x3\f\x3\f\a\f\x25B\n\f\f\f\xE\f\x25E\v\f\x3");
		sb.Append("\r\x3\r\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x5\xE\x269\n");
		sb.Append("\xE\x3\xF\x3\xF\x3\xF\x3\xF\a\xF\x26F\n\xF\f\xF\xE\xF\x272\v");
		sb.Append("\xF\x5\xF\x274\n\xF\x3\xF\x5\xF\x277\n\xF\x3\xF\x3\xF\x3\x10");
		sb.Append("\x5\x10\x27C\n\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10");
		sb.Append("\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x5");
		sb.Append("\x10\x28C\n\x10\x3\x10\x5\x10\x28F\n\x10\x3\x11\x3\x11\x3\x11");
		sb.Append("\x3\x12\x3\x12\x5\x12\x296\n\x12\x3\x12\x3\x12\x5\x12\x29A\n");
		sb.Append("\x12\x3\x12\x3\x12\x3\x12\x3\x12\x5\x12\x2A0\n\x12\x3\x12\x5");
		sb.Append("\x12\x2A3\n\x12\x3\x12\x3\x12\x5\x12\x2A7\n\x12\x3\x12\x3\x12");
		sb.Append("\x3\x12\x5\x12\x2AC\n\x12\x3\x12\x3\x12\x5\x12\x2B0\n\x12\x3");
		sb.Append("\x12\x3\x12\x5\x12\x2B4\n\x12\x3\x12\x3\x12\x3\x12\x5\x12\x2B9");
		sb.Append("\n\x12\x3\x12\x3\x12\x5\x12\x2BD\n\x12\x3\x13\x3\x13\x3\x13");
		sb.Append("\x3\x13\x3\x13\x6\x13\x2C4\n\x13\r\x13\xE\x13\x2C5\x3\x13\x5");
		sb.Append("\x13\x2C9\n\x13\x5\x13\x2CB\n\x13\x3\x13\x3\x13\x3\x13\x5\x13");
		sb.Append("\x2D0\n\x13\x3\x14\x3\x14\x5\x14\x2D4\n\x14\x3\x14\x3\x14\x3");
		sb.Append("\x14\x5\x14\x2D9\n\x14\x3\x15\x3\x15\x3\x15\x3\x15\x3\x16\x3");
		sb.Append("\x16\x3\x16\x3\x16\x5\x16\x2E3\n\x16\x3\x16\x3\x16\x3\x16\x3");
		sb.Append("\x16\x5\x16\x2E9\n\x16\x3\x17\x3\x17\x5\x17\x2ED\n\x17\x3\x17");
		sb.Append("\x3\x17\x3\x17\x3\x17\x5\x17\x2F3\n\x17\x3\x17\x3\x17\x5\x17");
		sb.Append("\x2F7\n\x17\x3\x17\x6\x17\x2FA\n\x17\r\x17\xE\x17\x2FB\x3\x18");
		sb.Append("\x3\x18\x5\x18\x300\n\x18\x3\x19\x3\x19\x3\x19\x3\x19\x5\x19");
		sb.Append("\x306\n\x19\x3\x19\x6\x19\x309\n\x19\r\x19\xE\x19\x30A\x3\x1A");
		sb.Append("\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x5\x1A\x314\n\x1A");
		sb.Append("\x3\x1A\x3\x1A\x3\x1A\x5\x1A\x319\n\x1A\x3\x1A\x5\x1A\x31C\n");
		sb.Append("\x1A\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x5\x1B\x323\n\x1B\x3");
		sb.Append("\x1B\x6\x1B\x326\n\x1B\r\x1B\xE\x1B\x327\x3\x1C\x3\x1C\x3\x1C");
		sb.Append("\x3\x1D\x3\x1D\x3\x1D\x5\x1D\x330\n\x1D\x3\x1D\x3\x1D\x3\x1D");
		sb.Append("\x3\x1D\x5\x1D\x336\n\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x5\x1D");
		sb.Append("\x33C\n\x1D\x3\x1E\x3\x1E\x5\x1E\x340\n\x1E\x3\x1E\x3\x1E\x5");
		sb.Append("\x1E\x344\n\x1E\x3\x1E\x5\x1E\x347\n\x1E\x3\x1E\x5\x1E\x34A");
		sb.Append("\n\x1E\x3\x1E\x3\x1E\x5\x1E\x34E\n\x1E\x3\x1E\x3\x1E\x5\x1E");
		sb.Append("\x352\n\x1E\x3\x1E\x3\x1E\x3\x1E\x5\x1E\x357\n\x1E\x3\x1E\x3");
		sb.Append("\x1E\x5\x1E\x35B\n\x1E\x3\x1E\x3\x1E\x3\x1E\x5\x1E\x360\n\x1E");
		sb.Append("\x3\x1E\x3\x1E\x5\x1E\x364\n\x1E\x3\x1F\x3\x1F\x3\x1F\x3\x1F");
		sb.Append("\x3\x1F\x5\x1F\x36B\n\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x5\x1F");
		sb.Append("\x371\n\x1F\x3 \x3 \x3 \x3 \x3 \x5 \x378\n \x3 \x3 \x5 \x37C");
		sb.Append("\n \x3!\x3!\x3!\x3!\x3!\x5!\x383\n!\x3\"\x3\"\x3\"\x5\"\x388");
		sb.Append("\n\"\x3#\x3#\x3#\x3#\x5#\x38E\n#\x3$\x3$\x3$\x3%\x3%\x3%\a%");
		sb.Append("\x396\n%\f%\xE%\x399\v%\x3&\x3&\x3&\x3&\x3&\x5&\x3A0\n&\x3\'");
		sb.Append("\x3\'\x3\'\x3\'\x3\'\x5\'\x3A7\n\'\x3(\x3(\x3(\x3(\x5(\x3AD");
		sb.Append("\n(\x3(\x3(\x5(\x3B1\n(\x3(\x5(\x3B4\n(\x3(\x3(\x3(\x3(\x3(");
		sb.Append("\x5(\x3BB\n(\x3(\x3(\x3(\x5(\x3C0\n(\x5(\x3C2\n(\x3)\x3)\x3");
		sb.Append(")\x3)\x5)\x3C8\n)\x3)\x3)\x3*\x3*\x5*\x3CE\n*\x3*\x3*\x3*\x3");
		sb.Append("*\x3*\x3*\x3*\x3*\x3+\x3+\x3+\a+\x3DB\n+\f+\xE+\x3DE\v+\x3,");
		sb.Append("\x3,\x5,\x3E2\n,\x3-\x3-\x5-\x3E6\n-\x3-\x3-\x3-\x3-\x5-\x3EC");
		sb.Append("\n-\x3-\x5-\x3EF\n-\x3-\x3-\x3-\x5-\x3F4\n-\x3.\x3.\x3.\x3.");
		sb.Append("\x5.\x3FA\n.\x3.\x3.\x3.\x3.\x3/\x3/\x3/\a/\x403\n/\f/\xE/\x406");
		sb.Append("\v/\x3\x30\x3\x30\x3\x30\x3\x30\x5\x30\x40C\n\x30\x3\x30\x5");
		sb.Append("\x30\x40F\n\x30\x3\x30\x5\x30\x412\n\x30\x3\x30\x3\x30\a\x30");
		sb.Append("\x416\n\x30\f\x30\xE\x30\x419\v\x30\x3\x31\x3\x31\x3\x31\x5");
		sb.Append("\x31\x41E\n\x31\x3\x31\x5\x31\x421\n\x31\x3\x32\x3\x32\x3\x32");
		sb.Append("\a\x32\x426\n\x32\f\x32\xE\x32\x429\v\x32\x3\x33\x3\x33\x3\x33");
		sb.Append("\x3\x33\x3\x33\x5\x33\x430\n\x33\x3\x33\x5\x33\x433\n\x33\x5");
		sb.Append("\x33\x435\n\x33\x3\x34\x3\x34\x3\x34\a\x34\x43A\n\x34\f\x34");
		sb.Append("\xE\x34\x43D\v\x34\x3\x35\x3\x35\x3\x35\x3\x35\x5\x35\x443\n");
		sb.Append("\x35\x3\x35\x3\x35\x3\x35\x3\x35\x5\x35\x449\n\x35\x3\x36\x3");
		sb.Append("\x36\x5\x36\x44D\n\x36\x3\x36\x3\x36\x3\x37\x3\x37\x3\x37\x5");
		sb.Append("\x37\x454\n\x37\x3\x37\x3\x37\x3\x37\x5\x37\x459\n\x37\x3\x37");
		sb.Append("\x5\x37\x45C\n\x37\x3\x37\a\x37\x45F\n\x37\f\x37\xE\x37\x462");
		sb.Append("\v\x37\x3\x38\x3\x38\x3\x38\x3\x38\x3\x38\x3\x38\x5\x38\x46A");
		sb.Append("\n\x38\x3\x38\x3\x38\x5\x38\x46E\n\x38\x3\x39\x3\x39\x3\x39");
		sb.Append("\x3:\x3:\x3:\x3:\x3:\x3:\x3:\x3;\x3;\x3;\x3;\x5;\x47E\n;\x3");
		sb.Append(";\x3;\x3<\x3<\a<\x484\n<\f<\xE<\x487\v<\x3=\a=\x48A\n=\f=\xE");
		sb.Append("=\x48D\v=\x3=\x3=\x5=\x491\n=\x3=\x5=\x494\n=\x3=\x5=\x497\n");
		sb.Append("=\x3=\x3=\x5=\x49B\n=\x3=\x5=\x49E\n=\x3=\x3=\x3=\x3=\x5=\x4A4");
		sb.Append("\n=\x3>\x3>\x3>\x3>\x3?\x3?\x3?\a?\x4AD\n?\f?\xE?\x4B0\v?\x3");
		sb.Append("@\x3@\x5@\x4B4\n@\x3@\x5@\x4B7\n@\x3\x41\x3\x41\x3\x41\x3\x41");
		sb.Append("\x3\x41\x3\x41\x3\x41\x3\x42\x3\x42\x3\x42\x3\x43\x3\x43\x3");
		sb.Append("\x43\x3\x43\a\x43\x4C7\n\x43\f\x43\xE\x43\x4CA\v\x43\x3\x44");
		sb.Append("\x3\x44\x5\x44\x4CE\n\x44\x3\x45\x3\x45\x3\x45\x3\x45\a\x45");
		sb.Append("\x4D4\n\x45\f\x45\xE\x45\x4D7\v\x45\x3\x45\x3\x45\x3\x46\x3");
		sb.Append("\x46\x5\x46\x4DD\n\x46\x3G\x3G\x5G\x4E1\nG\x3H\x3H\x3H\aH\x4E6");
		sb.Append("\nH\fH\xEH\x4E9\vH\x3I\x3I\x3I\x3I\x3I\x3I\x3I\x3I\x3I\x3I\x3");
		sb.Append("I\x5I\x4F6\nI\x5I\x4F8\nI\x3J\x3J\x3J\x3J\x5J\x4FE\nJ\x3J\x3");
		sb.Append("J\x3K\x3K\x3K\x3L\x3L\x3L\x3L\x3L\x3L\aL\x50B\nL\fL\xEL\x50E");
		sb.Append("\vL\x5L\x510\nL\x3M\x3M\x3M\x5M\x515\nM\x3M\x3M\x3N\x3N\x3N");
		sb.Append("\x3N\x5N\x51D\nN\x3N\x3N\x5N\x521\nN\x3N\x3N\x5N\x525\nN\x3");
		sb.Append("N\x5N\x528\nN\x3N\x3N\x3N\x5N\x52D\nN\x3N\x3N\x3N\x5N\x532\n");
		sb.Append("N\x3N\x5N\x535\nN\x3N\x3N\x5N\x539\nN\x3N\x3N\x3N\aN\x53E\n");
		sb.Append("N\fN\xEN\x541\vN\x3N\x3N\x3N\aN\x546\nN\fN\xEN\x549\vN\x3N\x3");
		sb.Append("N\x3N\x3N\x3N\x5N\x550\nN\x3N\x3N\x3N\aN\x555\nN\fN\xEN\x558");
		sb.Append("\vN\x3N\x3N\x3N\x5N\x55D\nN\x5N\x55F\nN\x3O\x3O\x3O\x5O\x564");
		sb.Append("\nO\x3O\x3O\x3P\x3P\x3P\x3P\x5P\x56C\nP\x3P\x3P\x3P\x5P\x571");
		sb.Append("\nP\x3Q\x3Q\x5Q\x575\nQ\x3Q\x5Q\x578\nQ\x3R\x3R\x3R\aR\x57D");
		sb.Append("\nR\fR\xER\x580\vR\x3R\x3R\x3R\x3S\x3S\x3S\x3S\x3T\x3T\x5T\x58B");
		sb.Append("\nT\x3T\x3T\x3T\x3T\x3U\x3U\x3U\x3V\x3V\x3V\aV\x597\nV\fV\xE");
		sb.Append("V\x59A\vV\x3W\x3W\x5W\x59E\nW\x3X\x3X\x3X\x3Y\x3Y\x3Y\x5Y\x5A6");
		sb.Append("\nY\x3Y\x3Y\x3Y\x3Y\x5Y\x5AC\nY\x3Y\x5Y\x5AF\nY\x3Z\x3Z\x3Z");
		sb.Append("\aZ\x5B4\nZ\fZ\xEZ\x5B7\vZ\x3[\x3[\x3[\x5[\x5BC\n[\x3\\\x3\\");
		sb.Append("\a\\\x5C0\n\\\f\\\xE\\\x5C3\v\\\x3]\x3]\a]\x5C7\n]\f]\xE]\x5CA");
		sb.Append("\v]\x3^\x3^\x3^\x5^\x5CF\n^\x3^\x5^\x5D2\n^\x3^\x5^\x5D5\n^");
		sb.Append("\x3^\x3^\x3^\x5^\x5DA\n^\x3_\x3_\x3_\x3_\a_\x5E0\n_\f_\xE_\x5E3");
		sb.Append("\v_\x3`\x3`\x3`\x3`\x3\x61\x3\x61\x3\x62\x3\x62\x3\x62\x5\x62");
		sb.Append("\x5EE\n\x62\x3\x62\x5\x62\x5F1\n\x62\x3\x62\x3\x62\x3\x63\x3");
		sb.Append("\x63\x3\x63\a\x63\x5F8\n\x63\f\x63\xE\x63\x5FB\v\x63\x3\x64");
		sb.Append("\x3\x64\x3\x64\x5\x64\x600\n\x64\x3\x65\x3\x65\x5\x65\x604\n");
		sb.Append("\x65\x3\x65\x5\x65\x607\n\x65\x3\x65\x5\x65\x60A\n\x65\x3\x66");
		sb.Append("\x3\x66\x3\x66\x3g\x3g\x3g\x3g\x3g\x5g\x614\ng\x3h\x3h\x3h\x3");
		sb.Append("h\x5h\x61A\nh\x3h\x5h\x61D\nh\x3h\x3h\x3h\x5h\x622\nh\x3h\x5");
		sb.Append("h\x625\nh\x3h\x3h\x5h\x629\nh\x3i\x3i\x3i\x3i\x5i\x62F\ni\x3");
		sb.Append("i\x5i\x632\ni\x3j\x3j\aj\x636\nj\fj\xEj\x639\vj\x3j\x3j\x3j");
		sb.Append("\x3j\x3k\x3k\x3k\x3k\x3k\x3k\x5k\x645\nk\x3k\x3k\x3k\x5k\x64A");
		sb.Append("\nk\x5k\x64C\nk\x3k\x3k\x3l\x3l\x3l\x3l\x3l\x5l\x655\nl\x3l");
		sb.Append("\x5l\x658\nl\x3l\x5l\x65B\nl\x3m\x3m\x3m\x3m\am\x661\nm\fm\xE");
		sb.Append("m\x664\vm\x3m\x3m\x3m\x3m\am\x66A\nm\fm\xEm\x66D\vm\x5m\x66F");
		sb.Append("\nm\x3n\x3n\x3n\x3n\x3o\x3o\x5o\x677\no\x3o\x3o\x3p\x3p\x5p");
		sb.Append("\x67D\np\x3p\x3p\x5p\x681\np\x3p\x5p\x684\np\x3q\x3q\x3q\aq");
		sb.Append("\x689\nq\fq\xEq\x68C\vq\x3r\x3r\x3r\x5r\x691\nr\x3s\x3s\x3s");
		sb.Append("\x3s\x3s\as\x698\ns\fs\xEs\x69B\vs\x3s\x3s\x3t\x3t\x3t\x3t\x3");
		sb.Append("t\x3t\at\x6A5\nt\ft\xEt\x6A8\vt\x3t\x3t\x3u\x3u\x5u\x6AE\nu");
		sb.Append("\x3v\x3v\x3v\x3v\x3v\av\x6B5\nv\fv\xEv\x6B8\vv\x5v\x6BA\nv\x3");
		sb.Append("v\x5v\x6BD\nv\x3w\x3w\x3w\aw\x6C2\nw\fw\xEw\x6C5\vw\x3x\x3x");
		sb.Append("\x3x\x5x\x6CA\nx\x3y\x3y\x3z\x5z\x6CF\nz\x3z\x3z\x3z\x3z\x5");
		sb.Append("z\x6D5\nz\x3z\x3z\x3z\x3z\x5z\x6DB\nz\x3z\x5z\x6DE\nz\x3z\x3");
		sb.Append("z\x3z\x3z\x3z\x3z\x5z\x6E6\nz\x3z\x3z\x3z\x3z\x5z\x6EC\nz\x3");
		sb.Append("z\x3z\x5z\x6F0\nz\x3z\x5z\x6F3\nz\x3z\x5z\x6F6\nz\x3{\x3{\x3");
		sb.Append("{\x3{\x3{\x5{\x6FD\n{\x3{\x3{\x5{\x701\n{\x3|\x3|\x3|\x3|\x3");
		sb.Append("|\x5|\x708\n|\x3}\x3}\x5}\x70C\n}\x3}\x3}\x5}\x710\n}\x3}\x3");
		sb.Append("}\x5}\x714\n}\x5}\x716\n}\x3~\x3~\x3~\x3~\x3\x7F\x3\x7F\x3\x7F");
		sb.Append("\x3\x7F\x3\x7F\x3\x80\x3\x80\x3\x80\x3\x81\x3\x81\x3\x81\x5");
		sb.Append("\x81\x727\n\x81\x3\x81\x3\x81\x5\x81\x72B\n\x81\x3\x81\x5\x81");
		sb.Append("\x72E\n\x81\x3\x81\x3\x81\x5\x81\x732\n\x81\x3\x81\x5\x81\x735");
		sb.Append("\n\x81\x3\x81\x3\x81\x3\x82\x3\x82\x3\x82\x3\x82\x3\x82\a\x82");
		sb.Append("\x73E\n\x82\f\x82\xE\x82\x741\v\x82\x3\x83\x3\x83\x3\x83\x3");
		sb.Append("\x83\a\x83\x747\n\x83\f\x83\xE\x83\x74A\v\x83\x3\x84\x3\x84");
		sb.Append("\x3\x84\x5\x84\x74F\n\x84\x5\x84\x751\n\x84\x3\x85\x3\x85\x3");
		sb.Append("\x85\x3\x86\x3\x86\x3\x86\x3\x86\x3\x86\x3\x87\x3\x87\x3\x87");
		sb.Append("\x3\x87\x3\x87\x3\x87\x3\x87\x3\x88\x3\x88\x3\x88\x3\x88\x5");
		sb.Append("\x88\x766\n\x88\x3\x89\x3\x89\x3\x89\a\x89\x76B\n\x89\f\x89");
		sb.Append("\xE\x89\x76E\v\x89\x3\x8A\x6\x8A\x771\n\x8A\r\x8A\xE\x8A\x772");
		sb.Append("\x3\x8B\x3\x8B\x3\x8B\x5\x8B\x778\n\x8B\x3\x8C\x3\x8C\x3\x8C");
		sb.Append("\x3\x8C\x3\x8C\x3\x8C\x5\x8C\x780\n\x8C\x3\x8C\x5\x8C\x783\n");
		sb.Append("\x8C\x3\x8D\x3\x8D\x3\x8D\x3\x8D\x3\x8D\a\x8D\x78A\n\x8D\f\x8D");
		sb.Append("\xE\x8D\x78D\v\x8D\x3\x8D\x3\x8D\x3\x8E\x3\x8E\x3\x8E\x3\x8E");
		sb.Append("\x5\x8E\x795\n\x8E\x3\x8E\x5\x8E\x798\n\x8E\x5\x8E\x79A\n\x8E");
		sb.Append("\x3\x8E\x5\x8E\x79D\n\x8E\x3\x8F\x3\x8F\x5\x8F\x7A1\n\x8F\x3");
		sb.Append("\x8F\x5\x8F\x7A4\n\x8F\x3\x8F\x5\x8F\x7A7\n\x8F\x3\x8F\x3\x8F");
		sb.Append("\x3\x90\x3\x90\x3\x90\x3\x90\a\x90\x7AF\n\x90\f\x90\xE\x90\x7B2");
		sb.Append("\v\x90\x3\x91\x3\x91\x3\x91\x3\x91\x3\x92\x3\x92\x3\x93\x3\x93");
		sb.Append("\x3\x93\x6\x93\x7BD\n\x93\r\x93\xE\x93\x7BE\x3\x93\x5\x93\x7C2");
		sb.Append("\n\x93\x3\x93\x3\x93\x3\x93\x3\x93\x3\x93\x3\x93\x3\x93\x6\x93");
		sb.Append("\x7CB\n\x93\r\x93\xE\x93\x7CC\x3\x93\x5\x93\x7D0\n\x93\x3\x93");
		sb.Append("\x3\x93\x3\x93\x3\x93\x5\x93\x7D6\n\x93\x3\x94\x3\x94\x3\x94");
		sb.Append("\a\x94\x7DB\n\x94\f\x94\xE\x94\x7DE\v\x94\x3\x95\x3\x95\x3\x95");
		sb.Append("\a\x95\x7E3\n\x95\f\x95\xE\x95\x7E6\v\x95\x3\x96\x3\x96\x3\x96");
		sb.Append("\a\x96\x7EB\n\x96\f\x96\xE\x96\x7EE\v\x96\x3\x97\x3\x97\x3\x97");
		sb.Append("\x5\x97\x7F3\n\x97\x3\x98\x3\x98\x3\x98\x3\x98\x3\x98\x3\x98");
		sb.Append("\x3\x98\x5\x98\x7FC\n\x98\x3\x98\x3\x98\x3\x98\x3\x98\x5\x98");
		sb.Append("\x802\n\x98\x3\x98\x3\x98\x5\x98\x806\n\x98\x3\x98\x3\x98\x5");
		sb.Append("\x98\x80A\n\x98\x5\x98\x80C\n\x98\a\x98\x80E\n\x98\f\x98\xE");
		sb.Append("\x98\x811\v\x98\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x5\x99\x818");
		sb.Append("\n\x99\x3\x99\x3\x99\x3\x99\x3\x99\x5\x99\x81E\n\x99\x3\x99");
		sb.Append("\x3\x99\x5\x99\x822\n\x99\x3\x99\x3\x99\x5\x99\x826\n\x99\x5");
		sb.Append("\x99\x828\n\x99\a\x99\x82A\n\x99\f\x99\xE\x99\x82D\v\x99\x3");
		sb.Append("\x99\x5\x99\x830\n\x99\x3\x99\x3\x99\x3\x99\x5\x99\x835\n\x99");
		sb.Append("\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\a\x99\x83C\n\x99\f\x99\xE");
		sb.Append("\x99\x83F\v\x99\x5\x99\x841\n\x99\x3\x99\x3\x99\x5\x99\x845");
		sb.Append("\n\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99");
		sb.Append("\x5\x99\x84F\n\x99\x3\x99\x3\x99\x5\x99\x853\n\x99\x5\x99\x855");
		sb.Append("\n\x99\x3\x9A\x3\x9A\x3\x9B\x3\x9B\x3\x9B\x3\x9B\x3\x9B\a\x9B");
		sb.Append("\x85E\n\x9B\f\x9B\xE\x9B\x861\v\x9B\x5\x9B\x863\n\x9B\x3\x9C");
		sb.Append("\x3\x9C\x3\x9C\a\x9C\x868\n\x9C\f\x9C\xE\x9C\x86B\v\x9C\x3\x9D");
		sb.Append("\x3\x9D\x3\x9D\a\x9D\x870\n\x9D\f\x9D\xE\x9D\x873\v\x9D\x3\x9E");
		sb.Append("\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x5\x9E\x87D");
		sb.Append("\n\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E");
		sb.Append("\x3\x9E\x3\x9E\a\x9E\x889\n\x9E\f\x9E\xE\x9E\x88C\v\x9E\x3\x9E");
		sb.Append("\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\a\x9E\x896");
		sb.Append("\n\x9E\f\x9E\xE\x9E\x899\v\x9E\x5\x9E\x89B\n\x9E\x3\x9E\x3\x9E");
		sb.Append("\x5\x9E\x89F\n\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9E\a\x9E");
		sb.Append("\x8A6\n\x9E\f\x9E\xE\x9E\x8A9\v\x9E\x3\x9E\x3\x9E\x5\x9E\x8AD");
		sb.Append("\n\x9E\x3\x9E\x5\x9E\x8B0\n\x9E\x3\x9F\x3\x9F\x5\x9F\x8B4\n");
		sb.Append("\x9F\x3\xA0\x3\xA0\x3\xA0\x3\xA0\a\xA0\x8BA\n\xA0\f\xA0\xE\xA0");
		sb.Append("\x8BD\v\xA0\x3\xA1\x3\xA1\x3\xA1\x5\xA1\x8C2\n\xA1\x3\xA2\x3");
		sb.Append("\xA2\x5\xA2\x8C6\n\xA2\x3\xA3\x3\xA3\x3\xA4\x3\xA4\x3\xA4\x3");
		sb.Append("\xA5\x3\xA5\x3\xA5\x5\xA5\x8D0\n\xA5\x3\xA5\x3\xA5\x3\xA5\x3");
		sb.Append("\xA5\x3\xA5\x5\xA5\x8D7\n\xA5\x3\xA5\x3\xA5\x3\xA5\x5\xA5\x8DC");
		sb.Append("\n\xA5\x3\xA5\x3\xA5\x5\xA5\x8E0\n\xA5\x3\xA5\x3\xA5\x3\xA6");
		sb.Append("\x3\xA6\x5\xA6\x8E6\n\xA6\x3\xA6\x3\xA6\x3\xA6\x5\xA6\x8EB\n");
		sb.Append("\xA6\x3\xA6\x3\xA6\x5\xA6\x8EF\n\xA6\x3\xA7\x3\xA7\x3\xA7\x3");
		sb.Append("\xA7\a\xA7\x8F5\n\xA7\f\xA7\xE\xA7\x8F8\v\xA7\x5\xA7\x8FA\n");
		sb.Append("\xA7\x3\xA7\x3\xA7\x5\xA7\x8FE\n\xA7\x3\xA8\x3\xA8\x3\xA8\x5");
		sb.Append("\xA8\x903\n\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x5");
		sb.Append("\xA8\x90B\n\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3");
		sb.Append("\xA8\x5\xA8\x914\n\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3");
		sb.Append("\xA8\x5\xA8\x91C\n\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3");
		sb.Append("\xA8\x5\xA8\x924\n\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3");
		sb.Append("\xA8\x5\xA8\x92C\n\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3");
		sb.Append("\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\a\xA8\x939\n\xA8\f\xA8");
		sb.Append("\xE\xA8\x93C\v\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8");
		sb.Append("\x3\xA8\x5\xA8\x945\n\xA8\x3\xA8\x3\xA8\x5\xA8\x949\n\xA8\x3");
		sb.Append("\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x5\xA8\x950\n\xA8\x3\xA8\x3");
		sb.Append("\xA8\x5\xA8\x954\n\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3");
		sb.Append("\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x5\xA8\x960\n\xA8\x3\xA8\x3");
		sb.Append("\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8");
		sb.Append("\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3");
		sb.Append("\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\a\xA8\x97A\n\xA8\f\xA8");
		sb.Append("\xE\xA8\x97D\v\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8");
		sb.Append("\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x5");
		sb.Append("\xA8\x98D\n\xA8\x3\xA8\x3\xA8\x5\xA8\x991\n\xA8\x3\xA8\x3\xA8");
		sb.Append("\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\x5\xA8\x99B\n\xA8");
		sb.Append("\x3\xA8\x5\xA8\x99E\n\xA8\x3\xA8\x3\xA8\x3\xA8\x5\xA8\x9A3\n");
		sb.Append("\xA8\x3\xA9\x3\xA9\x3\xA9\x5\xA9\x9A8\n\xA9\x3\xA9\x3\xA9\x5");
		sb.Append("\xA9\x9AC\n\xA9\x3\xA9\x3\xA9\x5\xA9\x9B0\n\xA9\x3\xAA\x3\xAA");
		sb.Append("\x5\xAA\x9B4\n\xAA\x3\xAB\x3\xAB\x3\xAB\a\xAB\x9B9\n\xAB\f\xAB");
		sb.Append("\xE\xAB\x9BC\v\xAB\x3\xAC\x3\xAC\x3\xAC\x3\xAC\x3\xAC\x5\xAC");
		sb.Append("\x9C3\n\xAC\x3\xAC\x3\xAC\x5\xAC\x9C7\n\xAC\x3\xAC\x5\xAC\x9CA");
		sb.Append("\n\xAC\x3\xAD\x3\xAD\x3\xAD\x5\xAD\x9CF\n\xAD\x3\xAD\x5\xAD");
		sb.Append("\x9D2\n\xAD\x3\xAE\x3\xAE\x3\xAE\x5\xAE\x9D7\n\xAE\x3\xAF\x3");
		sb.Append("\xAF\x3\xAF\x3\xAF\x5\xAF\x9DD\n\xAF\x3\xB0\x3\xB0\x3\xB0\x3");
		sb.Append("\xB0\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x5\xB0\x9E9\n");
		sb.Append("\xB0\x3\xB1\x5\xB1\x9EC\n\xB1\x3\xB1\x3\xB1\x3\xB1\a\xB1\x9F1");
		sb.Append("\n\xB1\f\xB1\xE\xB1\x9F4\v\xB1\x3\xB2\x5\xB2\x9F7\n\xB2\x3\xB2");
		sb.Append("\x3\xB2\x3\xB3\x3\xB3\x3\xB3\x3\xB3\x3\xB4\x3\xB4\x3\xB5\x3");
		sb.Append("\xB5\a\xB5\xA03\n\xB5\f\xB5\xE\xB5\xA06\v\xB5\x3\xB6\x3\xB6");
		sb.Append("\x3\xB6\x3\xB6\x3\xB6\x5\xB6\xA0D\n\xB6\x3\xB6\x3\xB6\x3\xB7");
		sb.Append("\x3\xB7\x3\xB7\a\xB7\xA14\n\xB7\f\xB7\xE\xB7\xA17\v\xB7\x3\xB8");
		sb.Append("\x3\xB8\x3\xB8\a\xB8\xA1C\n\xB8\f\xB8\xE\xB8\xA1F\v\xB8\x3\xB9");
		sb.Append("\x5\xB9\xA22\n\xB9\x3\xB9\x3\xB9\x3\xB9\x5\xB9\xA27\n\xB9\x3");
		sb.Append("\xBA\x3\xBA\x3\xBA\x3\xBA\x5\xBA\xA2D\n\xBA\x3\xBA\x5\xBA\xA30");
		sb.Append("\n\xBA\x5\xBA\xA32\n\xBA\x3\xBA\x3\xBA\x3\xBB\x3\xBB\x3\xBB");
		sb.Append("\x3\xBB\x3\xBB\x5\xBB\xA3B\n\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBB");
		sb.Append("\x5\xBB\xA41\n\xBB\x3\xBC\x3\xBC\x3\xBC\x3\xBC\a\xBC\xA47\n");
		sb.Append("\xBC\f\xBC\xE\xBC\xA4A\v\xBC\x3\xBC\x3\xBC\x3\xBD\x3\xBD\x3");
		sb.Append("\xBE\x3\xBE\x5\xBE\xA52\n\xBE\x3\xBF\x3\xBF\x3\xBF\x3\xBF\x5");
		sb.Append("\xBF\xA58\n\xBF\x3\xBF\x3\xBF\x5\xBF\xA5C\n\xBF\x3\xBF\x3\xBF");
		sb.Append("\x3\xC0\x3\xC0\x3\xC0\x3\xC0\x3\xC0\x5\xC0\xA65\n\xC0\x3\xC0");
		sb.Append("\x3\xC0\x3\xC1\x3\xC1\x3\xC1\x3\xC1\x3\xC2\x3\xC2\x3\xC2\x3");
		sb.Append("\xC2\x5\xC2\xA71\n\xC2\x5\xC2\xA73\n\xC2\x3\xC2\x3\xC2\x5\xC2");
		sb.Append("\xA77\n\xC2\x3\xC2\x3\xC2\x3\xC3\x3\xC3\x5\xC3\xA7D\n\xC3\x3");
		sb.Append("\xC3\x3\xC3\x3\xC3\x5\xC3\xA82\n\xC3\x3\xC3\x5\xC3\xA85\n\xC3");
		sb.Append("\x3\xC3\x5\xC3\xA88\n\xC3\x3\xC4\x3\xC4\a\xC4\xA8C\n\xC4\f\xC4");
		sb.Append("\xE\xC4\xA8F\v\xC4\x3\xC5\x3\xC5\x5\xC5\xA93\n\xC5\x3\xC5\x3");
		sb.Append("\xC5\x5\xC5\xA97\n\xC5\x3\xC5\x3\xC5\x5\xC5\xA9B\n\xC5\x3\xC5");
		sb.Append("\x3\xC5\x5\xC5\xA9F\n\xC5\x3\xC5\x3\xC5\x3\xC6\x3\xC6\x3\xC6");
		sb.Append("\x3\xC6\x3\xC7\x3\xC7\x3\xC7\a\xC7\xAAA\n\xC7\f\xC7\xE\xC7\xAAD");
		sb.Append("\v\xC7\x3\xC8\x3\xC8\x3\xC8\x3\xC8\x3\xC8\x5\xC8\xAB4\n\xC8");
		sb.Append("\x5\xC8\xAB6\n\xC8\x3\xC9\x3\xC9\x3\xC9\x3\xC9\x3\xC9\x5\xC9");
		sb.Append("\xABD\n\xC9\x3\xCA\x3\xCA\x3\xCA\x3\xCA\x3\xCA\x3\xCA\x3\xCB");
		sb.Append("\x3\xCB\x5\xCB\xAC7\n\xCB\x3\xCB\x3\xCB\x3\xCB\x5\xCB\xACC\n");
		sb.Append("\xCB\x3\xCB\x5\xCB\xACF\n\xCB\x3\xCB\x5\xCB\xAD2\n\xCB\x3\xCB");
		sb.Append("\x5\xCB\xAD5\n\xCB\x3\xCC\x3\xCC\x3\xCC\x3\xCC\x3\xCC\x3\xCC");
		sb.Append("\x5\xCC\xADD\n\xCC\x3\xCD\x3\xCD\x3\xCD\a\xCD\xAE2\n\xCD\f\xCD");
		sb.Append("\xE\xCD\xAE5\v\xCD\x3\xCE\x5\xCE\xAE8\n\xCE\x3\xCE\x3\xCE\x3");
		sb.Append("\xCE\a\xCE\xAED\n\xCE\f\xCE\xE\xCE\xAF0\v\xCE\x3\xCF\x3\xCF");
		sb.Append("\x3\xCF\a\xCF\xAF5\n\xCF\f\xCF\xE\xCF\xAF8\v\xCF\x3\xD0\x3\xD0");
		sb.Append("\x3\xD0\a\xD0\xAFD\n\xD0\f\xD0\xE\xD0\xB00\v\xD0\x3\xD1\x3\xD1");
		sb.Append("\x5\xD1\xB04\n\xD1\x3\xD2\x3\xD2\x5\xD2\xB08\n\xD2\x3\xD3\x3");
		sb.Append("\xD3\x3\xD3\x3\xD3\x3\xD3\x5\xD3\xB0F\n\xD3\x3\xD3\x5\xD3\xB12");
		sb.Append("\n\xD3\x3\xD4\x3\xD4\x3\xD4\x3\xD4\x3\xD4\x5\xD4\xB19\n\xD4");
		sb.Append("\x3\xD4\x5\xD4\xB1C\n\xD4\x3\xD5\x3\xD5\x3\xD5\a\xD5\xB21\n");
		sb.Append("\xD5\f\xD5\xE\xD5\xB24\v\xD5\x3\xD6\x3\xD6\x3\xD6\a\xD6\xB29");
		sb.Append("\n\xD6\f\xD6\xE\xD6\xB2C\v\xD6\x3\xD7\x3\xD7\x3\xD7\x3\xD7\x3");
		sb.Append("\xD7\x3\xD7\x3\xD7\x3\xD7\x3\xD7\x3\xD7\x5\xD7\xB38\n\xD7\x3");
		sb.Append("\xD8\x3\xD8\x5\xD8\xB3C\n\xD8\x3\xD9\x3\xD9\x3\xD9\x3\xD9\x3");
		sb.Append("\xD9\x3\xD9\x5\xD9\xB44\n\xD9\x3\xDA\x3\xDA\x3\xDB\x3\xDB\x3");
		sb.Append("\xDC\x3\xDC\x3\xDC\x3\xDC\x3\xDC\x5\xDC\xB4F\n\xDC\x3\xDD\x3");
		sb.Append("\xDD\x3\xDD\x5\xDD\xB54\n\xDD\x3\xDD\x3\xDD\x3\xDD\x3\xDD\x5");
		sb.Append("\xDD\xB5A\n\xDD\x3\xDE\x3\xDE\x3\xDE\x5\xDE\xB5F\n\xDE\x3\xDE");
		sb.Append("\x3\xDE\x3\xDF\x3\xDF\x3\xDF\x5\xDF\xB66\n\xDF\x3\xDF\x3\xDF");
		sb.Append("\x3\xE0\x3\xE0\x3\xE0\x3\xE0\a\xE0\xB6E\n\xE0\f\xE0\xE\xE0\xB71");
		sb.Append("\v\xE0\x3\xE0\x3\xE0\x3\xE1\x3\xE1\x3\xE1\x5\xE1\xB78\n\xE1");
		sb.Append("\x3\xE2\x3\xE2\x3\xE2\a\xE2\xB7D\n\xE2\f\xE2\xE\xE2\xB80\v\xE2");
		sb.Append("\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x5\xE3\xB87\n\xE3\x3\xE3");
		sb.Append("\x3\xE3\x3\xE3\x5\xE3\xB8C\n\xE3\x3\xE3\x3\xE3\x5\xE3\xB90\n");
		sb.Append("\xE3\x3\xE3\x5\xE3\xB93\n\xE3\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x5");
		sb.Append("\xE4\xB99\n\xE4\a\xE4\xB9B\n\xE4\f\xE4\xE\xE4\xB9E\v\xE4\x3");
		sb.Append("\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5");
		sb.Append("\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3");
		sb.Append("\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5");
		sb.Append("\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3");
		sb.Append("\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5");
		sb.Append("\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3\xE5\x3");
		sb.Append("\xE5\x5\xE5\xBD4\n\xE5\x3\xE6\x3\xE6\x3\xE6\x5\xE6\xBD9\n\xE6");
		sb.Append("\x3\xE7\x3\xE7\x5\xE7\xBDD\n\xE7\x3\xE8\x3\xE8\x5\xE8\xBE1\n");
		sb.Append("\xE8\x3\xE8\x5\xE8\xBE4\n\xE8\x3\xE8\x5\xE8\xBE7\n\xE8\x3\xE8");
		sb.Append("\x5\xE8\xBEA\n\xE8\x3\xE8\x5\xE8\xBED\n\xE8\x3\xE8\x5\xE8\xBF0");
		sb.Append("\n\xE8\x3\xE8\x5\xE8\xBF3\n\xE8\x3\xE8\x5\xE8\xBF6\n\xE8\x3");
		sb.Append("\xE8\x3\xE8\x5\xE8\xBFA\n\xE8\x3\xE8\x5\xE8\xBFD\n\xE8\x3\xE8");
		sb.Append("\x5\xE8\xC00\n\xE8\x3\xE8\x5\xE8\xC03\n\xE8\x3\xE8\x5\xE8\xC06");
		sb.Append("\n\xE8\x3\xE8\x5\xE8\xC09\n\xE8\x3\xE8\x5\xE8\xC0C\n\xE8\x3");
		sb.Append("\xE8\x3\xE8\x5\xE8\xC10\n\xE8\x3\xE8\x5\xE8\xC13\n\xE8\x3\xE8");
		sb.Append("\x5\xE8\xC16\n\xE8\x3\xE8\x5\xE8\xC19\n\xE8\x3\xE8\x5\xE8\xC1C");
		sb.Append("\n\xE8\x3\xE8\x5\xE8\xC1F\n\xE8\x3\xE8\x3\xE8\x5\xE8\xC23\n");
		sb.Append("\xE8\x3\xE8\x5\xE8\xC26\n\xE8\x3\xE8\x5\xE8\xC29\n\xE8\x3\xE8");
		sb.Append("\x5\xE8\xC2C\n\xE8\x3\xE8\x5\xE8\xC2F\n\xE8\x3\xE8\x3\xE8\x5");
		sb.Append("\xE8\xC33\n\xE8\x3\xE8\x5\xE8\xC36\n\xE8\x3\xE8\x5\xE8\xC39");
		sb.Append("\n\xE8\x3\xE8\x5\xE8\xC3C\n\xE8\x3\xE8\x3\xE8\x5\xE8\xC40\n");
		sb.Append("\xE8\x3\xE8\x5\xE8\xC43\n\xE8\x3\xE8\x5\xE8\xC46\n\xE8\x3\xE8");
		sb.Append("\x3\xE8\x5\xE8\xC4A\n\xE8\x3\xE8\x5\xE8\xC4D\n\xE8\x3\xE8\x3");
		sb.Append("\xE8\x5\xE8\xC51\n\xE8\x3\xE8\x5\xE8\xC54\n\xE8\x3\xE9\x3\xE9");
		sb.Append("\x3\xE9\x5\xE9\xC59\n\xE9\x3\xE9\x3\xE9\x3\xEA\x3\xEA\x3\xEA");
		sb.Append("\x5\xEA\xC60\n\xEA\x3\xEA\x3\xEA\x3\xEB\x3\xEB\x3\xEB\x5\xEB");
		sb.Append("\xC67\n\xEB\x3\xEB\x3\xEB\x3\xEC\x3\xEC\x3\xEC\x5\xEC\xC6E\n");
		sb.Append("\xEC\x3\xEC\x3\xEC\x3\xED\x3\xED\x3\xED\x5\xED\xC75\n\xED\x3");
		sb.Append("\xED\x3\xED\x3\xEE\x3\xEE\x3\xEE\x5\xEE\xC7C\n\xEE\x3\xEE\x3");
		sb.Append("\xEE\x3\xEF\x3\xEF\x3\xEF\x5\xEF\xC83\n\xEF\x3\xEF\x3\xEF\x3");
		sb.Append("\xF0\x3\xF0\x3\xF0\x5\xF0\xC8A\n\xF0\x3\xF0\x3\xF0\x3\xF1\x3");
		sb.Append("\xF1\x3\xF1\x5\xF1\xC91\n\xF1\x3\xF1\x3\xF1\x3\xF2\x3\xF2\x3");
		sb.Append("\xF3\x3\xF3\x3\xF3\x5\xF3\xC9A\n\xF3\x3\xF4\x3\xF4\x3\xF4\x3");
		sb.Append("\xF4\x3\xF4\x5\xF4\xCA1\n\xF4\x3\xF5\x3\xF5\x5\xF5\xCA5\n\xF5");
		sb.Append("\x3\xF5\x3\xF5\x3\xF6\x3\xF6\x5\xF6\xCAB\n\xF6\x3\xF7\x3\xF7");
		sb.Append("\x3\xF7\x5\xF7\xCB0\n\xF7\x3\xF8\x3\xF8\x3\xF8\x3\xF8\x3\xF9");
		sb.Append("\x3\xF9\x5\xF9\xCB8\n\xF9\x3\xF9\x3\xF9\x3\xFA\x3\xFA\x3\xFA");
		sb.Append("\a\xFA\xCBF\n\xFA\f\xFA\xE\xFA\xCC2\v\xFA\x3\xFA\x5\xFA\xCC5");
		sb.Append("\n\xFA\x3\xFB\x3\xFB\x3\xFB\a\xFB\xCCA\n\xFB\f\xFB\xE\xFB\xCCD");
		sb.Append("\v\xFB\x3\xFB\x5\xFB\xCD0\n\xFB\x3\xFC\x3\xFC\x5\xFC\xCD4\n");
		sb.Append("\xFC\x3\xFC\x3\xFC\x3\xFC\x3\xFC\x2\x2\xFD\x2\x4\x6\b\n\f\xE");
		sb.Append("\x10\x12\x14\x16\x18\x1A\x1C\x1E \"$&(*,.\x30\x32\x34\x36\x38");
		sb.Append(":<>@\x42\x44\x46HJLNPRTVXZ\\^`\x62\x64\x66hjlnprtvxz|~\x80\x82");
		sb.Append("\x84\x86\x88\x8A\x8C\x8E\x90\x92\x94\x96\x98\x9A\x9C\x9E\xA0");
		sb.Append("\xA2\xA4\xA6\xA8\xAA\xAC\xAE\xB0\xB2\xB4\xB6\xB8\xBA\xBC\xBE");
		sb.Append("\xC0\xC2\xC4\xC6\xC8\xCA\xCC\xCE\xD0\xD2\xD4\xD6\xD8\xDA\xDC");
		sb.Append("\xDE\xE0\xE2\xE4\xE6\xE8\xEA\xEC\xEE\xF0\xF2\xF4\xF6\xF8\xFA");
		sb.Append("\xFC\xFE\x100\x102\x104\x106\x108\x10A\x10C\x10E\x110\x112\x114");
		sb.Append("\x116\x118\x11A\x11C\x11E\x120\x122\x124\x126\x128\x12A\x12C");
		sb.Append("\x12E\x130\x132\x134\x136\x138\x13A\x13C\x13E\x140\x142\x144");
		sb.Append("\x146\x148\x14A\x14C\x14E\x150\x152\x154\x156\x158\x15A\x15C");
		sb.Append("\x15E\x160\x162\x164\x166\x168\x16A\x16C\x16E\x170\x172\x174");
		sb.Append("\x176\x178\x17A\x17C\x17E\x180\x182\x184\x186\x188\x18A\x18C");
		sb.Append("\x18E\x190\x192\x194\x196\x198\x19A\x19C\x19E\x1A0\x1A2\x1A4");
		sb.Append("\x1A6\x1A8\x1AA\x1AC\x1AE\x1B0\x1B2\x1B4\x1B6\x1B8\x1BA\x1BC");
		sb.Append("\x1BE\x1C0\x1C2\x1C4\x1C6\x1C8\x1CA\x1CC\x1CE\x1D0\x1D2\x1D4");
		sb.Append("\x1D6\x1D8\x1DA\x1DC\x1DE\x1E0\x1E2\x1E4\x1E6\x1E8\x1EA\x1EC");
		sb.Append("\x1EE\x1F0\x1F2\x1F4\x1F6\x2\x15\x3\x2\x8D\x8E\x4\x2\x8F\x8F");
		sb.Append("\x98\x98\x4\x2\v\v\x99\x99\x3\x2\x86\x87\x5\x2\xAE\xAE\xB0\xB0");
		sb.Append("\xB3\xB3\x4\x2\xA0\xA0\xA3\xA3\x5\x2\x9E\x9E\xA6\xA6\xA8\xA8");
		sb.Append("\x3\x2,-\x4\x2\x10\x10\x99\x99\x3\x2XY\x3\x2Z[\x3\x2\\]\x3\x2");
		sb.Append("^_\x3\x2`\x61\x4\x2\x14\x14\x62\x63\x3\x2\x64\x66\x3\x2gi\x3");
		sb.Append("\x2jl\x3\x2\xC6\xC7\xE83\x2\x1FC\x3\x2\x2\x2\x4\x206\x3\x2\x2");
		sb.Append("\x2\x6\x20C\x3\x2\x2\x2\b\x20F\x3\x2\x2\x2\n\x212\x3\x2\x2\x2");
		sb.Append("\f\x22E\x3\x2\x2\x2\xE\x23C\x3\x2\x2\x2\x10\x243\x3\x2\x2\x2");
		sb.Append("\x12\x247\x3\x2\x2\x2\x14\x24D\x3\x2\x2\x2\x16\x257\x3\x2\x2");
		sb.Append("\x2\x18\x25F\x3\x2\x2\x2\x1A\x268\x3\x2\x2\x2\x1C\x26A\x3\x2");
		sb.Append("\x2\x2\x1E\x27B\x3\x2\x2\x2 \x290\x3\x2\x2\x2\"\x295\x3\x2\x2");
		sb.Append("\x2$\x2BE\x3\x2\x2\x2&\x2D3\x3\x2\x2\x2(\x2DA\x3\x2\x2\x2*\x2DE");
		sb.Append("\x3\x2\x2\x2,\x2EA\x3\x2\x2\x2.\x2FF\x3\x2\x2\x2\x30\x301\x3");
		sb.Append("\x2\x2\x2\x32\x30C\x3\x2\x2\x2\x34\x31D\x3\x2\x2\x2\x36\x329");
		sb.Append("\x3\x2\x2\x2\x38\x32C\x3\x2\x2\x2:\x33F\x3\x2\x2\x2<\x365\x3");
		sb.Append("\x2\x2\x2>\x372\x3\x2\x2\x2@\x37D\x3\x2\x2\x2\x42\x384\x3\x2");
		sb.Append("\x2\x2\x44\x389\x3\x2\x2\x2\x46\x38F\x3\x2\x2\x2H\x392\x3\x2");
		sb.Append("\x2\x2J\x39F\x3\x2\x2\x2L\x3A1\x3\x2\x2\x2N\x3A8\x3\x2\x2\x2");
		sb.Append("P\x3C7\x3\x2\x2\x2R\x3CB\x3\x2\x2\x2T\x3D7\x3\x2\x2\x2V\x3DF");
		sb.Append("\x3\x2\x2\x2X\x3E3\x3\x2\x2\x2Z\x3F5\x3\x2\x2\x2\\\x3FF\x3\x2");
		sb.Append("\x2\x2^\x407\x3\x2\x2\x2`\x41A\x3\x2\x2\x2\x62\x422\x3\x2\x2");
		sb.Append("\x2\x64\x42A\x3\x2\x2\x2\x66\x436\x3\x2\x2\x2h\x448\x3\x2\x2");
		sb.Append("\x2j\x44A\x3\x2\x2\x2l\x450\x3\x2\x2\x2n\x463\x3\x2\x2\x2p\x46F");
		sb.Append("\x3\x2\x2\x2r\x472\x3\x2\x2\x2t\x479\x3\x2\x2\x2v\x481\x3\x2");
		sb.Append("\x2\x2x\x4A3\x3\x2\x2\x2z\x4A5\x3\x2\x2\x2|\x4A9\x3\x2\x2\x2");
		sb.Append("~\x4B3\x3\x2\x2\x2\x80\x4B8\x3\x2\x2\x2\x82\x4BF\x3\x2\x2\x2");
		sb.Append("\x84\x4C2\x3\x2\x2\x2\x86\x4CB\x3\x2\x2\x2\x88\x4CF\x3\x2\x2");
		sb.Append("\x2\x8A\x4DC\x3\x2\x2\x2\x8C\x4DE\x3\x2\x2\x2\x8E\x4E2\x3\x2");
		sb.Append("\x2\x2\x90\x4F7\x3\x2\x2\x2\x92\x4F9\x3\x2\x2\x2\x94\x501\x3");
		sb.Append("\x2\x2\x2\x96\x50F\x3\x2\x2\x2\x98\x511\x3\x2\x2\x2\x9A\x55E");
		sb.Append("\x3\x2\x2\x2\x9C\x560\x3\x2\x2\x2\x9E\x570\x3\x2\x2\x2\xA0\x572");
		sb.Append("\x3\x2\x2\x2\xA2\x579\x3\x2\x2\x2\xA4\x584\x3\x2\x2\x2\xA6\x588");
		sb.Append("\x3\x2\x2\x2\xA8\x590\x3\x2\x2\x2\xAA\x593\x3\x2\x2\x2\xAC\x59D");
		sb.Append("\x3\x2\x2\x2\xAE\x59F\x3\x2\x2\x2\xB0\x5A5\x3\x2\x2\x2\xB2\x5B0");
		sb.Append("\x3\x2\x2\x2\xB4\x5B8\x3\x2\x2\x2\xB6\x5C1\x3\x2\x2\x2\xB8\x5C4");
		sb.Append("\x3\x2\x2\x2\xBA\x5D4\x3\x2\x2\x2\xBC\x5DB\x3\x2\x2\x2\xBE\x5E4");
		sb.Append("\x3\x2\x2\x2\xC0\x5E8\x3\x2\x2\x2\xC2\x5ED\x3\x2\x2\x2\xC4\x5F4");
		sb.Append("\x3\x2\x2\x2\xC6\x5FF\x3\x2\x2\x2\xC8\x601\x3\x2\x2\x2\xCA\x60B");
		sb.Append("\x3\x2\x2\x2\xCC\x60E\x3\x2\x2\x2\xCE\x619\x3\x2\x2\x2\xD0\x62A");
		sb.Append("\x3\x2\x2\x2\xD2\x633\x3\x2\x2\x2\xD4\x63E\x3\x2\x2\x2\xD6\x64F");
		sb.Append("\x3\x2\x2\x2\xD8\x66E\x3\x2\x2\x2\xDA\x670\x3\x2\x2\x2\xDC\x676");
		sb.Append("\x3\x2\x2\x2\xDE\x67C\x3\x2\x2\x2\xE0\x685\x3\x2\x2\x2\xE2\x690");
		sb.Append("\x3\x2\x2\x2\xE4\x692\x3\x2\x2\x2\xE6\x69E\x3\x2\x2\x2\xE8\x6AD");
		sb.Append("\x3\x2\x2\x2\xEA\x6BC\x3\x2\x2\x2\xEC\x6BE\x3\x2\x2\x2\xEE\x6C6");
		sb.Append("\x3\x2\x2\x2\xF0\x6CB\x3\x2\x2\x2\xF2\x6CE\x3\x2\x2\x2\xF4\x6F7");
		sb.Append("\x3\x2\x2\x2\xF6\x702\x3\x2\x2\x2\xF8\x70B\x3\x2\x2\x2\xFA\x717");
		sb.Append("\x3\x2\x2\x2\xFC\x71B\x3\x2\x2\x2\xFE\x720\x3\x2\x2\x2\x100");
		sb.Append("\x723\x3\x2\x2\x2\x102\x738\x3\x2\x2\x2\x104\x742\x3\x2\x2\x2");
		sb.Append("\x106\x74B\x3\x2\x2\x2\x108\x752\x3\x2\x2\x2\x10A\x755\x3\x2");
		sb.Append("\x2\x2\x10C\x75A\x3\x2\x2\x2\x10E\x761\x3\x2\x2\x2\x110\x767");
		sb.Append("\x3\x2\x2\x2\x112\x770\x3\x2\x2\x2\x114\x777\x3\x2\x2\x2\x116");
		sb.Append("\x779\x3\x2\x2\x2\x118\x784\x3\x2\x2\x2\x11A\x790\x3\x2\x2\x2");
		sb.Append("\x11C\x79E\x3\x2\x2\x2\x11E\x7AA\x3\x2\x2\x2\x120\x7B3\x3\x2");
		sb.Append("\x2\x2\x122\x7B7\x3\x2\x2\x2\x124\x7D5\x3\x2\x2\x2\x126\x7D7");
		sb.Append("\x3\x2\x2\x2\x128\x7DF\x3\x2\x2\x2\x12A\x7E7\x3\x2\x2\x2\x12C");
		sb.Append("\x7F2\x3\x2\x2\x2\x12E\x7F4\x3\x2\x2\x2\x130\x812\x3\x2\x2\x2");
		sb.Append("\x132\x856\x3\x2\x2\x2\x134\x858\x3\x2\x2\x2\x136\x864\x3\x2");
		sb.Append("\x2\x2\x138\x86C\x3\x2\x2\x2\x13A\x8AF\x3\x2\x2\x2\x13C\x8B1");
		sb.Append("\x3\x2\x2\x2\x13E\x8B5\x3\x2\x2\x2\x140\x8BE\x3\x2\x2\x2\x142");
		sb.Append("\x8C3\x3\x2\x2\x2\x144\x8C7\x3\x2\x2\x2\x146\x8C9\x3\x2\x2\x2");
		sb.Append("\x148\x8CC\x3\x2\x2\x2\x14A\x8E3\x3\x2\x2\x2\x14C\x8F0\x3\x2");
		sb.Append("\x2\x2\x14E\x9A2\x3\x2\x2\x2\x150\x9A7\x3\x2\x2\x2\x152\x9B3");
		sb.Append("\x3\x2\x2\x2\x154\x9B5\x3\x2\x2\x2\x156\x9C2\x3\x2\x2\x2\x158");
		sb.Append("\x9CB\x3\x2\x2\x2\x15A\x9D6\x3\x2\x2\x2\x15C\x9DC\x3\x2\x2\x2");
		sb.Append("\x15E\x9E8\x3\x2\x2\x2\x160\x9EB\x3\x2\x2\x2\x162\x9F6\x3\x2");
		sb.Append("\x2\x2\x164\x9FA\x3\x2\x2\x2\x166\x9FE\x3\x2\x2\x2\x168\xA00");
		sb.Append("\x3\x2\x2\x2\x16A\xA0C\x3\x2\x2\x2\x16C\xA10\x3\x2\x2\x2\x16E");
		sb.Append("\xA18\x3\x2\x2\x2\x170\xA21\x3\x2\x2\x2\x172\xA31\x3\x2\x2\x2");
		sb.Append("\x174\xA3A\x3\x2\x2\x2\x176\xA42\x3\x2\x2\x2\x178\xA4D\x3\x2");
		sb.Append("\x2\x2\x17A\xA51\x3\x2\x2\x2\x17C\xA53\x3\x2\x2\x2\x17E\xA5F");
		sb.Append("\x3\x2\x2\x2\x180\xA68\x3\x2\x2\x2\x182\xA6C\x3\x2\x2\x2\x184");
		sb.Append("\xA7C\x3\x2\x2\x2\x186\xA89\x3\x2\x2\x2\x188\xA90\x3\x2\x2\x2");
		sb.Append("\x18A\xAA2\x3\x2\x2\x2\x18C\xAA6\x3\x2\x2\x2\x18E\xAB5\x3\x2");
		sb.Append("\x2\x2\x190\xAB7\x3\x2\x2\x2\x192\xABE\x3\x2\x2\x2\x194\xAC6");
		sb.Append("\x3\x2\x2\x2\x196\xAD6\x3\x2\x2\x2\x198\xADE\x3\x2\x2\x2\x19A");
		sb.Append("\xAE7\x3\x2\x2\x2\x19C\xAF1\x3\x2\x2\x2\x19E\xAF9\x3\x2\x2\x2");
		sb.Append("\x1A0\xB03\x3\x2\x2\x2\x1A2\xB07\x3\x2\x2\x2\x1A4\xB09\x3\x2");
		sb.Append("\x2\x2\x1A6\xB13\x3\x2\x2\x2\x1A8\xB1D\x3\x2\x2\x2\x1AA\xB25");
		sb.Append("\x3\x2\x2\x2\x1AC\xB37\x3\x2\x2\x2\x1AE\xB3B\x3\x2\x2\x2\x1B0");
		sb.Append("\xB3D\x3\x2\x2\x2\x1B2\xB45\x3\x2\x2\x2\x1B4\xB47\x3\x2\x2\x2");
		sb.Append("\x1B6\xB49\x3\x2\x2\x2\x1B8\xB53\x3\x2\x2\x2\x1BA\xB5E\x3\x2");
		sb.Append("\x2\x2\x1BC\xB65\x3\x2\x2\x2\x1BE\xB69\x3\x2\x2\x2\x1C0\xB77");
		sb.Append("\x3\x2\x2\x2\x1C2\xB79\x3\x2\x2\x2\x1C4\xB81\x3\x2\x2\x2\x1C6");
		sb.Append("\xB94\x3\x2\x2\x2\x1C8\xBD3\x3\x2\x2\x2\x1CA\xBD8\x3\x2\x2\x2");
		sb.Append("\x1CC\xBDC\x3\x2\x2\x2\x1CE\xC53\x3\x2\x2\x2\x1D0\xC58\x3\x2");
		sb.Append("\x2\x2\x1D2\xC5F\x3\x2\x2\x2\x1D4\xC66\x3\x2\x2\x2\x1D6\xC6D");
		sb.Append("\x3\x2\x2\x2\x1D8\xC74\x3\x2\x2\x2\x1DA\xC7B\x3\x2\x2\x2\x1DC");
		sb.Append("\xC82\x3\x2\x2\x2\x1DE\xC89\x3\x2\x2\x2\x1E0\xC90\x3\x2\x2\x2");
		sb.Append("\x1E2\xC94\x3\x2\x2\x2\x1E4\xC96\x3\x2\x2\x2\x1E6\xCA0\x3\x2");
		sb.Append("\x2\x2\x1E8\xCA4\x3\x2\x2\x2\x1EA\xCAA\x3\x2\x2\x2\x1EC\xCAF");
		sb.Append("\x3\x2\x2\x2\x1EE\xCB1\x3\x2\x2\x2\x1F0\xCB5\x3\x2\x2\x2\x1F2");
		sb.Append("\xCBB\x3\x2\x2\x2\x1F4\xCC6\x3\x2\x2\x2\x1F6\xCD3\x3\x2\x2\x2");
		sb.Append("\x1F8\x1FB\x5\x14\v\x2\x1F9\x1FB\x5\n\x6\x2\x1FA\x1F8\x3\x2");
		sb.Append("\x2\x2\x1FA\x1F9\x3\x2\x2\x2\x1FB\x1FE\x3\x2\x2\x2\x1FC\x1FA");
		sb.Append("\x3\x2\x2\x2\x1FC\x1FD\x3\x2\x2\x2\x1FD\x1FF\x3\x2\x2\x2\x1FE");
		sb.Append("\x1FC\x3\x2\x2\x2\x1FF\x200\x5\x166\xB4\x2\x200\x201\a\x2\x2");
		sb.Append("\x3\x201\x3\x3\x2\x2\x2\x202\x205\x5\x14\v\x2\x203\x205\x5\n");
		sb.Append("\x6\x2\x204\x202\x3\x2\x2\x2\x204\x203\x3\x2\x2\x2\x205\x208");
		sb.Append("\x3\x2\x2\x2\x206\x204\x3\x2\x2\x2\x206\x207\x3\x2\x2\x2\x207");
		sb.Append("\x209\x3\x2\x2\x2\x208\x206\x3\x2\x2\x2\x209\x20A\x5\x1E\x10");
		sb.Append("\x2\x20A\x20B\a\x2\x2\x3\x20B\x5\x3\x2\x2\x2\x20C\x20D\x5\x1C2");
		sb.Append("\xE2\x2\x20D\x20E\a\x2\x2\x3\x20E\a\x3\x2\x2\x2\x20F\x210\x5");
		sb.Append("\x1EC\xF7\x2\x210\x211\a\x2\x2\x3\x211\t\x3\x2\x2\x2\x212\x214");
		sb.Append("\a\x7F\x2\x2\x213\x215\x5\x198\xCD\x2\x214\x213\x3\x2\x2\x2");
		sb.Append("\x214\x215\x3\x2\x2\x2\x215\x218\x3\x2\x2\x2\x216\x217\a\x94");
		sb.Append("\x2\x2\x217\x219\a\x95\x2\x2\x218\x216\x3\x2\x2\x2\x218\x219");
		sb.Append("\x3\x2\x2\x2\x219\x21B\x3\x2\x2\x2\x21A\x21C\x5\x192\xCA\x2");
		sb.Append("\x21B\x21A\x3\x2\x2\x2\x21B\x21C\x3\x2\x2\x2\x21C\x21E\x3\x2");
		sb.Append("\x2\x2\x21D\x21F\x5\f\a\x2\x21E\x21D\x3\x2\x2\x2\x21E\x21F\x3");
		sb.Append("\x2\x2\x2\x21F\x220\x3\x2\x2\x2\x220\x226\a\xC5\x2\x2\x221\x223");
		sb.Append("\a\x92\x2\x2\x222\x224\x5\xB2Z\x2\x223\x222\x3\x2\x2\x2\x223");
		sb.Append("\x224\x3\x2\x2\x2\x224\x225\x3\x2\x2\x2\x225\x227\a\x93\x2\x2");
		sb.Append("\x226\x221\x3\x2\x2\x2\x226\x227\x3\x2\x2\x2\x227\x22A\x3\x2");
		sb.Append("\x2\x2\x228\x229\a\xC5\x2\x2\x229\x22B\az\x2\x2\x22A\x228\x3");
		sb.Append("\x2\x2\x2\x22A\x22B\x3\x2\x2\x2\x22B\x22C\x3\x2\x2\x2\x22C\x22D");
		sb.Append("\x5\xE\b\x2\x22D\v\x3\x2\x2\x2\x22E\x22F\a\xC5\x2\x2\x22F\x230");
		sb.Append("\a\x98\x2\x2\x230\r\x3\x2\x2\x2\x231\x233\a\x96\x2\x2\x232\x234");
		sb.Append("\x5\x10\t\x2\x233\x232\x3\x2\x2\x2\x233\x234\x3\x2\x2\x2\x234");
		sb.Append("\x235\x3\x2\x2\x2\x235\x236\x5\x122\x92\x2\x236\x237\a\x97\x2");
		sb.Append("\x2\x237\x23D\x3\x2\x2\x2\x238\x239\a\x94\x2\x2\x239\x23A\x5");
		sb.Append("\x1EA\xF6\x2\x23A\x23B\a\x95\x2\x2\x23B\x23D\x3\x2\x2\x2\x23C");
		sb.Append("\x231\x3\x2\x2\x2\x23C\x238\x3\x2\x2\x2\x23D\xF\x3\x2\x2\x2");
		sb.Append("\x23E\x244\a\xC5\x2\x2\x23F\x240\a\x92\x2\x2\x240\x241\x5\xB2");
		sb.Append("Z\x2\x241\x242\a\x93\x2\x2\x242\x244\x3\x2\x2\x2\x243\x23E\x3");
		sb.Append("\x2\x2\x2\x243\x23F\x3\x2\x2\x2\x244\x245\x3\x2\x2\x2\x245\x246");
		sb.Append("\t\x2\x2\x2\x246\x11\x3\x2\x2\x2\x247\x248\a\xBD\x2\x2\x248");
		sb.Append("\x249\a\xC5\x2\x2\x249\x24A\a\x92\x2\x2\x24A\x24B\a\xC5\x2\x2");
		sb.Append("\x24B\x24C\a\x93\x2\x2\x24C\x13\x3\x2\x2\x2\x24D\x24E\a\xBD");
		sb.Append("\x2\x2\x24E\x255\x5\x198\xCD\x2\x24F\x252\a\x92\x2\x2\x250\x253");
		sb.Append("\x5\x16\f\x2\x251\x253\x5\x1A\xE\x2\x252\x250\x3\x2\x2\x2\x252");
		sb.Append("\x251\x3\x2\x2\x2\x252\x253\x3\x2\x2\x2\x253\x254\x3\x2\x2\x2");
		sb.Append("\x254\x256\a\x93\x2\x2\x255\x24F\x3\x2\x2\x2\x255\x256\x3\x2");
		sb.Append("\x2\x2\x256\x15\x3\x2\x2\x2\x257\x25C\x5\x18\r\x2\x258\x259");
		sb.Append("\a\x99\x2\x2\x259\x25B\x5\x18\r\x2\x25A\x258\x3\x2\x2\x2\x25B");
		sb.Append("\x25E\x3\x2\x2\x2\x25C\x25A\x3\x2\x2\x2\x25C\x25D\x3\x2\x2\x2");
		sb.Append("\x25D\x17\x3\x2\x2\x2\x25E\x25C\x3\x2\x2\x2\x25F\x260\x5\x1C8");
		sb.Append("\xE5\x2\x260\x261\a\x8F\x2\x2\x261\x262\x5\x1A\xE\x2\x262\x19");
		sb.Append("\x3\x2\x2\x2\x263\x269\x5\x14\v\x2\x264\x269\x5\x1C\xF\x2\x265");
		sb.Append("\x269\x5\x1E6\xF4\x2\x266\x269\a\xC5\x2\x2\x267\x269\x5\x198");
		sb.Append("\xCD\x2\x268\x263\x3\x2\x2\x2\x268\x264\x3\x2\x2\x2\x268\x265");
		sb.Append("\x3\x2\x2\x2\x268\x266\x3\x2\x2\x2\x268\x267\x3\x2\x2\x2\x269");
		sb.Append("\x1B\x3\x2\x2\x2\x26A\x273\a\x96\x2\x2\x26B\x270\x5\x1A\xE\x2");
		sb.Append("\x26C\x26D\a\x99\x2\x2\x26D\x26F\x5\x1A\xE\x2\x26E\x26C\x3\x2");
		sb.Append("\x2\x2\x26F\x272\x3\x2\x2\x2\x270\x26E\x3\x2\x2\x2\x270\x271");
		sb.Append("\x3\x2\x2\x2\x271\x274\x3\x2\x2\x2\x272\x270\x3\x2\x2\x2\x273");
		sb.Append("\x26B\x3\x2\x2\x2\x273\x274\x3\x2\x2\x2\x274\x276\x3\x2\x2\x2");
		sb.Append("\x275\x277\a\x99\x2\x2\x276\x275\x3\x2\x2\x2\x276\x277\x3\x2");
		sb.Append("\x2\x2\x277\x278\x3\x2\x2\x2\x278\x279\a\x97\x2\x2\x279\x1D");
		sb.Append("\x3\x2\x2\x2\x27A\x27C\x5 \x11\x2\x27B\x27A\x3\x2\x2\x2\x27B");
		sb.Append("\x27C\x3\x2\x2\x2\x27C\x28B\x3\x2\x2\x2\x27D\x28C\x5\"\x12\x2");
		sb.Append("\x27E\x28C\x5N(\x2\x27F\x28C\x5R*\x2\x280\x28C\x5X-\x2\x281");
		sb.Append("\x28C\x5Z.\x2\x282\x28C\x5j\x36\x2\x283\x28C\x5\x92J\x2\x284");
		sb.Append("\x28C\x5\x94K\x2\x285\x28C\x5$\x13\x2\x286\x28C\x5(\x15\x2\x287");
		sb.Append("\x28C\x5t;\x2\x288\x28C\x5n\x38\x2\x289\x28C\x5p\x39\x2\x28A");
		sb.Append("\x28C\x5r:\x2\x28B\x27D\x3\x2\x2\x2\x28B\x27E\x3\x2\x2\x2\x28B");
		sb.Append("\x27F\x3\x2\x2\x2\x28B\x280\x3\x2\x2\x2\x28B\x281\x3\x2\x2\x2");
		sb.Append("\x28B\x282\x3\x2\x2\x2\x28B\x283\x3\x2\x2\x2\x28B\x284\x3\x2");
		sb.Append("\x2\x2\x28B\x285\x3\x2\x2\x2\x28B\x286\x3\x2\x2\x2\x28B\x287");
		sb.Append("\x3\x2\x2\x2\x28B\x288\x3\x2\x2\x2\x28B\x289\x3\x2\x2\x2\x28B");
		sb.Append("\x28A\x3\x2\x2\x2\x28C\x28E\x3\x2\x2\x2\x28D\x28F\x5\xD0i\x2");
		sb.Append("\x28E\x28D\x3\x2\x2\x2\x28E\x28F\x3\x2\x2\x2\x28F\x1F\x3\x2");
		sb.Append("\x2\x2\x290\x291\a\x82\x2\x2\x291\x292\a\xC5\x2\x2\x292!\x3");
		sb.Append("\x2\x2\x2\x293\x294\a\x35\x2\x2\x294\x296\x5\xAEX\x2\x295\x293");
		sb.Append("\x3\x2\x2\x2\x295\x296\x3\x2\x2\x2\x296\x299\x3\x2\x2\x2\x297");
		sb.Append("\x298\a\x34\x2\x2\x298\x29A\x5\xB0Y\x2\x299\x297\x3\x2\x2\x2");
		sb.Append("\x299\x29A\x3\x2\x2\x2\x29A\x29B\x3\x2\x2\x2\x29B\x29C\a\x1A");
		sb.Append("\x2\x2\x29C\x29F\x5\xC2\x62\x2\x29D\x29E\a \x2\x2\x29E\x2A0");
		sb.Append("\x5\xB4[\x2\x29F\x29D\x3\x2\x2\x2\x29F\x2A0\x3\x2\x2\x2\x2A0");
		sb.Append("\x2A2\x3\x2\x2\x2\x2A1\x2A3\x5\x100\x81\x2\x2A2\x2A1\x3\x2\x2");
		sb.Append("\x2\x2A2\x2A3\x3\x2\x2\x2\x2A3\x2A6\x3\x2\x2\x2\x2A4\x2A5\a");
		sb.Append("\xF\x2\x2\x2A5\x2A7\x5\xC0\x61\x2\x2A6\x2A4\x3\x2\x2\x2\x2A6");
		sb.Append("\x2A7\x3\x2\x2\x2\x2A7\x2AB\x3\x2\x2\x2\x2A8\x2A9\a*\x2\x2\x2A9");
		sb.Append("\x2AA\a)\x2\x2\x2AA\x2AC\x5\xE0q\x2\x2AB\x2A8\x3\x2\x2\x2\x2AB");
		sb.Append("\x2AC\x3\x2\x2\x2\x2AC\x2AF\x3\x2\x2\x2\x2AD\x2AE\a+\x2\x2\x2AE");
		sb.Append("\x2B0\x5\xF0y\x2\x2AF\x2AD\x3\x2\x2\x2\x2AF\x2B0\x3\x2\x2\x2");
		sb.Append("\x2B0\x2B3\x3\x2\x2\x2\x2B1\x2B2\a\x30\x2\x2\x2B2\x2B4\x5\xF2");
		sb.Append("z\x2\x2B3\x2B1\x3\x2\x2\x2\x2B3\x2B4\x3\x2\x2\x2\x2B4\x2B8\x3");
		sb.Append("\x2\x2\x2\x2B5\x2B6\a\x37\x2\x2\x2B6\x2B7\a)\x2\x2\x2B7\x2B9");
		sb.Append("\x5\xECw\x2\x2B8\x2B5\x3\x2\x2\x2\x2B8\x2B9\x3\x2\x2\x2\x2B9");
		sb.Append("\x2BC\x3\x2\x2\x2\x2BA\x2BB\ap\x2\x2\x2BB\x2BD\x5\xF8}\x2\x2BC");
		sb.Append("\x2BA\x3\x2\x2\x2\x2BC\x2BD\x3\x2\x2\x2\x2BD#\x3\x2\x2\x2\x2BE");
		sb.Append("\x2BF\a\'\x2\x2\x2BF\x2CF\x5&\x14\x2\x2C0\x2D0\x5\x44#\x2\x2C1");
		sb.Append("\x2CA\x5:\x1E\x2\x2C2\x2C4\x5> \x2\x2C3\x2C2\x3\x2\x2\x2\x2C4");
		sb.Append("\x2C5\x3\x2\x2\x2\x2C5\x2C3\x3\x2\x2\x2\x2C5\x2C6\x3\x2\x2\x2");
		sb.Append("\x2C6\x2C8\x3\x2\x2\x2\x2C7\x2C9\x5\x42\"\x2\x2C8\x2C7\x3\x2");
		sb.Append("\x2\x2\x2C8\x2C9\x3\x2\x2\x2\x2C9\x2CB\x3\x2\x2\x2\x2CA\x2C3");
		sb.Append("\x3\x2\x2\x2\x2CA\x2CB\x3\x2\x2\x2\x2CB\x2D0\x3\x2\x2\x2\x2CC");
		sb.Append("\x2D0\x5\x46$\x2\x2CD\x2D0\x5<\x1F\x2\x2CE\x2D0\x5,\x17\x2\x2CF");
		sb.Append("\x2C0\x3\x2\x2\x2\x2CF\x2C1\x3\x2\x2\x2\x2CF\x2CC\x3\x2\x2\x2");
		sb.Append("\x2CF\x2CD\x3\x2\x2\x2\x2CF\x2CE\x3\x2\x2\x2\x2D0%\x3\x2\x2");
		sb.Append("\x2\x2D1\x2D4\x5\x184\xC3\x2\x2D2\x2D4\x5\xD2j\x2\x2D3\x2D1");
		sb.Append("\x3\x2\x2\x2\x2D3\x2D2\x3\x2\x2\x2\x2D4\x2D8\x3\x2\x2\x2\x2D5");
		sb.Append("\x2D6\a\x10\x2\x2\x2D6\x2D9\a\xC5\x2\x2\x2D7\x2D9\a\xC5\x2\x2");
		sb.Append("\x2D8\x2D5\x3\x2\x2\x2\x2D8\x2D7\x3\x2\x2\x2\x2D8\x2D9\x3\x2");
		sb.Append("\x2\x2\x2D9\'\x3\x2\x2\x2\x2DA\x2DB\ar\x2\x2\x2DB\x2DC\a;\x2");
		sb.Append("\x2\x2DC\x2DD\x5*\x16\x2\x2DD)\x3\x2\x2\x2\x2DE\x2E2\x5\x198");
		sb.Append("\xCD\x2\x2DF\x2E0\a\x10\x2\x2\x2E0\x2E3\a\xC5\x2\x2\x2E1\x2E3");
		sb.Append("\a\xC5\x2\x2\x2E2\x2DF\x3\x2\x2\x2\x2E2\x2E1\x3\x2\x2\x2\x2E2");
		sb.Append("\x2E3\x3\x2\x2\x2\x2E3\x2E4\x3\x2\x2\x2\x2E4\x2E5\aR\x2\x2\x2E5");
		sb.Append("\x2E8\x5H%\x2\x2E6\x2E7\a\xF\x2\x2\x2E7\x2E9\x5\xC0\x61\x2\x2E8");
		sb.Append("\x2E6\x3\x2\x2\x2\x2E8\x2E9\x3\x2\x2\x2\x2E9+\x3\x2\x2\x2\x2EA");
		sb.Append("\x2EC\a}\x2\x2\x2EB\x2ED\a\x35\x2\x2\x2EC\x2EB\x3\x2\x2\x2\x2EC");
		sb.Append("\x2ED\x3\x2\x2\x2\x2ED\x2EE\x3\x2\x2\x2\x2EE\x2F2\a\xC5\x2\x2");
		sb.Append("\x2EF\x2F0\a\x10\x2\x2\x2F0\x2F3\a\xC5\x2\x2\x2F1\x2F3\a\xC5");
		sb.Append("\x2\x2\x2F2\x2EF\x3\x2\x2\x2\x2F2\x2F1\x3\x2\x2\x2\x2F2\x2F3");
		sb.Append("\x3\x2\x2\x2\x2F3\x2F6\x3\x2\x2\x2\x2F4\x2F5\a\xF\x2\x2\x2F5");
		sb.Append("\x2F7\x5\xC0\x61\x2\x2F6\x2F4\x3\x2\x2\x2\x2F6\x2F7\x3\x2\x2");
		sb.Append("\x2\x2F7\x2F9\x3\x2\x2\x2\x2F8\x2FA\x5.\x18\x2\x2F9\x2F8\x3");
		sb.Append("\x2\x2\x2\x2FA\x2FB\x3\x2\x2\x2\x2FB\x2F9\x3\x2\x2\x2\x2FB\x2FC");
		sb.Append("\x3\x2\x2\x2\x2FC-\x3\x2\x2\x2\x2FD\x300\x5\x30\x19\x2\x2FE");
		sb.Append("\x300\x5\x34\x1B\x2\x2FF\x2FD\x3\x2\x2\x2\x2FF\x2FE\x3\x2\x2");
		sb.Append("\x2\x300/\x3\x2\x2\x2\x301\x302\a\x1D\x2\x2\x302\x305\a~\x2");
		sb.Append("\x2\x303\x304\a\v\x2\x2\x304\x306\x5\x122\x92\x2\x305\x303\x3");
		sb.Append("\x2\x2\x2\x305\x306\x3\x2\x2\x2\x306\x308\x3\x2\x2\x2\x307\x309");
		sb.Append("\x5\x32\x1A\x2\x308\x307\x3\x2\x2\x2\x309\x30A\x3\x2\x2\x2\x30A");
		sb.Append("\x308\x3\x2\x2\x2\x30A\x30B\x3\x2\x2\x2\x30B\x31\x3\x2\x2\x2");
		sb.Append("\x30C\x31B\a\x1E\x2\x2\x30D\x30E\ar\x2\x2\x30E\x30F\aR\x2\x2");
		sb.Append("\x30F\x310\x5H%\x2\x310\x313\x3\x2\x2\x2\x311\x312\a\xF\x2\x2");
		sb.Append("\x312\x314\x5\xC0\x61\x2\x313\x311\x3\x2\x2\x2\x313\x314\x3");
		sb.Append("\x2\x2\x2\x314\x31C\x3\x2\x2\x2\x315\x318\aP\x2\x2\x316\x317");
		sb.Append("\a\xF\x2\x2\x317\x319\x5\xC0\x61\x2\x318\x316\x3\x2\x2\x2\x318");
		sb.Append("\x319\x3\x2\x2\x2\x319\x31C\x3\x2\x2\x2\x31A\x31C\x5\x38\x1D");
		sb.Append("\x2\x31B\x30D\x3\x2\x2\x2\x31B\x315\x3\x2\x2\x2\x31B\x31A\x3");
		sb.Append("\x2\x2\x2\x31C\x33\x3\x2\x2\x2\x31D\x31E\a\x1D\x2\x2\x31E\x31F");
		sb.Append("\a\f\x2\x2\x31F\x322\a~\x2\x2\x320\x321\a\v\x2\x2\x321\x323");
		sb.Append("\x5\x122\x92\x2\x322\x320\x3\x2\x2\x2\x322\x323\x3\x2\x2\x2");
		sb.Append("\x323\x325\x3\x2\x2\x2\x324\x326\x5\x36\x1C\x2\x325\x324\x3");
		sb.Append("\x2\x2\x2\x326\x327\x3\x2\x2\x2\x327\x325\x3\x2\x2\x2\x327\x328");
		sb.Append("\x3\x2\x2\x2\x328\x35\x3\x2\x2\x2\x329\x32A\a\x1E\x2\x2\x32A");
		sb.Append("\x32B\x5\x38\x1D\x2\x32B\x37\x3\x2\x2\x2\x32C\x32F\a\x34\x2");
		sb.Append("\x2\x32D\x32E\a\x35\x2\x2\x32E\x330\x5\x198\xCD\x2\x32F\x32D");
		sb.Append("\x3\x2\x2\x2\x32F\x330\x3\x2\x2\x2\x330\x335\x3\x2\x2\x2\x331");
		sb.Append("\x332\a\x92\x2\x2\x332\x333\x5\xB2Z\x2\x333\x334\a\x93\x2\x2");
		sb.Append("\x334\x336\x3\x2\x2\x2\x335\x331\x3\x2\x2\x2\x335\x336\x3\x2");
		sb.Append("\x2\x2\x336\x337\x3\x2\x2\x2\x337\x338\a\x1A\x2\x2\x338\x33B");
		sb.Append("\x5\xC4\x63\x2\x339\x33A\a\xF\x2\x2\x33A\x33C\x5\xC0\x61\x2");
		sb.Append("\x33B\x339\x3\x2\x2\x2\x33B\x33C\x3\x2\x2\x2\x33C\x39\x3\x2");
		sb.Append("\x2\x2\x33D\x33E\a\x34\x2\x2\x33E\x340\x5\xB0Y\x2\x33F\x33D");
		sb.Append("\x3\x2\x2\x2\x33F\x340\x3\x2\x2\x2\x340\x341\x3\x2\x2\x2\x341");
		sb.Append("\x346\a\x1A\x2\x2\x342\x344\a\v\x2\x2\x343\x342\x3\x2\x2\x2");
		sb.Append("\x343\x344\x3\x2\x2\x2\x344\x345\x3\x2\x2\x2\x345\x347\aP\x2");
		sb.Append("\x2\x346\x343\x3\x2\x2\x2\x346\x347\x3\x2\x2\x2\x347\x349\x3");
		sb.Append("\x2\x2\x2\x348\x34A\a,\x2\x2\x349\x348\x3\x2\x2\x2\x349\x34A");
		sb.Append("\x3\x2\x2\x2\x34A\x34B\x3\x2\x2\x2\x34B\x34D\x5\xC4\x63\x2\x34C");
		sb.Append("\x34E\x5L\'\x2\x34D\x34C\x3\x2\x2\x2\x34D\x34E\x3\x2\x2\x2\x34E");
		sb.Append("\x351\x3\x2\x2\x2\x34F\x350\a\xF\x2\x2\x350\x352\x5\xC0\x61");
		sb.Append("\x2\x351\x34F\x3\x2\x2\x2\x351\x352\x3\x2\x2\x2\x352\x356\x3");
		sb.Append("\x2\x2\x2\x353\x354\a*\x2\x2\x354\x355\a)\x2\x2\x355\x357\x5");
		sb.Append("\xE0q\x2\x356\x353\x3\x2\x2\x2\x356\x357\x3\x2\x2\x2\x357\x35A");
		sb.Append("\x3\x2\x2\x2\x358\x359\a+\x2\x2\x359\x35B\x5\xF0y\x2\x35A\x358");
		sb.Append("\x3\x2\x2\x2\x35A\x35B\x3\x2\x2\x2\x35B\x35F\x3\x2\x2\x2\x35C");
		sb.Append("\x35D\a\x37\x2\x2\x35D\x35E\a)\x2\x2\x35E\x360\x5\xECw\x2\x35F");
		sb.Append("\x35C\x3\x2\x2\x2\x35F\x360\x3\x2\x2\x2\x360\x363\x3\x2\x2\x2");
		sb.Append("\x361\x362\ap\x2\x2\x362\x364\x5\xF8}\x2\x363\x361\x3\x2\x2");
		sb.Append("\x2\x363\x364\x3\x2\x2\x2\x364;\x3\x2\x2\x2\x365\x366\ar\x2");
		sb.Append("\x2\x366\x36A\a\xC5\x2\x2\x367\x368\a\x10\x2\x2\x368\x36B\a");
		sb.Append("\xC5\x2\x2\x369\x36B\a\xC5\x2\x2\x36A\x367\x3\x2\x2\x2\x36A");
		sb.Append("\x369\x3\x2\x2\x2\x36A\x36B\x3\x2\x2\x2\x36B\x36C\x3\x2\x2\x2");
		sb.Append("\x36C\x36D\aR\x2\x2\x36D\x370\x5H%\x2\x36E\x36F\a\xF\x2\x2\x36F");
		sb.Append("\x371\x5\xC0\x61\x2\x370\x36E\x3\x2\x2\x2\x370\x371\x3\x2\x2");
		sb.Append("\x2\x371=\x3\x2\x2\x2\x372\x373\a\x34\x2\x2\x373\x374\x5\xB0");
		sb.Append("Y\x2\x374\x375\a\x1A\x2\x2\x375\x377\x5\xC4\x63\x2\x376\x378");
		sb.Append("\x5@!\x2\x377\x376\x3\x2\x2\x2\x377\x378\x3\x2\x2\x2\x378\x37B");
		sb.Append("\x3\x2\x2\x2\x379\x37A\a\xF\x2\x2\x37A\x37C\x5\xC0\x61\x2\x37B");
		sb.Append("\x379\x3\x2\x2\x2\x37B\x37C\x3\x2\x2\x2\x37C?\x3\x2\x2\x2\x37D");
		sb.Append("\x37E\a \x2\x2\x37E\x382\x5\x186\xC4\x2\x37F\x380\a\x10\x2\x2");
		sb.Append("\x380\x383\a\xC5\x2\x2\x381\x383\a\xC5\x2\x2\x382\x37F\x3\x2");
		sb.Append("\x2\x2\x382\x381\x3\x2\x2\x2\x382\x383\x3\x2\x2\x2\x383\x41");
		sb.Append("\x3\x2\x2\x2\x384\x387\a\x30\x2\x2\x385\x388\a\x32\x2\x2\x386");
		sb.Append("\x388\a-\x2\x2\x387\x385\x3\x2\x2\x2\x387\x386\x3\x2\x2\x2\x388");
		sb.Append("\x43\x3\x2\x2\x2\x389\x38A\aP\x2\x2\x38A\x38D\x5L\'\x2\x38B");
		sb.Append("\x38C\a\xF\x2\x2\x38C\x38E\x5\xC0\x61\x2\x38D\x38B\x3\x2\x2");
		sb.Append("\x2\x38D\x38E\x3\x2\x2\x2\x38E\x45\x3\x2\x2\x2\x38F\x390\aR");
		sb.Append("\x2\x2\x390\x391\x5H%\x2\x391G\x3\x2\x2\x2\x392\x397\x5J&\x2");
		sb.Append("\x393\x394\a\x99\x2\x2\x394\x396\x5J&\x2\x395\x393\x3\x2\x2");
		sb.Append("\x2\x396\x399\x3\x2\x2\x2\x397\x395\x3\x2\x2\x2\x397\x398\x3");
		sb.Append("\x2\x2\x2\x398I\x3\x2\x2\x2\x399\x397\x3\x2\x2\x2\x39A\x39B");
		sb.Append("\x5\x1C2\xE2\x2\x39B\x39C\a\x8F\x2\x2\x39C\x39D\x5\x122\x92");
		sb.Append("\x2\x39D\x3A0\x3\x2\x2\x2\x39E\x3A0\x5\x122\x92\x2\x39F\x39A");
		sb.Append("\x3\x2\x2\x2\x39F\x39E\x3\x2\x2\x2\x3A0K\x3\x2\x2\x2\x3A1\x3A2");
		sb.Append("\a \x2\x2\x3A2\x3A6\a\xC5\x2\x2\x3A3\x3A4\a\x10\x2\x2\x3A4\x3A7");
		sb.Append("\a\xC5\x2\x2\x3A5\x3A7\a\xC5\x2\x2\x3A6\x3A3\x3\x2\x2\x2\x3A6");
		sb.Append("\x3A5\x3\x2\x2\x2\x3A6\x3A7\x3\x2\x2\x2\x3A7M\x3\x2\x2\x2\x3A8");
		sb.Append("\x3A9\a\x3\x2\x2\x3A9\x3AA\a\x4\x2\x2\x3AA\x3AC\a\xC5\x2\x2");
		sb.Append("\x3AB\x3AD\x5\xD8m\x2\x3AC\x3AB\x3\x2\x2\x2\x3AC\x3AD\x3\x2");
		sb.Append("\x2\x2\x3AD\x3B0\x3\x2\x2\x2\x3AE\x3B1\a?\x2\x2\x3AF\x3B1\a");
		sb.Append("@\x2\x2\x3B0\x3AE\x3\x2\x2\x2\x3B0\x3AF\x3\x2\x2\x2\x3B0\x3B1");
		sb.Append("\x3\x2\x2\x2\x3B1\x3B3\x3\x2\x2\x2\x3B2\x3B4\a\x10\x2\x2\x3B3");
		sb.Append("\x3B2\x3\x2\x2\x2\x3B3\x3B4\x3\x2\x2\x2\x3B4\x3BA\x3\x2\x2\x2");
		sb.Append("\x3B5\x3BB\x5P)\x2\x3B6\x3B7\a\x92\x2\x2\x3B7\x3B8\x5\x62\x32");
		sb.Append("\x2\x3B8\x3B9\a\x93\x2\x2\x3B9\x3BB\x3\x2\x2\x2\x3BA\x3B5\x3");
		sb.Append("\x2\x2\x2\x3BA\x3B6\x3\x2\x2\x2\x3BB\x3C1\x3\x2\x2\x2\x3BC\x3BF");
		sb.Append("\a\x34\x2\x2\x3BD\x3BE\a\xF\x2\x2\x3BE\x3C0\x5\x122\x92\x2\x3BF");
		sb.Append("\x3BD\x3\x2\x2\x2\x3BF\x3C0\x3\x2\x2\x2\x3C0\x3C2\x3\x2\x2\x2");
		sb.Append("\x3C1\x3BC\x3\x2\x2\x2\x3C1\x3C2\x3\x2\x2\x2\x3C2O\x3\x2\x2");
		sb.Append("\x2\x3C3\x3C4\a\x1A\x2\x2\x3C4\x3C5\x5\x66\x34\x2\x3C5\x3C6");
		sb.Append("\a \x2\x2\x3C6\x3C8\x3\x2\x2\x2\x3C7\x3C3\x3\x2\x2\x2\x3C7\x3C8");
		sb.Append("\x3\x2\x2\x2\x3C8\x3C9\x3\x2\x2\x2\x3C9\x3CA\x5\x198\xCD\x2");
		sb.Append("\x3CAQ\x3\x2\x2\x2\x3CB\x3CD\a\x3\x2\x2\x3CC\x3CE\a\xC5\x2\x2");
		sb.Append("\x3CD\x3CC\x3\x2\x2\x2\x3CD\x3CE\x3\x2\x2\x2\x3CE\x3CF\x3\x2");
		sb.Append("\x2\x2\x3CF\x3D0\aW\x2\x2\x3D0\x3D1\a\xC5\x2\x2\x3D1\x3D2\a");
		sb.Append("\'\x2\x2\x3D2\x3D3\a\xC5\x2\x2\x3D3\x3D4\a\x92\x2\x2\x3D4\x3D5");
		sb.Append("\x5T+\x2\x3D5\x3D6\a\x93\x2\x2\x3D6S\x3\x2\x2\x2\x3D7\x3DC\x5");
		sb.Append("V,\x2\x3D8\x3D9\a\x99\x2\x2\x3D9\x3DB\x5V,\x2\x3DA\x3D8\x3\x2");
		sb.Append("\x2\x2\x3DB\x3DE\x3\x2\x2\x2\x3DC\x3DA\x3\x2\x2\x2\x3DC\x3DD");
		sb.Append("\x3\x2\x2\x2\x3DDU\x3\x2\x2\x2\x3DE\x3DC\x3\x2\x2\x2\x3DF\x3E1");
		sb.Append("\a\xC5\x2\x2\x3E0\x3E2\a\xC5\x2\x2\x3E1\x3E0\x3\x2\x2\x2\x3E1");
		sb.Append("\x3E2\x3\x2\x2\x2\x3E2W\x3\x2\x2\x2\x3E3\x3E5\a\x3\x2\x2\x3E4");
		sb.Append("\x3E6\a\xC5\x2\x2\x3E5\x3E4\x3\x2\x2\x2\x3E5\x3E6\x3\x2\x2\x2");
		sb.Append("\x3E6\x3E7\x3\x2\x2\x2\x3E7\x3E8\aS\x2\x2\x3E8\x3EE\x5\x198");
		sb.Append("\xCD\x2\x3E9\x3EB\a\x94\x2\x2\x3EA\x3EC\a\xC5\x2\x2\x3EB\x3EA");
		sb.Append("\x3\x2\x2\x2\x3EB\x3EC\x3\x2\x2\x2\x3EC\x3ED\x3\x2\x2\x2\x3ED");
		sb.Append("\x3EF\a\x95\x2\x2\x3EE\x3E9\x3\x2\x2\x2\x3EE\x3EF\x3\x2\x2\x2");
		sb.Append("\x3EF\x3F0\x3\x2\x2\x2\x3F0\x3F3\a\xC5\x2\x2\x3F1\x3F2\a\x8F");
		sb.Append("\x2\x2\x3F2\x3F4\x5\x122\x92\x2\x3F3\x3F1\x3\x2\x2\x2\x3F3\x3F4");
		sb.Append("\x3\x2\x2\x2\x3F4Y\x3\x2\x2\x2\x3F5\x3F6\a\x3\x2\x2\x3F6\x3F7");
		sb.Append("\aT\x2\x2\x3F7\x3F9\a\xC5\x2\x2\x3F8\x3FA\a\x10\x2\x2\x3F9\x3F8");
		sb.Append("\x3\x2\x2\x2\x3F9\x3FA\x3\x2\x2\x2\x3FA\x3FB\x3\x2\x2\x2\x3FB");
		sb.Append("\x3FC\a\x92\x2\x2\x3FC\x3FD\x5\\/\x2\x3FD\x3FE\a\x93\x2\x2\x3FE");
		sb.Append("[\x3\x2\x2\x2\x3FF\x404\x5^\x30\x2\x400\x401\a\x99\x2\x2\x401");
		sb.Append("\x403\x5^\x30\x2\x402\x400\x3\x2\x2\x2\x403\x406\x3\x2\x2\x2");
		sb.Append("\x404\x402\x3\x2\x2\x2\x404\x405\x3\x2\x2\x2\x405]\x3\x2\x2");
		sb.Append("\x2\x406\x404\x3\x2\x2\x2\x407\x40B\a\xC5\x2\x2\x408\x40C\x5");
		sb.Append("`\x31\x2\x409\x40C\x5\x14E\xA8\x2\x40A\x40C\x5\x154\xAB\x2\x40B");
		sb.Append("\x408\x3\x2\x2\x2\x40B\x409\x3\x2\x2\x2\x40B\x40A\x3\x2\x2\x2");
		sb.Append("\x40C\x40E\x3\x2\x2\x2\x40D\x40F\a\xC5\x2\x2\x40E\x40D\x3\x2");
		sb.Append("\x2\x2\x40E\x40F\x3\x2\x2\x2\x40F\x411\x3\x2\x2\x2\x410\x412");
		sb.Append("\a\xC5\x2\x2\x411\x410\x3\x2\x2\x2\x411\x412\x3\x2\x2\x2\x412");
		sb.Append("\x417\x3\x2\x2\x2\x413\x416\x5\x192\xCA\x2\x414\x416\x5\x14");
		sb.Append("\v\x2\x415\x413\x3\x2\x2\x2\x415\x414\x3\x2\x2\x2\x416\x419");
		sb.Append("\x3\x2\x2\x2\x417\x415\x3\x2\x2\x2\x417\x418\x3\x2\x2\x2\x418");
		sb.Append("_\x3\x2\x2\x2\x419\x417\x3\x2\x2\x2\x41A\x420\x5\x198\xCD\x2");
		sb.Append("\x41B\x41D\a\x94\x2\x2\x41C\x41E\a\xC5\x2\x2\x41D\x41C\x3\x2");
		sb.Append("\x2\x2\x41D\x41E\x3\x2\x2\x2\x41E\x41F\x3\x2\x2\x2\x41F\x421");
		sb.Append("\a\x95\x2\x2\x420\x41B\x3\x2\x2\x2\x420\x421\x3\x2\x2\x2\x421");
		sb.Append("\x61\x3\x2\x2\x2\x422\x427\x5\x64\x33\x2\x423\x424\a\x99\x2");
		sb.Append("\x2\x424\x426\x5\x64\x33\x2\x425\x423\x3\x2\x2\x2\x426\x429");
		sb.Append("\x3\x2\x2\x2\x427\x425\x3\x2\x2\x2\x427\x428\x3\x2\x2\x2\x428");
		sb.Append("\x63\x3\x2\x2\x2\x429\x427\x3\x2\x2\x2\x42A\x434\x5\x198\xCD");
		sb.Append("\x2\x42B\x435\ao\x2\x2\x42C\x432\x5\x198\xCD\x2\x42D\x42F\a");
		sb.Append("\x94\x2\x2\x42E\x430\a\xC5\x2\x2\x42F\x42E\x3\x2\x2\x2\x42F");
		sb.Append("\x430\x3\x2\x2\x2\x430\x431\x3\x2\x2\x2\x431\x433\a\x95\x2\x2");
		sb.Append("\x432\x42D\x3\x2\x2\x2\x432\x433\x3\x2\x2\x2\x433\x435\x3\x2");
		sb.Append("\x2\x2\x434\x42B\x3\x2\x2\x2\x434\x42C\x3\x2\x2\x2\x435\x65");
		sb.Append("\x3\x2\x2\x2\x436\x43B\x5h\x35\x2\x437\x438\a\x99\x2\x2\x438");
		sb.Append("\x43A\x5h\x35\x2\x439\x437\x3\x2\x2\x2\x43A\x43D\x3\x2\x2\x2");
		sb.Append("\x43B\x439\x3\x2\x2\x2\x43B\x43C\x3\x2\x2\x2\x43Cg\x3\x2\x2");
		sb.Append("\x2\x43D\x43B\x3\x2\x2\x2\x43E\x449\a\xA6\x2\x2\x43F\x442\x5");
		sb.Append("\x1C2\xE2\x2\x440\x441\a\x10\x2\x2\x441\x443\a\xC5\x2\x2\x442");
		sb.Append("\x440\x3\x2\x2\x2\x442\x443\x3\x2\x2\x2\x443\x449\x3\x2\x2\x2");
		sb.Append("\x444\x445\x5\x1E6\xF4\x2\x445\x446\a\x10\x2\x2\x446\x447\a");
		sb.Append("\xC5\x2\x2\x447\x449\x3\x2\x2\x2\x448\x43E\x3\x2\x2\x2\x448");
		sb.Append("\x43F\x3\x2\x2\x2\x448\x444\x3\x2\x2\x2\x449i\x3\x2\x2\x2\x44A");
		sb.Append("\x44C\a\x3\x2\x2\x44B\x44D\a\xC5\x2\x2\x44C\x44B\x3\x2\x2\x2");
		sb.Append("\x44C\x44D\x3\x2\x2\x2\x44D\x44E\x3\x2\x2\x2\x44E\x44F\x5l\x37");
		sb.Append("\x2\x44Fk\x3\x2\x2\x2\x450\x451\a=\x2\x2\x451\x453\a\xC5\x2");
		sb.Append("\x2\x452\x454\a\x10\x2\x2\x453\x452\x3\x2\x2\x2\x453\x454\x3");
		sb.Append("\x2\x2\x2\x454\x45B\x3\x2\x2\x2\x455\x45C\x5\xAAV\x2\x456\x458");
		sb.Append("\a\x92\x2\x2\x457\x459\x5\x62\x32\x2\x458\x457\x3\x2\x2\x2\x458");
		sb.Append("\x459\x3\x2\x2\x2\x459\x45A\x3\x2\x2\x2\x45A\x45C\a\x93\x2\x2");
		sb.Append("\x45B\x455\x3\x2\x2\x2\x45B\x456\x3\x2\x2\x2\x45C\x460\x3\x2");
		sb.Append("\x2\x2\x45D\x45F\x5\xA8U\x2\x45E\x45D\x3\x2\x2\x2\x45F\x462");
		sb.Append("\x3\x2\x2\x2\x460\x45E\x3\x2\x2\x2\x460\x461\x3\x2\x2\x2\x461");
		sb.Append("m\x3\x2\x2\x2\x462\x460\x3\x2\x2\x2\x463\x464\aP\x2\x2\x464");
		sb.Append("\x465\a \x2\x2\x465\x469\x5\x198\xCD\x2\x466\x467\a\x10\x2\x2");
		sb.Append("\x467\x46A\a\xC5\x2\x2\x468\x46A\a\xC5\x2\x2\x469\x466\x3\x2");
		sb.Append("\x2\x2\x469\x468\x3\x2\x2\x2\x469\x46A\x3\x2\x2\x2\x46A\x46D");
		sb.Append("\x3\x2\x2\x2\x46B\x46C\a\xF\x2\x2\x46C\x46E\x5\xC0\x61\x2\x46D");
		sb.Append("\x46B\x3\x2\x2\x2\x46D\x46E\x3\x2\x2\x2\x46Eo\x3\x2\x2\x2\x46F");
		sb.Append("\x470\ar\x2\x2\x470\x471\x5*\x16\x2\x471q\x3\x2\x2\x2\x472\x473");
		sb.Append("\a\x34\x2\x2\x473\x474\x5\xB0Y\x2\x474\x475\a\x36\x2\x2\x475");
		sb.Append("\x476\a\x92\x2\x2\x476\x477\x5\x1A8\xD5\x2\x477\x478\a\x93\x2");
		sb.Append("\x2\x478s\x3\x2\x2\x2\x479\x47A\a\x3\x2\x2\x47A\x47B\a\x85\x2");
		sb.Append("\x2\x47B\x47D\a\xC5\x2\x2\x47C\x47E\a\x10\x2\x2\x47D\x47C\x3");
		sb.Append("\x2\x2\x2\x47D\x47E\x3\x2\x2\x2\x47E\x47F\x3\x2\x2\x2\x47F\x480");
		sb.Append("\x5v<\x2\x480u\x3\x2\x2\x2\x481\x485\x5x=\x2\x482\x484\x5x=");
		sb.Append("\x2\x483\x482\x3\x2\x2\x2\x484\x487\x3\x2\x2\x2\x485\x483\x3");
		sb.Append("\x2\x2\x2\x485\x486\x3\x2\x2\x2\x486w\x3\x2\x2\x2\x487\x485");
		sb.Append("\x3\x2\x2\x2\x488\x48A\x5\x14\v\x2\x489\x488\x3\x2\x2\x2\x48A");
		sb.Append("\x48D\x3\x2\x2\x2\x48B\x489\x3\x2\x2\x2\x48B\x48C\x3\x2\x2\x2");
		sb.Append("\x48C\x490\x3\x2\x2\x2\x48D\x48B\x3\x2\x2\x2\x48E\x491\a\xC5");
		sb.Append("\x2\x2\x48F\x491\a\x1A\x2\x2\x490\x48E\x3\x2\x2\x2\x490\x48F");
		sb.Append("\x3\x2\x2\x2\x491\x493\x3\x2\x2\x2\x492\x494\x5z>\x2\x493\x492");
		sb.Append("\x3\x2\x2\x2\x493\x494\x3\x2\x2\x2\x494\x496\x3\x2\x2\x2\x495");
		sb.Append("\x497\x5\x84\x43\x2\x496\x495\x3\x2\x2\x2\x496\x497\x3\x2\x2");
		sb.Append("\x2\x497\x498\x3\x2\x2\x2\x498\x49A\a\x96\x2\x2\x499\x49B\x5");
		sb.Append("\x8EH\x2\x49A\x499\x3\x2\x2\x2\x49A\x49B\x3\x2\x2\x2\x49B\x49D");
		sb.Append("\x3\x2\x2\x2\x49C\x49E\a\x99\x2\x2\x49D\x49C\x3\x2\x2\x2\x49D");
		sb.Append("\x49E\x3\x2\x2\x2\x49E\x49F\x3\x2\x2\x2\x49F\x4A4\a\x97\x2\x2");
		sb.Append("\x4A0\x4A1\x5j\x36\x2\x4A1\x4A2\a\x99\x2\x2\x4A2\x4A4\x3\x2");
		sb.Append("\x2\x2\x4A3\x48B\x3\x2\x2\x2\x4A3\x4A0\x3\x2\x2\x2\x4A4y\x3");
		sb.Append("\x2\x2\x2\x4A5\x4A6\a\x92\x2\x2\x4A6\x4A7\x5|?\x2\x4A7\x4A8");
		sb.Append("\a\x93\x2\x2\x4A8{\x3\x2\x2\x2\x4A9\x4AE\x5~@\x2\x4AA\x4AB\a");
		sb.Append("\x99\x2\x2\x4AB\x4AD\x5~@\x2\x4AC\x4AA\x3\x2\x2\x2\x4AD\x4B0");
		sb.Append("\x3\x2\x2\x2\x4AE\x4AC\x3\x2\x2\x2\x4AE\x4AF\x3\x2\x2\x2\x4AF");
		sb.Append("}\x3\x2\x2\x2\x4B0\x4AE\x3\x2\x2\x2\x4B1\x4B4\x5\x198\xCD\x2");
		sb.Append("\x4B2\x4B4\x5\x80\x41\x2\x4B3\x4B1\x3\x2\x2\x2\x4B3\x4B2\x3");
		sb.Append("\x2\x2\x2\x4B4\x4B6\x3\x2\x2\x2\x4B5\x4B7\x5\x82\x42\x2\x4B6");
		sb.Append("\x4B5\x3\x2\x2\x2\x4B6\x4B7\x3\x2\x2\x2\x4B7\x7F\x3\x2\x2\x2");
		sb.Append("\x4B8\x4B9\a\x92\x2\x2\x4B9\x4BA\x5\x198\xCD\x2\x4BA\x4BB\a");
		sb.Append("\x99\x2\x2\x4BB\x4BC\x5\x198\xCD\x2\x4BC\x4BD\x3\x2\x2\x2\x4BD");
		sb.Append("\x4BE\a\x93\x2\x2\x4BE\x81\x3\x2\x2\x2\x4BF\x4C0\a\x10\x2\x2");
		sb.Append("\x4C0\x4C1\a\xC5\x2\x2\x4C1\x83\x3\x2\x2\x2\x4C2\x4C3\a\x8D");
		sb.Append("\x2\x2\x4C3\x4C8\x5\x86\x44\x2\x4C4\x4C5\a\x99\x2\x2\x4C5\x4C7");
		sb.Append("\x5\x86\x44\x2\x4C6\x4C4\x3\x2\x2\x2\x4C7\x4CA\x3\x2\x2\x2\x4C8");
		sb.Append("\x4C6\x3\x2\x2\x2\x4C8\x4C9\x3\x2\x2\x2\x4C9\x85\x3\x2\x2\x2");
		sb.Append("\x4CA\x4C8\x3\x2\x2\x2\x4CB\x4CD\x5\x198\xCD\x2\x4CC\x4CE\x5");
		sb.Append("\x88\x45\x2\x4CD\x4CC\x3\x2\x2\x2\x4CD\x4CE\x3\x2\x2\x2\x4CE");
		sb.Append("\x87\x3\x2\x2\x2\x4CF\x4D0\a\xAD\x2\x2\x4D0\x4D5\x5\x8A\x46");
		sb.Append("\x2\x4D1\x4D2\a\x99\x2\x2\x4D2\x4D4\x5\x8A\x46\x2\x4D3\x4D1");
		sb.Append("\x3\x2\x2\x2\x4D4\x4D7\x3\x2\x2\x2\x4D5\x4D3\x3\x2\x2\x2\x4D5");
		sb.Append("\x4D6\x3\x2\x2\x2\x4D6\x4D8\x3\x2\x2\x2\x4D7\x4D5\x3\x2\x2\x2");
		sb.Append("\x4D8\x4D9\a\xAB\x2\x2\x4D9\x89\x3\x2\x2\x2\x4DA\x4DD\x5\x8C");
		sb.Append("G\x2\x4DB\x4DD\a\x91\x2\x2\x4DC\x4DA\x3\x2\x2\x2\x4DC\x4DB\x3");
		sb.Append("\x2\x2\x2\x4DD\x8B\x3\x2\x2\x2\x4DE\x4E0\x5\x198\xCD\x2\x4DF");
		sb.Append("\x4E1\x5\x88\x45\x2\x4E0\x4DF\x3\x2\x2\x2\x4E0\x4E1\x3\x2\x2");
		sb.Append("\x2\x4E1\x8D\x3\x2\x2\x2\x4E2\x4E7\x5\x90I\x2\x4E3\x4E4\a\x99");
		sb.Append("\x2\x2\x4E4\x4E6\x5\x90I\x2\x4E5\x4E3\x3\x2\x2\x2\x4E6\x4E9");
		sb.Append("\x3\x2\x2\x2\x4E7\x4E5\x3\x2\x2\x2\x4E7\x4E8\x3\x2\x2\x2\x4E8");
		sb.Append("\x8F\x3\x2\x2\x2\x4E9\x4E7\x3\x2\x2\x2\x4EA\x4EB\a\x1A\x2\x2");
		sb.Append("\x4EB\x4EC\t\x3\x2\x2\x4EC\x4ED\a\x92\x2\x2\x4ED\x4EE\x5\"\x12");
		sb.Append("\x2\x4EE\x4EF\a\x93\x2\x2\x4EF\x4F8\x3\x2\x2\x2\x4F0\x4F1\a");
		sb.Append("\xC5\x2\x2\x4F1\x4F5\t\x3\x2\x2\x4F2\x4F6\x5\x122\x92\x2\x4F3");
		sb.Append("\x4F6\x5\x1EE\xF8\x2\x4F4\x4F6\x5\x1F0\xF9\x2\x4F5\x4F2\x3\x2");
		sb.Append("\x2\x2\x4F5\x4F3\x3\x2\x2\x2\x4F5\x4F4\x3\x2\x2\x2\x4F6\x4F8");
		sb.Append("\x3\x2\x2\x2\x4F7\x4EA\x3\x2\x2\x2\x4F7\x4F0\x3\x2\x2\x2\x4F8");
		sb.Append("\x91\x3\x2\x2\x2\x4F9\x4FA\a\x3\x2\x2\x4FA\x4FB\a\x82\x2\x2");
		sb.Append("\x4FB\x4FD\a\xC5\x2\x2\x4FC\x4FE\a\x10\x2\x2\x4FD\x4FC\x3\x2");
		sb.Append("\x2\x2\x4FD\x4FE\x3\x2\x2\x2\x4FE\x4FF\x3\x2\x2\x2\x4FF\x500");
		sb.Append("\x5\x96L\x2\x500\x93\x3\x2\x2\x2\x501\x502\a\x3\x2\x2\x502\x503");
		sb.Append("\x5\n\x6\x2\x503\x95\x3\x2\x2\x2\x504\x510\x5\x9AN\x2\x505\x506");
		sb.Append("\x5\x98M\x2\x506\x507\a\x99\x2\x2\x507\x50C\x5\x98M\x2\x508");
		sb.Append("\x509\a\x99\x2\x2\x509\x50B\x5\x98M\x2\x50A\x508\x3\x2\x2\x2");
		sb.Append("\x50B\x50E\x3\x2\x2\x2\x50C\x50A\x3\x2\x2\x2\x50C\x50D\x3\x2");
		sb.Append("\x2\x2\x50D\x510\x3\x2\x2\x2\x50E\x50C\x3\x2\x2\x2\x50F\x504");
		sb.Append("\x3\x2\x2\x2\x50F\x505\x3\x2\x2\x2\x510\x97\x3\x2\x2\x2\x511");
		sb.Append("\x512\a\x82\x2\x2\x512\x514\a\xC5\x2\x2\x513\x515\a\x10\x2\x2");
		sb.Append("\x514\x513\x3\x2\x2\x2\x514\x515\x3\x2\x2\x2\x515\x516\x3\x2");
		sb.Append("\x2\x2\x516\x517\x5\x9AN\x2\x517\x99\x3\x2\x2\x2\x518\x51C\a");
		sb.Append("\x81\x2\x2\x519\x51A\a\xBD\x2\x2\x51A\x51D\a\xC5\x2\x2\x51B");
		sb.Append("\x51D\x5\x9EP\x2\x51C\x519\x3\x2\x2\x2\x51C\x51B\x3\x2\x2\x2");
		sb.Append("\x51D\x520\x3\x2\x2\x2\x51E\x51F\a\x1F\x2\x2\x51F\x521\x5\x9E");
		sb.Append("P\x2\x520\x51E\x3\x2\x2\x2\x520\x521\x3\x2\x2\x2\x521\x55F\x3");
		sb.Append("\x2\x2\x2\x522\x524\a\x83\x2\x2\x523\x525\a)\x2\x2\x524\x523");
		sb.Append("\x3\x2\x2\x2\x524\x525\x3\x2\x2\x2\x525\x527\x3\x2\x2\x2\x526");
		sb.Append("\x528\x5\x9CO\x2\x527\x526\x3\x2\x2\x2\x527\x528\x3\x2\x2\x2");
		sb.Append("\x528\x52C\x3\x2\x2\x2\x529\x52A\a\xBD\x2\x2\x52A\x52B\a\xC5");
		sb.Append("\x2\x2\x52B\x52D\a\v\x2\x2\x52C\x529\x3\x2\x2\x2\x52C\x52D\x3");
		sb.Append("\x2\x2\x2\x52D\x52E\x3\x2\x2\x2\x52E\x534\x5\x9EP\x2\x52F\x531");
		sb.Append("\a\x84\x2\x2\x530\x532\a)\x2\x2\x531\x530\x3\x2\x2\x2\x531\x532");
		sb.Append("\x3\x2\x2\x2\x532\x533\x3\x2\x2\x2\x533\x535\x5\x9EP\x2\x534");
		sb.Append("\x52F\x3\x2\x2\x2\x534\x535\x3\x2\x2\x2\x535\x55F\x3\x2\x2\x2");
		sb.Append("\x536\x538\aw\x2\x2\x537\x539\a)\x2\x2\x538\x537\x3\x2\x2\x2");
		sb.Append("\x538\x539\x3\x2\x2\x2\x539\x53A\x3\x2\x2\x2\x53A\x53F\x5\xA2");
		sb.Append("R\x2\x53B\x53C\a\x99\x2\x2\x53C\x53E\x5\xA2R\x2\x53D\x53B\x3");
		sb.Append("\x2\x2\x2\x53E\x541\x3\x2\x2\x2\x53F\x53D\x3\x2\x2\x2\x53F\x540");
		sb.Append("\x3\x2\x2\x2\x540\x55F\x3\x2\x2\x2\x541\x53F\x3\x2\x2\x2\x542");
		sb.Append("\x547\x5\xA6T\x2\x543\x544\a\x99\x2\x2\x544\x546\x5\xA6T\x2");
		sb.Append("\x545\x543\x3\x2\x2\x2\x546\x549\x3\x2\x2\x2\x547\x545\x3\x2");
		sb.Append("\x2\x2\x547\x548\x3\x2\x2\x2\x548\x54A\x3\x2\x2\x2\x549\x547");
		sb.Append("\x3\x2\x2\x2\x54A\x54B\a \x2\x2\x54B\x54C\x5\x184\xC3\x2\x54C");
		sb.Append("\x55F\x3\x2\x2\x2\x54D\x54F\a\x15\x2\x2\x54E\x550\a)\x2\x2\x54F");
		sb.Append("\x54E\x3\x2\x2\x2\x54F\x550\x3\x2\x2\x2\x550\x551\x3\x2\x2\x2");
		sb.Append("\x551\x556\x5\xA4S\x2\x552\x553\a\x99\x2\x2\x553\x555\x5\xA4");
		sb.Append("S\x2\x554\x552\x3\x2\x2\x2\x555\x558\x3\x2\x2\x2\x556\x554\x3");
		sb.Append("\x2\x2\x2\x556\x557\x3\x2\x2\x2\x557\x559\x3\x2\x2\x2\x558\x556");
		sb.Append("\x3\x2\x2\x2\x559\x55A\a\xC5\x2\x2\x55A\x55C\x5\x1E2\xF2\x2");
		sb.Append("\x55B\x55D\a\xC5\x2\x2\x55C\x55B\x3\x2\x2\x2\x55C\x55D\x3\x2");
		sb.Append("\x2\x2\x55D\x55F\x3\x2\x2\x2\x55E\x518\x3\x2\x2\x2\x55E\x522");
		sb.Append("\x3\x2\x2\x2\x55E\x536\x3\x2\x2\x2\x55E\x542\x3\x2\x2\x2\x55E");
		sb.Append("\x54D\x3\x2\x2\x2\x55F\x9B\x3\x2\x2\x2\x560\x561\a,\x2\x2\x561");
		sb.Append("\x563\a\x92\x2\x2\x562\x564\x5\x1A8\xD5\x2\x563\x562\x3\x2\x2");
		sb.Append("\x2\x563\x564\x3\x2\x2\x2\x564\x565\x3\x2\x2\x2\x565\x566\a");
		sb.Append("\x93\x2\x2\x566\x9D\x3\x2\x2\x2\x567\x571\x5\xA0Q\x2\x568\x56B");
		sb.Append("\x5\xD2j\x2\x569\x56A\a\xBD\x2\x2\x56A\x56C\a\xC5\x2\x2\x56B");
		sb.Append("\x569\x3\x2\x2\x2\x56B\x56C\x3\x2\x2\x2\x56C\x571\x3\x2\x2\x2");
		sb.Append("\x56D\x571\x5\xFA~\x2\x56E\x56F\ay\x2\x2\x56F\x571\x5\x1CE\xE8");
		sb.Append("\x2\x570\x567\x3\x2\x2\x2\x570\x568\x3\x2\x2\x2\x570\x56D\x3");
		sb.Append("\x2\x2\x2\x570\x56E\x3\x2\x2\x2\x571\x9F\x3\x2\x2\x2\x572\x577");
		sb.Append("\x5\x184\xC3\x2\x573\x575\a\x10\x2\x2\x574\x573\x3\x2\x2\x2");
		sb.Append("\x574\x575\x3\x2\x2\x2\x575\x576\x3\x2\x2\x2\x576\x578\a\xC5");
		sb.Append("\x2\x2\x577\x574\x3\x2\x2\x2\x577\x578\x3\x2\x2\x2\x578\xA1");
		sb.Append("\x3\x2\x2\x2\x579\x57E\x5\x1C2\xE2\x2\x57A\x57B\t\x4\x2\x2\x57B");
		sb.Append("\x57D\x5\x1C2\xE2\x2\x57C\x57A\x3\x2\x2\x2\x57D\x580\x3\x2\x2");
		sb.Append("\x2\x57E\x57C\x3\x2\x2\x2\x57E\x57F\x3\x2\x2\x2\x57F\x581\x3");
		sb.Append("\x2\x2\x2\x580\x57E\x3\x2\x2\x2\x581\x582\a \x2\x2\x582\x583");
		sb.Append("\x5\x184\xC3\x2\x583\xA3\x3\x2\x2\x2\x584\x585\x5\x158\xAD\x2");
		sb.Append("\x585\x586\a \x2\x2\x586\x587\x5\x184\xC3\x2\x587\xA5\x3\x2");
		sb.Append("\x2\x2\x588\x58A\a*\x2\x2\x589\x58B\a)\x2\x2\x58A\x589\x3\x2");
		sb.Append("\x2\x2\x58A\x58B\x3\x2\x2\x2\x58B\x58C\x3\x2\x2\x2\x58C\x58D");
		sb.Append("\x5\x122\x92\x2\x58D\x58E\a\x10\x2\x2\x58E\x58F\a\xC5\x2\x2");
		sb.Append("\x58F\xA7\x3\x2\x2\x2\x590\x591\a\xC5\x2\x2\x591\x592\x5\xB2");
		sb.Append("Z\x2\x592\xA9\x3\x2\x2\x2\x593\x598\x5\xACW\x2\x594\x595\a\x99");
		sb.Append("\x2\x2\x595\x597\x5\xACW\x2\x596\x594\x3\x2\x2\x2\x597\x59A");
		sb.Append("\x3\x2\x2\x2\x598\x596\x3\x2\x2\x2\x598\x599\x3\x2\x2\x2\x599");
		sb.Append("\xAB\x3\x2\x2\x2\x59A\x598\x3\x2\x2\x2\x59B\x59E\a\xA6\x2\x2");
		sb.Append("\x59C\x59E\x5\x198\xCD\x2\x59D\x59B\x3\x2\x2\x2\x59D\x59C\x3");
		sb.Append("\x2\x2\x2\x59E\xAD\x3\x2\x2\x2\x59F\x5A0\aT\x2\x2\x5A0\x5A1");
		sb.Append("\a\xC5\x2\x2\x5A1\xAF\x3\x2\x2\x2\x5A2\x5A6\a;\x2\x2\x5A3\x5A6");
		sb.Append("\a:\x2\x2\x5A4\x5A6\a<\x2\x2\x5A5\x5A2\x3\x2\x2\x2\x5A5\x5A3");
		sb.Append("\x3\x2\x2\x2\x5A5\x5A4\x3\x2\x2\x2\x5A5\x5A6\x3\x2\x2\x2\x5A6");
		sb.Append("\x5A7\x3\x2\x2\x2\x5A7\x5A8\a\x35\x2\x2\x5A8\x5AE\x5\x198\xCD");
		sb.Append("\x2\x5A9\x5AB\a\x92\x2\x2\x5AA\x5AC\x5\xB2Z\x2\x5AB\x5AA\x3");
		sb.Append("\x2\x2\x2\x5AB\x5AC\x3\x2\x2\x2\x5AC\x5AD\x3\x2\x2\x2\x5AD\x5AF");
		sb.Append("\a\x93\x2\x2\x5AE\x5A9\x3\x2\x2\x2\x5AE\x5AF\x3\x2\x2\x2\x5AF");
		sb.Append("\xB1\x3\x2\x2\x2\x5B0\x5B5\a\xC5\x2\x2\x5B1\x5B2\a\x99\x2\x2");
		sb.Append("\x5B2\x5B4\a\xC5\x2\x2\x5B3\x5B1\x3\x2\x2\x2\x5B4\x5B7\x3\x2");
		sb.Append("\x2\x2\x5B5\x5B3\x3\x2\x2\x2\x5B5\x5B6\x3\x2\x2\x2\x5B6\xB3");
		sb.Append("\x3\x2\x2\x2\x5B7\x5B5\x3\x2\x2\x2\x5B8\x5BB\x5\xCEh\x2\x5B9");
		sb.Append("\x5BC\x5\xB6\\\x2\x5BA\x5BC\x5\xB8]\x2\x5BB\x5B9\x3\x2\x2\x2");
		sb.Append("\x5BB\x5BA\x3\x2\x2\x2\x5BC\xB5\x3\x2\x2\x2\x5BD\x5BE\a\x99");
		sb.Append("\x2\x2\x5BE\x5C0\x5\xCEh\x2\x5BF\x5BD\x3\x2\x2\x2\x5C0\x5C3");
		sb.Append("\x3\x2\x2\x2\x5C1\x5BF\x3\x2\x2\x2\x5C1\x5C2\x3\x2\x2\x2\x5C2");
		sb.Append("\xB7\x3\x2\x2\x2\x5C3\x5C1\x3\x2\x2\x2\x5C4\x5C8\x5\xBA^\x2");
		sb.Append("\x5C5\x5C7\x5\xBA^\x2\x5C6\x5C5\x3\x2\x2\x2\x5C7\x5CA\x3\x2");
		sb.Append("\x2\x2\x5C8\x5C6\x3\x2\x2\x2\x5C8\x5C9\x3\x2\x2\x2\x5C9\xB9");
		sb.Append("\x3\x2\x2\x2\x5CA\x5C8\x3\x2\x2\x2\x5CB\x5CF\a$\x2\x2\x5CC\x5CF");
		sb.Append("\a%\x2\x2\x5CD\x5CF\a&\x2\x2\x5CE\x5CB\x3\x2\x2\x2\x5CE\x5CC");
		sb.Append("\x3\x2\x2\x2\x5CE\x5CD\x3\x2\x2\x2\x5CF\x5D0\x3\x2\x2\x2\x5D0");
		sb.Append("\x5D2\a!\x2\x2\x5D1\x5CE\x3\x2\x2\x2\x5D1\x5D2\x3\x2\x2\x2\x5D2");
		sb.Append("\x5D5\x3\x2\x2\x2\x5D3\x5D5\a\"\x2\x2\x5D4\x5D1\x3\x2\x2\x2");
		sb.Append("\x5D4\x5D3\x3\x2\x2\x2\x5D5\x5D6\x3\x2\x2\x2\x5D6\x5D7\a#\x2");
		sb.Append("\x2\x5D7\x5D9\x5\xCEh\x2\x5D8\x5DA\x5\xBC_\x2\x5D9\x5D8\x3\x2");
		sb.Append("\x2\x2\x5D9\x5DA\x3\x2\x2\x2\x5DA\xBB\x3\x2\x2\x2\x5DB\x5DC");
		sb.Append("\a\'\x2\x2\x5DC\x5E1\x5\xBE`\x2\x5DD\x5DE\a\v\x2\x2\x5DE\x5E0");
		sb.Append("\x5\xBE`\x2\x5DF\x5DD\x3\x2\x2\x2\x5E0\x5E3\x3\x2\x2\x2\x5E1");
		sb.Append("\x5DF\x3\x2\x2\x2\x5E1\x5E2\x3\x2\x2\x2\x5E2\xBD\x3\x2\x2\x2");
		sb.Append("\x5E3\x5E1\x3\x2\x2\x2\x5E4\x5E5\x5\x1C2\xE2\x2\x5E5\x5E6\a");
		sb.Append("\x8F\x2\x2\x5E6\x5E7\x5\x1C2\xE2\x2\x5E7\xBF\x3\x2\x2\x2\x5E8");
		sb.Append("\x5E9\x5\x126\x94\x2\x5E9\xC1\x3\x2\x2\x2\x5EA\x5EE\a:\x2\x2");
		sb.Append("\x5EB\x5EE\a;\x2\x2\x5EC\x5EE\a<\x2\x2\x5ED\x5EA\x3\x2\x2\x2");
		sb.Append("\x5ED\x5EB\x3\x2\x2\x2\x5ED\x5EC\x3\x2\x2\x2\x5ED\x5EE\x3\x2");
		sb.Append("\x2\x2\x5EE\x5F0\x3\x2\x2\x2\x5EF\x5F1\a,\x2\x2\x5F0\x5EF\x3");
		sb.Append("\x2\x2\x2\x5F0\x5F1\x3\x2\x2\x2\x5F1\x5F2\x3\x2\x2\x2\x5F2\x5F3");
		sb.Append("\x5\xC4\x63\x2\x5F3\xC3\x3\x2\x2\x2\x5F4\x5F9\x5\xC6\x64\x2");
		sb.Append("\x5F5\x5F6\a\x99\x2\x2\x5F6\x5F8\x5\xC6\x64\x2\x5F7\x5F5\x3");
		sb.Append("\x2\x2\x2\x5F8\x5FB\x3\x2\x2\x2\x5F9\x5F7\x3\x2\x2\x2\x5F9\x5FA");
		sb.Append("\x3\x2\x2\x2\x5FA\xC5\x3\x2\x2\x2\x5FB\x5F9\x3\x2\x2\x2\x5FC");
		sb.Append("\x600\a\xA6\x2\x2\x5FD\x600\x5\xCCg\x2\x5FE\x600\x5\xC8\x65");
		sb.Append("\x2\x5FF\x5FC\x3\x2\x2\x2\x5FF\x5FD\x3\x2\x2\x2\x5FF\x5FE\x3");
		sb.Append("\x2\x2\x2\x600\xC7\x3\x2\x2\x2\x601\x603\x5\x122\x92\x2\x602");
		sb.Append("\x604\x5\xCA\x66\x2\x603\x602\x3\x2\x2\x2\x603\x604\x3\x2\x2");
		sb.Append("\x2\x604\x609\x3\x2\x2\x2\x605\x607\a\x10\x2\x2\x606\x605\x3");
		sb.Append("\x2\x2\x2\x606\x607\x3\x2\x2\x2\x607\x608\x3\x2\x2\x2\x608\x60A");
		sb.Append("\x5\x1C8\xE5\x2\x609\x606\x3\x2\x2\x2\x609\x60A\x3\x2\x2\x2");
		sb.Append("\x60A\xC9\x3\x2\x2\x2\x60B\x60C\a\xBD\x2\x2\x60C\x60D\a\xC5");
		sb.Append("\x2\x2\x60D\xCB\x3\x2\x2\x2\x60E\x60F\a\xC5\x2\x2\x60F\x610");
		sb.Append("\a\xB7\x2\x2\x610\x613\a\xA6\x2\x2\x611\x612\a\x10\x2\x2\x612");
		sb.Append("\x614\a\xC5\x2\x2\x613\x611\x3\x2\x2\x2\x613\x614\x3\x2\x2\x2");
		sb.Append("\x614\xCD\x3\x2\x2\x2\x615\x61A\x5\x184\xC3\x2\x616\x61A\x5");
		sb.Append("\xD2j\x2\x617\x61A\x5\xD4k\x2\x618\x61A\x5\xD6l\x2\x619\x615");
		sb.Append("\x3\x2\x2\x2\x619\x616\x3\x2\x2\x2\x619\x617\x3\x2\x2\x2\x619");
		sb.Append("\x618\x3\x2\x2\x2\x61A\x61C\x3\x2\x2\x2\x61B\x61D\x5\xD8m\x2");
		sb.Append("\x61C\x61B\x3\x2\x2\x2\x61C\x61D\x3\x2\x2\x2\x61D\x621\x3\x2");
		sb.Append("\x2\x2\x61E\x61F\a\x10\x2\x2\x61F\x622\a\xC5\x2\x2\x620\x622");
		sb.Append("\a\xC5\x2\x2\x621\x61E\x3\x2\x2\x2\x621\x620\x3\x2\x2\x2\x621");
		sb.Append("\x622\x3\x2\x2\x2\x622\x624\x3\x2\x2\x2\x623\x625\a>\x2\x2\x624");
		sb.Append("\x623\x3\x2\x2\x2\x624\x625\x3\x2\x2\x2\x625\x628\x3\x2\x2\x2");
		sb.Append("\x626\x629\a?\x2\x2\x627\x629\a@\x2\x2\x628\x626\x3\x2\x2\x2");
		sb.Append("\x628\x627\x3\x2\x2\x2\x628\x629\x3\x2\x2\x2\x629\xCF\x3\x2");
		sb.Append("\x2\x2\x62A\x62B\az\x2\x2\x62B\x631\a\xC5\x2\x2\x62C\x62E\a");
		sb.Append("\x92\x2\x2\x62D\x62F\x5\x1A8\xD5\x2\x62E\x62D\x3\x2\x2\x2\x62E");
		sb.Append("\x62F\x3\x2\x2\x2\x62F\x630\x3\x2\x2\x2\x630\x632\a\x93\x2\x2");
		sb.Append("\x631\x62C\x3\x2\x2\x2\x631\x632\x3\x2\x2\x2\x632\xD1\x3\x2");
		sb.Append("\x2\x2\x633\x637\a\x41\x2\x2\x634\x636\x5\x14\v\x2\x635\x634");
		sb.Append("\x3\x2\x2\x2\x636\x639\x3\x2\x2\x2\x637\x635\x3\x2\x2\x2\x637");
		sb.Append("\x638\x3\x2\x2\x2\x638\x63A\x3\x2\x2\x2\x639\x637\x3\x2\x2\x2");
		sb.Append("\x63A\x63B\a\x94\x2\x2\x63B\x63C\x5\x166\xB4\x2\x63C\x63D\a");
		sb.Append("\x95\x2\x2\x63D\xD3\x3\x2\x2\x2\x63E\x63F\a\x42\x2\x2\x63F\x640");
		sb.Append("\a\x98\x2\x2\x640\x641\a\xC5\x2\x2\x641\x644\a\x94\x2\x2\x642");
		sb.Append("\x645\a\xC4\x2\x2\x643\x645\a\xC3\x2\x2\x644\x642\x3\x2\x2\x2");
		sb.Append("\x644\x643\x3\x2\x2\x2\x645\x64B\x3\x2\x2\x2\x646\x649\a\x43");
		sb.Append("\x2\x2\x647\x64A\a\xC4\x2\x2\x648\x64A\a\xC3\x2\x2\x649\x647");
		sb.Append("\x3\x2\x2\x2\x649\x648\x3\x2\x2\x2\x64A\x64C\x3\x2\x2\x2\x64B");
		sb.Append("\x646\x3\x2\x2\x2\x64B\x64C\x3\x2\x2\x2\x64C\x64D\x3\x2\x2\x2");
		sb.Append("\x64D\x64E\a\x95\x2\x2\x64E\xD5\x3\x2\x2\x2\x64F\x650\a\xC5");
		sb.Append("\x2\x2\x650\x651\a\x98\x2\x2\x651\x657\x5\x198\xCD\x2\x652\x654");
		sb.Append("\a\x92\x2\x2\x653\x655\x5\x1A8\xD5\x2\x654\x653\x3\x2\x2\x2");
		sb.Append("\x654\x655\x3\x2\x2\x2\x655\x656\x3\x2\x2\x2\x656\x658\a\x93");
		sb.Append("\x2\x2\x657\x652\x3\x2\x2\x2\x657\x658\x3\x2\x2\x2\x658\x65A");
		sb.Append("\x3\x2\x2\x2\x659\x65B\x5\x192\xCA\x2\x65A\x659\x3\x2\x2\x2");
		sb.Append("\x65A\x65B\x3\x2\x2\x2\x65B\xD7\x3\x2\x2\x2\x65C\x65D\a\xB7");
		sb.Append("\x2\x2\x65D\x662\x5\xDAn\x2\x65E\x65F\a\xB7\x2\x2\x65F\x661");
		sb.Append("\x5\xDAn\x2\x660\x65E\x3\x2\x2\x2\x661\x664\x3\x2\x2\x2\x662");
		sb.Append("\x660\x3\x2\x2\x2\x662\x663\x3\x2\x2\x2\x663\x66F\x3\x2\x2\x2");
		sb.Append("\x664\x662\x3\x2\x2\x2\x665\x666\a\xBE\x2\x2\x666\x66B\x5\xDC");
		sb.Append("o\x2\x667\x668\a\xBE\x2\x2\x668\x66A\x5\xDCo\x2\x669\x667\x3");
		sb.Append("\x2\x2\x2\x66A\x66D\x3\x2\x2\x2\x66B\x669\x3\x2\x2\x2\x66B\x66C");
		sb.Append("\x3\x2\x2\x2\x66C\x66F\x3\x2\x2\x2\x66D\x66B\x3\x2\x2\x2\x66E");
		sb.Append("\x65C\x3\x2\x2\x2\x66E\x665\x3\x2\x2\x2\x66F\xD9\x3\x2\x2\x2");
		sb.Append("\x670\x671\a\xC5\x2\x2\x671\x672\a\x98\x2\x2\x672\x673\x5\xDE");
		sb.Append("p\x2\x673\xDB\x3\x2\x2\x2\x674\x675\a\xC5\x2\x2\x675\x677\a");
		sb.Append("\x98\x2\x2\x676\x674\x3\x2\x2\x2\x676\x677\x3\x2\x2\x2\x677");
		sb.Append("\x678\x3\x2\x2\x2\x678\x679\x5\xDEp\x2\x679\xDD\x3\x2\x2\x2");
		sb.Append("\x67A\x67D\a\xC5\x2\x2\x67B\x67D\a}\x2\x2\x67C\x67A\x3\x2\x2");
		sb.Append("\x2\x67C\x67B\x3\x2\x2\x2\x67D\x683\x3\x2\x2\x2\x67E\x680\a");
		sb.Append("\x92\x2\x2\x67F\x681\x5\x1AA\xD6\x2\x680\x67F\x3\x2\x2\x2\x680");
		sb.Append("\x681\x3\x2\x2\x2\x681\x682\x3\x2\x2\x2\x682\x684\a\x93\x2\x2");
		sb.Append("\x683\x67E\x3\x2\x2\x2\x683\x684\x3\x2\x2\x2\x684\xDF\x3\x2");
		sb.Append("\x2\x2\x685\x68A\x5\xE2r\x2\x686\x687\a\x99\x2\x2\x687\x689");
		sb.Append("\x5\xE2r\x2\x688\x686\x3\x2\x2\x2\x689\x68C\x3\x2\x2\x2\x68A");
		sb.Append("\x688\x3\x2\x2\x2\x68A\x68B\x3\x2\x2\x2\x68B\xE1\x3\x2\x2\x2");
		sb.Append("\x68C\x68A\x3\x2\x2\x2\x68D\x691\x5\x122\x92\x2\x68E\x691\x5");
		sb.Append("\xE4s\x2\x68F\x691\x5\xE6t\x2\x690\x68D\x3\x2\x2\x2\x690\x68E");
		sb.Append("\x3\x2\x2\x2\x690\x68F\x3\x2\x2\x2\x691\xE3\x3\x2\x2\x2\x692");
		sb.Append("\x693\t\x5\x2\x2\x693\x694\a\x92\x2\x2\x694\x699\x5\xEAv\x2");
		sb.Append("\x695\x696\a\x99\x2\x2\x696\x698\x5\xEAv\x2\x697\x695\x3\x2");
		sb.Append("\x2\x2\x698\x69B\x3\x2\x2\x2\x699\x697\x3\x2\x2\x2\x699\x69A");
		sb.Append("\x3\x2\x2\x2\x69A\x69C\x3\x2\x2\x2\x69B\x699\x3\x2\x2\x2\x69C");
		sb.Append("\x69D\a\x93\x2\x2\x69D\xE5\x3\x2\x2\x2\x69E\x69F\a\x88\x2\x2");
		sb.Append("\x69F\x6A0\a\x8A\x2\x2\x6A0\x6A1\a\x92\x2\x2\x6A1\x6A6\x5\xE8");
		sb.Append("u\x2\x6A2\x6A3\a\x99\x2\x2\x6A3\x6A5\x5\xE8u\x2\x6A4\x6A2\x3");
		sb.Append("\x2\x2\x2\x6A5\x6A8\x3\x2\x2\x2\x6A6\x6A4\x3\x2\x2\x2\x6A6\x6A7");
		sb.Append("\x3\x2\x2\x2\x6A7\x6A9\x3\x2\x2\x2\x6A8\x6A6\x3\x2\x2\x2\x6A9");
		sb.Append("\x6AA\a\x93\x2\x2\x6AA\xE7\x3\x2\x2\x2\x6AB\x6AE\x5\xE4s\x2");
		sb.Append("\x6AC\x6AE\x5\xEAv\x2\x6AD\x6AB\x3\x2\x2\x2\x6AD\x6AC\x3\x2");
		sb.Append("\x2\x2\x6AE\xE9\x3\x2\x2\x2\x6AF\x6BD\x5\x122\x92\x2\x6B0\x6B9");
		sb.Append("\a\x92\x2\x2\x6B1\x6B6\x5\x122\x92\x2\x6B2\x6B3\a\x99\x2\x2");
		sb.Append("\x6B3\x6B5\x5\x122\x92\x2\x6B4\x6B2\x3\x2\x2\x2\x6B5\x6B8\x3");
		sb.Append("\x2\x2\x2\x6B6\x6B4\x3\x2\x2\x2\x6B6\x6B7\x3\x2\x2\x2\x6B7\x6BA");
		sb.Append("\x3\x2\x2\x2\x6B8\x6B6\x3\x2\x2\x2\x6B9\x6B1\x3\x2\x2\x2\x6B9");
		sb.Append("\x6BA\x3\x2\x2\x2\x6BA\x6BB\x3\x2\x2\x2\x6BB\x6BD\a\x93\x2\x2");
		sb.Append("\x6BC\x6AF\x3\x2\x2\x2\x6BC\x6B0\x3\x2\x2\x2\x6BD\xEB\x3\x2");
		sb.Append("\x2\x2\x6BE\x6C3\x5\xEEx\x2\x6BF\x6C0\a\x99\x2\x2\x6C0\x6C2");
		sb.Append("\x5\xEEx\x2\x6C1\x6BF\x3\x2\x2\x2\x6C2\x6C5\x3\x2\x2\x2\x6C3");
		sb.Append("\x6C1\x3\x2\x2\x2\x6C3\x6C4\x3\x2\x2\x2\x6C4\xED\x3\x2\x2\x2");
		sb.Append("\x6C5\x6C3\x3\x2\x2\x2\x6C6\x6C9\x5\x122\x92\x2\x6C7\x6CA\a");
		sb.Append("\x38\x2\x2\x6C8\x6CA\a\x39\x2\x2\x6C9\x6C7\x3\x2\x2\x2\x6C9");
		sb.Append("\x6C8\x3\x2\x2\x2\x6C9\x6CA\x3\x2\x2\x2\x6CA\xEF\x3\x2\x2\x2");
		sb.Append("\x6CB\x6CC\x5\x126\x94\x2\x6CC\xF1\x3\x2\x2\x2\x6CD\x6CF\x5");
		sb.Append("\xF6|\x2\x6CE\x6CD\x3\x2\x2\x2\x6CE\x6CF\x3\x2\x2\x2\x6CF\x6D4");
		sb.Append("\x3\x2\x2\x2\x6D0\x6D5\a-\x2\x2\x6D1\x6D5\a\x32\x2\x2\x6D2\x6D5");
		sb.Append("\a\x33\x2\x2\x6D3\x6D5\aQ\x2\x2\x6D4\x6D0\x3\x2\x2\x2\x6D4\x6D1");
		sb.Append("\x3\x2\x2\x2\x6D4\x6D2\x3\x2\x2\x2\x6D4\x6D3\x3\x2\x2\x2\x6D4");
		sb.Append("\x6D5\x3\x2\x2\x2\x6D5\x6F2\x3\x2\x2\x2\x6D6\x6DD\a\r\x2\x2");
		sb.Append("\x6D7\x6DE\x5\x1CE\xE8\x2\x6D8\x6DB\x5\x1E2\xF2\x2\x6D9\x6DB");
		sb.Append("\a\xC5\x2\x2\x6DA\x6D8\x3\x2\x2\x2\x6DA\x6D9\x3\x2\x2\x2\x6DB");
		sb.Append("\x6DC\x3\x2\x2\x2\x6DC\x6DE\a\x31\x2\x2\x6DD\x6D7\x3\x2\x2\x2");
		sb.Append("\x6DD\x6DA\x3\x2\x2\x2\x6DE\x6F3\x3\x2\x2\x2\x6DF\x6E0\aV\x2");
		sb.Append("\x2\x6E0\x6F3\x5\xFA~\x2\x6E1\x6E2\a\x1D\x2\x2\x6E2\x6E5\x5");
		sb.Append("\x122\x92\x2\x6E3\x6E4\a\x1E\x2\x2\x6E4\x6E6\x5\x46$\x2\x6E5");
		sb.Append("\x6E3\x3\x2\x2\x2\x6E5\x6E6\x3\x2\x2\x2\x6E6\x6F3\x3\x2\x2\x2");
		sb.Append("\x6E7\x6E8\a\x1D\x2\x2\x6E8\x6EB\a\x84\x2\x2\x6E9\x6EA\a\v\x2");
		sb.Append("\x2\x6EA\x6EC\x5\x122\x92\x2\x6EB\x6E9\x3\x2\x2\x2\x6EB\x6EC");
		sb.Append("\x3\x2\x2\x2\x6EC\x6EF\x3\x2\x2\x2\x6ED\x6EE\a\x1E\x2\x2\x6EE");
		sb.Append("\x6F0\x5\x46$\x2\x6EF\x6ED\x3\x2\x2\x2\x6EF\x6F0\x3\x2\x2\x2");
		sb.Append("\x6F0\x6F3\x3\x2\x2\x2\x6F1\x6F3\x3\x2\x2\x2\x6F2\x6D6\x3\x2");
		sb.Append("\x2\x2\x6F2\x6DF\x3\x2\x2\x2\x6F2\x6E1\x3\x2\x2\x2\x6F2\x6E7");
		sb.Append("\x3\x2\x2\x2\x6F2\x6F1\x3\x2\x2\x2\x6F3\x6F5\x3\x2\x2\x2\x6F4");
		sb.Append("\x6F6\x5\xF4{\x2\x6F5\x6F4\x3\x2\x2\x2\x6F5\x6F6\x3\x2\x2\x2");
		sb.Append("\x6F6\xF3\x3\x2\x2\x2\x6F7\x6F8\a\v\x2\x2\x6F8\x6F9\a\x1D\x2");
		sb.Append("\x2\x6F9\x6FC\a\x84\x2\x2\x6FA\x6FB\a\v\x2\x2\x6FB\x6FD\x5\x122");
		sb.Append("\x92\x2\x6FC\x6FA\x3\x2\x2\x2\x6FC\x6FD\x3\x2\x2\x2\x6FD\x700");
		sb.Append("\x3\x2\x2\x2\x6FE\x6FF\a\x1E\x2\x2\x6FF\x701\x5\x46$\x2\x700");
		sb.Append("\x6FE\x3\x2\x2\x2\x700\x701\x3\x2\x2\x2\x701\xF5\x3\x2\x2\x2");
		sb.Append("\x702\x707\ay\x2\x2\x703\x708\x5\x1CE\xE8\x2\x704\x705\x5\x1E2");
		sb.Append("\xF2\x2\x705\x706\a\x31\x2\x2\x706\x708\x3\x2\x2\x2\x707\x703");
		sb.Append("\x3\x2\x2\x2\x707\x704\x3\x2\x2\x2\x708\xF7\x3\x2\x2\x2\x709");
		sb.Append("\x70C\x5\x1E8\xF5\x2\x70A\x70C\a\xC5\x2\x2\x70B\x709\x3\x2\x2");
		sb.Append("\x2\x70B\x70A\x3\x2\x2\x2\x70C\x715\x3\x2\x2\x2\x70D\x710\a");
		sb.Append("\x99\x2\x2\x70E\x710\aq\x2\x2\x70F\x70D\x3\x2\x2\x2\x70F\x70E");
		sb.Append("\x3\x2\x2\x2\x710\x713\x3\x2\x2\x2\x711\x714\x5\x1E8\xF5\x2");
		sb.Append("\x712\x714\a\xC5\x2\x2\x713\x711\x3\x2\x2\x2\x713\x712\x3\x2");
		sb.Append("\x2\x2\x714\x716\x3\x2\x2\x2\x715\x70F\x3\x2\x2\x2\x715\x716");
		sb.Append("\x3\x2\x2\x2\x716\xF9\x3\x2\x2\x2\x717\x718\a\x92\x2\x2\x718");
		sb.Append("\x719\x5\x1AA\xD6\x2\x719\x71A\a\x93\x2\x2\x71A\xFB\x3\x2\x2");
		sb.Append("\x2\x71B\x71C\a\x1D\x2\x2\x71C\x71D\x5\x122\x92\x2\x71D\x71E");
		sb.Append("\a\x1E\x2\x2\x71E\x71F\x5\x122\x92\x2\x71F\xFD\x3\x2\x2\x2\x720");
		sb.Append("\x721\a\x1C\x2\x2\x721\x722\x5\x122\x92\x2\x722\xFF\x3\x2\x2");
		sb.Append("\x2\x723\x724\as\x2\x2\x724\x726\a\x92\x2\x2\x725\x727\x5\x102");
		sb.Append("\x82\x2\x726\x725\x3\x2\x2\x2\x726\x727\x3\x2\x2\x2\x727\x728");
		sb.Append("\x3\x2\x2\x2\x728\x72A\x5\x104\x83\x2\x729\x72B\x5\x108\x85");
		sb.Append("\x2\x72A\x729\x3\x2\x2\x2\x72A\x72B\x3\x2\x2\x2\x72B\x72D\x3");
		sb.Append("\x2\x2\x2\x72C\x72E\x5\x10C\x87\x2\x72D\x72C\x3\x2\x2\x2\x72D");
		sb.Append("\x72E\x3\x2\x2\x2\x72E\x72F\x3\x2\x2\x2\x72F\x731\x5\x10A\x86");
		sb.Append("\x2\x730\x732\x5\x10E\x88\x2\x731\x730\x3\x2\x2\x2\x731\x732");
		sb.Append("\x3\x2\x2\x2\x732\x734\x3\x2\x2\x2\x733\x735\x5\x11E\x90\x2");
		sb.Append("\x734\x733\x3\x2\x2\x2\x734\x735\x3\x2\x2\x2\x735\x736\x3\x2");
		sb.Append("\x2\x2\x736\x737\a\x93\x2\x2\x737\x101\x3\x2\x2\x2\x738\x739");
		sb.Append("\aw\x2\x2\x739\x73A\a)\x2\x2\x73A\x73F\x5\x122\x92\x2\x73B\x73C");
		sb.Append("\a\x99\x2\x2\x73C\x73E\x5\x122\x92\x2\x73D\x73B\x3\x2\x2\x2");
		sb.Append("\x73E\x741\x3\x2\x2\x2\x73F\x73D\x3\x2\x2\x2\x73F\x740\x3\x2");
		sb.Append("\x2\x2\x740\x103\x3\x2\x2\x2\x741\x73F\x3\x2\x2\x2\x742\x743");
		sb.Append("\au\x2\x2\x743\x748\x5\x106\x84\x2\x744\x745\a\x99\x2\x2\x745");
		sb.Append("\x747\x5\x106\x84\x2\x746\x744\x3\x2\x2\x2\x747\x74A\x3\x2\x2");
		sb.Append("\x2\x748\x746\x3\x2\x2\x2\x748\x749\x3\x2\x2\x2\x749\x105\x3");
		sb.Append("\x2\x2\x2\x74A\x748\x3\x2\x2\x2\x74B\x750\x5\x122\x92\x2\x74C");
		sb.Append("\x74E\a\x10\x2\x2\x74D\x74F\a\xC5\x2\x2\x74E\x74D\x3\x2\x2\x2");
		sb.Append("\x74E\x74F\x3\x2\x2\x2\x74F\x751\x3\x2\x2\x2\x750\x74C\x3\x2");
		sb.Append("\x2\x2\x750\x751\x3\x2\x2\x2\x751\x107\x3\x2\x2\x2\x752\x753");
		sb.Append("\a-\x2\x2\x753\x754\ax\x2\x2\x754\x109\x3\x2\x2\x2\x755\x756");
		sb.Append("\a\x41\x2\x2\x756\x757\a\x92\x2\x2\x757\x758\x5\x110\x89\x2");
		sb.Append("\x758\x759\a\x93\x2\x2\x759\x10B\x3\x2\x2\x2\x75A\x75B\ay\x2");
		sb.Append("\x2\x75B\x75C\x5\x1C8\xE5\x2\x75C\x75D\x5\x1C8\xE5\x2\x75D\x75E");
		sb.Append("\x5\x1C8\xE5\x2\x75E\x75F\x5\x1C8\xE5\x2\x75F\x760\x5\x1C8\xE5");
		sb.Append("\x2\x760\x10D\x3\x2\x2\x2\x761\x762\a\xC5\x2\x2\x762\x765\x5");
		sb.Append("\x1CE\xE8\x2\x763\x764\a\n\x2\x2\x764\x766\a\x84\x2\x2\x765");
		sb.Append("\x763\x3\x2\x2\x2\x765\x766\x3\x2\x2\x2\x766\x10F\x3\x2\x2\x2");
		sb.Append("\x767\x76C\x5\x112\x8A\x2\x768\x769\a\xB0\x2\x2\x769\x76B\x5");
		sb.Append("\x112\x8A\x2\x76A\x768\x3\x2\x2\x2\x76B\x76E\x3\x2\x2\x2\x76C");
		sb.Append("\x76A\x3\x2\x2\x2\x76C\x76D\x3\x2\x2\x2\x76D\x111\x3\x2\x2\x2");
		sb.Append("\x76E\x76C\x3\x2\x2\x2\x76F\x771\x5\x114\x8B\x2\x770\x76F\x3");
		sb.Append("\x2\x2\x2\x771\x772\x3\x2\x2\x2\x772\x770\x3\x2\x2\x2\x772\x773");
		sb.Append("\x3\x2\x2\x2\x773\x113\x3\x2\x2\x2\x774\x778\x5\x118\x8D\x2");
		sb.Append("\x775\x778\x5\x116\x8C\x2\x776\x778\x5\x11A\x8E\x2\x777\x774");
		sb.Append("\x3\x2\x2\x2\x777\x775\x3\x2\x2\x2\x777\x776\x3\x2\x2\x2\x778");
		sb.Append("\x115\x3\x2\x2\x2\x779\x77A\a\x92\x2\x2\x77A\x77B\x5\x110\x89");
		sb.Append("\x2\x77B\x77F\a\x93\x2\x2\x77C\x780\a\xA6\x2\x2\x77D\x780\a");
		sb.Append("\xA0\x2\x2\x77E\x780\a\x91\x2\x2\x77F\x77C\x3\x2\x2\x2\x77F");
		sb.Append("\x77D\x3\x2\x2\x2\x77F\x77E\x3\x2\x2\x2\x77F\x780\x3\x2\x2\x2");
		sb.Append("\x780\x782\x3\x2\x2\x2\x781\x783\x5\x11C\x8F\x2\x782\x781\x3");
		sb.Append("\x2\x2\x2\x782\x783\x3\x2\x2\x2\x783\x117\x3\x2\x2\x2\x784\x785");
		sb.Append("\at\x2\x2\x785\x786\a\x92\x2\x2\x786\x78B\x5\x110\x89\x2\x787");
		sb.Append("\x788\a\x99\x2\x2\x788\x78A\x5\x110\x89\x2\x789\x787\x3\x2\x2");
		sb.Append("\x2\x78A\x78D\x3\x2\x2\x2\x78B\x789\x3\x2\x2\x2\x78B\x78C\x3");
		sb.Append("\x2\x2\x2\x78C\x78E\x3\x2\x2\x2\x78D\x78B\x3\x2\x2\x2\x78E\x78F");
		sb.Append("\a\x93\x2\x2\x78F\x119\x3\x2\x2\x2\x790\x799\a\xC5\x2\x2\x791");
		sb.Append("\x795\a\xA6\x2\x2\x792\x795\a\xA0\x2\x2\x793\x795\a\x91\x2\x2");
		sb.Append("\x794\x791\x3\x2\x2\x2\x794\x792\x3\x2\x2\x2\x794\x793\x3\x2");
		sb.Append("\x2\x2\x795\x797\x3\x2\x2\x2\x796\x798\a\x91\x2\x2\x797\x796");
		sb.Append("\x3\x2\x2\x2\x797\x798\x3\x2\x2\x2\x798\x79A\x3\x2\x2\x2\x799");
		sb.Append("\x794\x3\x2\x2\x2\x799\x79A\x3\x2\x2\x2\x79A\x79C\x3\x2\x2\x2");
		sb.Append("\x79B\x79D\x5\x11C\x8F\x2\x79C\x79B\x3\x2\x2\x2\x79C\x79D\x3");
		sb.Append("\x2\x2\x2\x79D\x11B\x3\x2\x2\x2\x79E\x7A0\a\x96\x2\x2\x79F\x7A1");
		sb.Append("\x5\x122\x92\x2\x7A0\x79F\x3\x2\x2\x2\x7A0\x7A1\x3\x2\x2\x2");
		sb.Append("\x7A1\x7A3\x3\x2\x2\x2\x7A2\x7A4\a\x99\x2\x2\x7A3\x7A2\x3\x2");
		sb.Append("\x2\x2\x7A3\x7A4\x3\x2\x2\x2\x7A4\x7A6\x3\x2\x2\x2\x7A5\x7A7");
		sb.Append("\x5\x122\x92\x2\x7A6\x7A5\x3\x2\x2\x2\x7A6\x7A7\x3\x2\x2\x2");
		sb.Append("\x7A7\x7A8\x3\x2\x2\x2\x7A8\x7A9\a\x97\x2\x2\x7A9\x11D\x3\x2");
		sb.Append("\x2\x2\x7AA\x7AB\av\x2\x2\x7AB\x7B0\x5\x120\x91\x2\x7AC\x7AD");
		sb.Append("\a\x99\x2\x2\x7AD\x7AF\x5\x120\x91\x2\x7AE\x7AC\x3\x2\x2\x2");
		sb.Append("\x7AF\x7B2\x3\x2\x2\x2\x7B0\x7AE\x3\x2\x2\x2\x7B0\x7B1\x3\x2");
		sb.Append("\x2\x2\x7B1\x11F\x3\x2\x2\x2\x7B2\x7B0\x3\x2\x2\x2\x7B3\x7B4");
		sb.Append("\a\xC5\x2\x2\x7B4\x7B5\a\x10\x2\x2\x7B5\x7B6\x5\x122\x92\x2");
		sb.Append("\x7B6\x121\x3\x2\x2\x2\x7B7\x7B8\x5\x124\x93\x2\x7B8\x123\x3");
		sb.Append("\x2\x2\x2\x7B9\x7BA\b\x93\x1\x2\x7BA\x7BC\a\x1B\x2\x2\x7BB\x7BD");
		sb.Append("\x5\xFC\x7F\x2\x7BC\x7BB\x3\x2\x2\x2\x7BD\x7BE\x3\x2\x2\x2\x7BE");
		sb.Append("\x7BC\x3\x2\x2\x2\x7BE\x7BF\x3\x2\x2\x2\x7BF\x7C1\x3\x2\x2\x2");
		sb.Append("\x7C0\x7C2\x5\xFE\x80\x2\x7C1\x7C0\x3\x2\x2\x2\x7C1\x7C2\x3");
		sb.Append("\x2\x2\x2\x7C2\x7C3\x3\x2\x2\x2\x7C3\x7C4\a\x1F\x2\x2\x7C4\x7C5");
		sb.Append("\b\x93\x1\x2\x7C5\x7D6\x3\x2\x2\x2\x7C6\x7C7\b\x93\x1\x2\x7C7");
		sb.Append("\x7C8\a\x1B\x2\x2\x7C8\x7CA\x5\x122\x92\x2\x7C9\x7CB\x5\xFC");
		sb.Append("\x7F\x2\x7CA\x7C9\x3\x2\x2\x2\x7CB\x7CC\x3\x2\x2\x2\x7CC\x7CA");
		sb.Append("\x3\x2\x2\x2\x7CC\x7CD\x3\x2\x2\x2\x7CD\x7CF\x3\x2\x2\x2\x7CE");
		sb.Append("\x7D0\x5\xFE\x80\x2\x7CF\x7CE\x3\x2\x2\x2\x7CF\x7D0\x3\x2\x2");
		sb.Append("\x2\x7D0\x7D1\x3\x2\x2\x2\x7D1\x7D2\a\x1F\x2\x2\x7D2\x7D3\b");
		sb.Append("\x93\x1\x2\x7D3\x7D6\x3\x2\x2\x2\x7D4\x7D6\x5\x126\x94\x2\x7D5");
		sb.Append("\x7B9\x3\x2\x2\x2\x7D5\x7C6\x3\x2\x2\x2\x7D5\x7D4\x3\x2\x2\x2");
		sb.Append("\x7D6\x125\x3\x2\x2\x2\x7D7\x7DC\x5\x128\x95\x2\x7D8\x7D9\a");
		sb.Append("\n\x2\x2\x7D9\x7DB\x5\x128\x95\x2\x7DA\x7D8\x3\x2\x2\x2\x7DB");
		sb.Append("\x7DE\x3\x2\x2\x2\x7DC\x7DA\x3\x2\x2\x2\x7DC\x7DD\x3\x2\x2\x2");
		sb.Append("\x7DD\x127\x3\x2\x2\x2\x7DE\x7DC\x3\x2\x2\x2\x7DF\x7E4\x5\x12A");
		sb.Append("\x96\x2\x7E0\x7E1\a\v\x2\x2\x7E1\x7E3\x5\x12A\x96\x2\x7E2\x7E0");
		sb.Append("\x3\x2\x2\x2\x7E3\x7E6\x3\x2\x2\x2\x7E4\x7E2\x3\x2\x2\x2\x7E4");
		sb.Append("\x7E5\x3\x2\x2\x2\x7E5\x129\x3\x2\x2\x2\x7E6\x7E4\x3\x2\x2\x2");
		sb.Append("\x7E7\x7EC\x5\x12C\x97\x2\x7E8\x7E9\t\x6\x2\x2\x7E9\x7EB\x5");
		sb.Append("\x12C\x97\x2\x7EA\x7E8\x3\x2\x2\x2\x7EB\x7EE\x3\x2\x2\x2\x7EC");
		sb.Append("\x7EA\x3\x2\x2\x2\x7EC\x7ED\x3\x2\x2\x2\x7ED\x12B\x3\x2\x2\x2");
		sb.Append("\x7EE\x7EC\x3\x2\x2\x2\x7EF\x7F3\x5\x12E\x98\x2\x7F0\x7F1\a");
		sb.Append("\f\x2\x2\x7F1\x7F3\x5\x12E\x98\x2\x7F2\x7EF\x3\x2\x2\x2\x7F2");
		sb.Append("\x7F0\x3\x2\x2\x2\x7F3\x12D\x3\x2\x2\x2\x7F4\x80F\x5\x130\x99");
		sb.Append("\x2\x7F5\x7FC\a\x8F\x2\x2\x7F6\x7FC\a(\x2\x2\x7F7\x7F8\a(\x2");
		sb.Append("\x2\x7F8\x7FC\a\f\x2\x2\x7F9\x7FC\a\x90\x2\x2\x7FA\x7FC\a\x9D");
		sb.Append("\x2\x2\x7FB\x7F5\x3\x2\x2\x2\x7FB\x7F6\x3\x2\x2\x2\x7FB\x7F7");
		sb.Append("\x3\x2\x2\x2\x7FB\x7F9\x3\x2\x2\x2\x7FB\x7FA\x3\x2\x2\x2\x7FC");
		sb.Append("\x80B\x3\x2\x2\x2\x7FD\x80C\x5\x130\x99\x2\x7FE\x802\a.\x2\x2");
		sb.Append("\x7FF\x802\a/\x2\x2\x800\x802\a-\x2\x2\x801\x7FE\x3\x2\x2\x2");
		sb.Append("\x801\x7FF\x3\x2\x2\x2\x801\x800\x3\x2\x2\x2\x802\x809\x3\x2");
		sb.Append("\x2\x2\x803\x805\a\x92\x2\x2\x804\x806\x5\x1A8\xD5\x2\x805\x804");
		sb.Append("\x3\x2\x2\x2\x805\x806\x3\x2\x2\x2\x806\x807\x3\x2\x2\x2\x807");
		sb.Append("\x80A\a\x93\x2\x2\x808\x80A\x5\x144\xA3\x2\x809\x803\x3\x2\x2");
		sb.Append("\x2\x809\x808\x3\x2\x2\x2\x80A\x80C\x3\x2\x2\x2\x80B\x7FD\x3");
		sb.Append("\x2\x2\x2\x80B\x801\x3\x2\x2\x2\x80C\x80E\x3\x2\x2\x2\x80D\x7FB");
		sb.Append("\x3\x2\x2\x2\x80E\x811\x3\x2\x2\x2\x80F\x80D\x3\x2\x2\x2\x80F");
		sb.Append("\x810\x3\x2\x2\x2\x810\x12F\x3\x2\x2\x2\x811\x80F\x3\x2\x2\x2");
		sb.Append("\x812\x854\x5\x134\x9B\x2\x813\x818\a\xAD\x2\x2\x814\x818\a");
		sb.Append("\xAB\x2\x2\x815\x818\a\xAC\x2\x2\x816\x818\a\xAA\x2\x2\x817");
		sb.Append("\x813\x3\x2\x2\x2\x817\x814\x3\x2\x2\x2\x817\x815\x3\x2\x2\x2");
		sb.Append("\x817\x816\x3\x2\x2\x2\x818\x827\x3\x2\x2\x2\x819\x828\x5\x134");
		sb.Append("\x9B\x2\x81A\x81E\a.\x2\x2\x81B\x81E\a/\x2\x2\x81C\x81E\a-\x2");
		sb.Append("\x2\x81D\x81A\x3\x2\x2\x2\x81D\x81B\x3\x2\x2\x2\x81D\x81C\x3");
		sb.Append("\x2\x2\x2\x81E\x825\x3\x2\x2\x2\x81F\x821\a\x92\x2\x2\x820\x822");
		sb.Append("\x5\x1A8\xD5\x2\x821\x820\x3\x2\x2\x2\x821\x822\x3\x2\x2\x2");
		sb.Append("\x822\x823\x3\x2\x2\x2\x823\x826\a\x93\x2\x2\x824\x826\x5\x144");
		sb.Append("\xA3\x2\x825\x81F\x3\x2\x2\x2\x825\x824\x3\x2\x2\x2\x826\x828");
		sb.Append("\x3\x2\x2\x2\x827\x819\x3\x2\x2\x2\x827\x81D\x3\x2\x2\x2\x828");
		sb.Append("\x82A\x3\x2\x2\x2\x829\x817\x3\x2\x2\x2\x82A\x82D\x3\x2\x2\x2");
		sb.Append("\x82B\x829\x3\x2\x2\x2\x82B\x82C\x3\x2\x2\x2\x82C\x855\x3\x2");
		sb.Append("\x2\x2\x82D\x82B\x3\x2\x2\x2\x82E\x830\a\f\x2\x2\x82F\x82E\x3");
		sb.Append("\x2\x2\x2\x82F\x830\x3\x2\x2\x2\x830\x852\x3\x2\x2\x2\x831\x834");
		sb.Append("\a\x5\x2\x2\x832\x835\a\x92\x2\x2\x833\x835\a\x94\x2\x2\x834");
		sb.Append("\x832\x3\x2\x2\x2\x834\x833\x3\x2\x2\x2\x835\x836\x3\x2\x2\x2");
		sb.Append("\x836\x840\x5\x122\x92\x2\x837\x838\a\x98\x2\x2\x838\x841\x5");
		sb.Append("\x122\x92\x2\x839\x83A\a\x99\x2\x2\x83A\x83C\x5\x122\x92\x2");
		sb.Append("\x83B\x839\x3\x2\x2\x2\x83C\x83F\x3\x2\x2\x2\x83D\x83B\x3\x2");
		sb.Append("\x2\x2\x83D\x83E\x3\x2\x2\x2\x83E\x841\x3\x2\x2\x2\x83F\x83D");
		sb.Append("\x3\x2\x2\x2\x840\x837\x3\x2\x2\x2\x840\x83D\x3\x2\x2\x2\x841");
		sb.Append("\x844\x3\x2\x2\x2\x842\x845\a\x93\x2\x2\x843\x845\a\x95\x2\x2");
		sb.Append("\x844\x842\x3\x2\x2\x2\x844\x843\x3\x2\x2\x2\x845\x853\x3\x2");
		sb.Append("\x2\x2\x846\x847\a\x5\x2\x2\x847\x853\x5\x132\x9A\x2\x848\x849");
		sb.Append("\a\x6\x2\x2\x849\x853\x5\x164\xB3\x2\x84A\x84B\a\a\x2\x2\x84B");
		sb.Append("\x84E\x5\x134\x9B\x2\x84C\x84D\a\t\x2\x2\x84D\x84F\x5\x1EA\xF6");
		sb.Append("\x2\x84E\x84C\x3\x2\x2\x2\x84E\x84F\x3\x2\x2\x2\x84F\x853\x3");
		sb.Append("\x2\x2\x2\x850\x851\a\b\x2\x2\x851\x853\x5\x134\x9B\x2\x852");
		sb.Append("\x831\x3\x2\x2\x2\x852\x846\x3\x2\x2\x2\x852\x848\x3\x2\x2\x2");
		sb.Append("\x852\x84A\x3\x2\x2\x2\x852\x850\x3\x2\x2\x2\x853\x855\x3\x2");
		sb.Append("\x2\x2\x854\x82B\x3\x2\x2\x2\x854\x82F\x3\x2\x2\x2\x855\x131");
		sb.Append("\x3\x2\x2\x2\x856\x857\x5\x148\xA5\x2\x857\x133\x3\x2\x2\x2");
		sb.Append("\x858\x862\x5\x136\x9C\x2\x859\x85A\a\xB2\x2\x2\x85A\x85F\x5");
		sb.Append("\x136\x9C\x2\x85B\x85C\a\xB2\x2\x2\x85C\x85E\x5\x136\x9C\x2");
		sb.Append("\x85D\x85B\x3\x2\x2\x2\x85E\x861\x3\x2\x2\x2\x85F\x85D\x3\x2");
		sb.Append("\x2\x2\x85F\x860\x3\x2\x2\x2\x860\x863\x3\x2\x2\x2\x861\x85F");
		sb.Append("\x3\x2\x2\x2\x862\x859\x3\x2\x2\x2\x862\x863\x3\x2\x2\x2\x863");
		sb.Append("\x135\x3\x2\x2\x2\x864\x869\x5\x138\x9D\x2\x865\x866\t\a\x2");
		sb.Append("\x2\x866\x868\x5\x138\x9D\x2\x867\x865\x3\x2\x2\x2\x868\x86B");
		sb.Append("\x3\x2\x2\x2\x869\x867\x3\x2\x2\x2\x869\x86A\x3\x2\x2\x2\x86A");
		sb.Append("\x137\x3\x2\x2\x2\x86B\x869\x3\x2\x2\x2\x86C\x871\x5\x13A\x9E");
		sb.Append("\x2\x86D\x86E\t\b\x2\x2\x86E\x870\x5\x13A\x9E\x2\x86F\x86D\x3");
		sb.Append("\x2\x2\x2\x870\x873\x3\x2\x2\x2\x871\x86F\x3\x2\x2\x2\x871\x872");
		sb.Append("\x3\x2\x2\x2\x872\x139\x3\x2\x2\x2\x873\x871\x3\x2\x2\x2\x874");
		sb.Append("\x875\a\xA3\x2\x2\x875\x8B0\x5\x1C2\xE2\x2\x876\x8B0\x5\x1E6");
		sb.Append("\xF4\x2\x877\x8B0\x5\x13C\x9F\x2\x878\x879\a\x92\x2\x2\x879");
		sb.Append("\x87A\x5\x122\x92\x2\x87A\x87C\a\x93\x2\x2\x87B\x87D\x5\x13E");
		sb.Append("\xA0\x2\x87C\x87B\x3\x2\x2\x2\x87C\x87D\x3\x2\x2\x2\x87D\x8B0");
		sb.Append("\x3\x2\x2\x2\x87E\x8B0\x5\x14E\xA8\x2\x87F\x8B0\x5\x152\xAA");
		sb.Append("\x2\x880\x8B0\x5\x14C\xA7\x2\x881\x8B0\x5\x142\xA2\x2\x882\x8B0");
		sb.Append("\x5\x146\xA4\x2\x883\x884\a\x80\x2\x2\x884\x885\a\x96\x2\x2");
		sb.Append("\x885\x88A\x5\x140\xA1\x2\x886\x887\a\x99\x2\x2\x887\x889\x5");
		sb.Append("\x140\xA1\x2\x888\x886\x3\x2\x2\x2\x889\x88C\x3\x2\x2\x2\x88A");
		sb.Append("\x888\x3\x2\x2\x2\x88A\x88B\x3\x2\x2\x2\x88B\x88D\x3\x2\x2\x2");
		sb.Append("\x88C\x88A\x3\x2\x2\x2\x88D\x88E\a\x97\x2\x2\x88E\x8B0\x3\x2");
		sb.Append("\x2\x2\x88F\x890\a\x80\x2\x2\x890\x891\x5\x198\xCD\x2\x891\x89A");
		sb.Append("\a\x92\x2\x2\x892\x897\x5\x122\x92\x2\x893\x894\a\x99\x2\x2");
		sb.Append("\x894\x896\x5\x122\x92\x2\x895\x893\x3\x2\x2\x2\x896\x899\x3");
		sb.Append("\x2\x2\x2\x897\x895\x3\x2\x2\x2\x897\x898\x3\x2\x2\x2\x898\x89B");
		sb.Append("\x3\x2\x2\x2\x899\x897\x3\x2\x2\x2\x89A\x892\x3\x2\x2\x2\x89A");
		sb.Append("\x89B\x3\x2\x2\x2\x89B\x89C\x3\x2\x2\x2\x89C\x89E\a\x93\x2\x2");
		sb.Append("\x89D\x89F\x5\x13E\xA0\x2\x89E\x89D\x3\x2\x2\x2\x89E\x89F\x3");
		sb.Append("\x2\x2\x2\x89F\x8B0\x3\x2\x2\x2\x8A0\x8A1\a\xC5\x2\x2\x8A1\x8A2");
		sb.Append("\a\x94\x2\x2\x8A2\x8A7\x5\x122\x92\x2\x8A3\x8A4\a\x99\x2\x2");
		sb.Append("\x8A4\x8A6\x5\x122\x92\x2\x8A5\x8A3\x3\x2\x2\x2\x8A6\x8A9\x3");
		sb.Append("\x2\x2\x2\x8A7\x8A5\x3\x2\x2\x2\x8A7\x8A8\x3\x2\x2\x2\x8A8\x8AA");
		sb.Append("\x3\x2\x2\x2\x8A9\x8A7\x3\x2\x2\x2\x8AA\x8AC\a\x95\x2\x2\x8AB");
		sb.Append("\x8AD\x5\x13E\xA0\x2\x8AC\x8AB\x3\x2\x2\x2\x8AC\x8AD\x3\x2\x2");
		sb.Append("\x2\x8AD\x8B0\x3\x2\x2\x2\x8AE\x8B0\x5\x1EE\xF8\x2\x8AF\x874");
		sb.Append("\x3\x2\x2\x2\x8AF\x876\x3\x2\x2\x2\x8AF\x877\x3\x2\x2\x2\x8AF");
		sb.Append("\x878\x3\x2\x2\x2\x8AF\x87E\x3\x2\x2\x2\x8AF\x87F\x3\x2\x2\x2");
		sb.Append("\x8AF\x880\x3\x2\x2\x2\x8AF\x881\x3\x2\x2\x2\x8AF\x882\x3\x2");
		sb.Append("\x2\x2\x8AF\x883\x3\x2\x2\x2\x8AF\x88F\x3\x2\x2\x2\x8AF\x8A0");
		sb.Append("\x3\x2\x2\x2\x8AF\x8AE\x3\x2\x2\x2\x8B0\x13B\x3\x2\x2\x2\x8B1");
		sb.Append("\x8B3\x5\x1E4\xF3\x2\x8B2\x8B4\x5\x13E\xA0\x2\x8B3\x8B2\x3\x2");
		sb.Append("\x2\x2\x8B3\x8B4\x3\x2\x2\x2\x8B4\x13D\x3\x2\x2\x2\x8B5\x8B6");
		sb.Append("\a\xB7\x2\x2\x8B6\x8BB\x5\x158\xAD\x2\x8B7\x8B8\a\xB7\x2\x2");
		sb.Append("\x8B8\x8BA\x5\x158\xAD\x2\x8B9\x8B7\x3\x2\x2\x2\x8BA\x8BD\x3");
		sb.Append("\x2\x2\x2\x8BB\x8B9\x3\x2\x2\x2\x8BB\x8BC\x3\x2\x2\x2\x8BC\x13F");
		sb.Append("\x3\x2\x2\x2\x8BD\x8BB\x3\x2\x2\x2\x8BE\x8C1\x5\x1C2\xE2\x2");
		sb.Append("\x8BF\x8C0\a\x8F\x2\x2\x8C0\x8C2\x5\x122\x92\x2\x8C1\x8BF\x3");
		sb.Append("\x2\x2\x2\x8C1\x8C2\x3\x2\x2\x2\x8C2\x141\x3\x2\x2\x2\x8C3\x8C5");
		sb.Append("\x5\x148\xA5\x2\x8C4\x8C6\x5\x13E\xA0\x2\x8C5\x8C4\x3\x2\x2");
		sb.Append("\x2\x8C5\x8C6\x3\x2\x2\x2\x8C6\x143\x3\x2\x2\x2\x8C7\x8C8\x5");
		sb.Append("\x148\xA5\x2\x8C8\x145\x3\x2\x2\x2\x8C9\x8CA\aI\x2\x2\x8CA\x8CB");
		sb.Append("\x5\x148\xA5\x2\x8CB\x147\x3\x2\x2\x2\x8CC\x8CD\a\x92\x2\x2");
		sb.Append("\x8CD\x8CF\a\x1A\x2\x2\x8CE\x8D0\a,\x2\x2\x8CF\x8CE\x3\x2\x2");
		sb.Append("\x2\x8CF\x8D0\x3\x2\x2\x2\x8D0\x8D1\x3\x2\x2\x2\x8D1\x8D2\x5");
		sb.Append("\xC4\x63\x2\x8D2\x8D3\a \x2\x2\x8D3\x8D6\x5\x14A\xA6\x2\x8D4");
		sb.Append("\x8D5\a\xF\x2\x2\x8D5\x8D7\x5\xC0\x61\x2\x8D6\x8D4\x3\x2\x2");
		sb.Append("\x2\x8D6\x8D7\x3\x2\x2\x2\x8D7\x8DB\x3\x2\x2\x2\x8D8\x8D9\a");
		sb.Append("*\x2\x2\x8D9\x8DA\a)\x2\x2\x8DA\x8DC\x5\xE0q\x2\x8DB\x8D8\x3");
		sb.Append("\x2\x2\x2\x8DB\x8DC\x3\x2\x2\x2\x8DC\x8DF\x3\x2\x2\x2\x8DD\x8DE");
		sb.Append("\a+\x2\x2\x8DE\x8E0\x5\xF0y\x2\x8DF\x8DD\x3\x2\x2\x2\x8DF\x8E0");
		sb.Append("\x3\x2\x2\x2\x8E0\x8E1\x3\x2\x2\x2\x8E1\x8E2\a\x93\x2\x2\x8E2");
		sb.Append("\x149\x3\x2\x2\x2\x8E3\x8E5\x5\x184\xC3\x2\x8E4\x8E6\x5\xD8");
		sb.Append("m\x2\x8E5\x8E4\x3\x2\x2\x2\x8E5\x8E6\x3\x2\x2\x2\x8E6\x8EA\x3");
		sb.Append("\x2\x2\x2\x8E7\x8E8\a\x10\x2\x2\x8E8\x8EB\a\xC5\x2\x2\x8E9\x8EB");
		sb.Append("\a\xC5\x2\x2\x8EA\x8E7\x3\x2\x2\x2\x8EA\x8E9\x3\x2\x2\x2\x8EA");
		sb.Append("\x8EB\x3\x2\x2\x2\x8EB\x8EE\x3\x2\x2\x2\x8EC\x8EF\a?\x2\x2\x8ED");
		sb.Append("\x8EF\a@\x2\x2\x8EE\x8EC\x3\x2\x2\x2\x8EE\x8ED\x3\x2\x2\x2\x8EE");
		sb.Append("\x8EF\x3\x2\x2\x2\x8EF\x14B\x3\x2\x2\x2\x8F0\x8F9\a\x96\x2\x2");
		sb.Append("\x8F1\x8F6\x5\x122\x92\x2\x8F2\x8F3\a\x99\x2\x2\x8F3\x8F5\x5");
		sb.Append("\x122\x92\x2\x8F4\x8F2\x3\x2\x2\x2\x8F5\x8F8\x3\x2\x2\x2\x8F6");
		sb.Append("\x8F4\x3\x2\x2\x2\x8F6\x8F7\x3\x2\x2\x2\x8F7\x8FA\x3\x2\x2\x2");
		sb.Append("\x8F8\x8F6\x3\x2\x2\x2\x8F9\x8F1\x3\x2\x2\x2\x8F9\x8FA\x3\x2");
		sb.Append("\x2\x2\x8FA\x8FB\x3\x2\x2\x2\x8FB\x8FD\a\x97\x2\x2\x8FC\x8FE");
		sb.Append("\x5\x13E\xA0\x2\x8FD\x8FC\x3\x2\x2\x2\x8FD\x8FE\x3\x2\x2\x2");
		sb.Append("\x8FE\x14D\x3\x2\x2\x2\x8FF\x900\a\x11\x2\x2\x900\x902\a\x92");
		sb.Append("\x2\x2\x901\x903\t\t\x2\x2\x902\x901\x3\x2\x2\x2\x902\x903\x3");
		sb.Append("\x2\x2\x2\x903\x904\x3\x2\x2\x2\x904\x905\x5\x19C\xCF\x2\x905");
		sb.Append("\x906\a\x93\x2\x2\x906\x9A3\x3\x2\x2\x2\x907\x908\a\x12\x2\x2");
		sb.Append("\x908\x90A\a\x92\x2\x2\x909\x90B\t\t\x2\x2\x90A\x909\x3\x2\x2");
		sb.Append("\x2\x90A\x90B\x3\x2\x2\x2\x90B\x90C\x3\x2\x2\x2\x90C\x90D\x5");
		sb.Append("\x19C\xCF\x2\x90D\x90E\a\x93\x2\x2\x90E\x9A3\x3\x2\x2\x2\x90F");
		sb.Append("\x910\a\x19\x2\x2\x910\x913\a\x92\x2\x2\x911\x914\a-\x2\x2\x912");
		sb.Append("\x914\a,\x2\x2\x913\x911\x3\x2\x2\x2\x913\x912\x3\x2\x2\x2\x913");
		sb.Append("\x914\x3\x2\x2\x2\x914\x915\x3\x2\x2\x2\x915\x916\x5\x19C\xCF");
		sb.Append("\x2\x916\x917\a\x93\x2\x2\x917\x9A3\x3\x2\x2\x2\x918\x919\a");
		sb.Append("\x16\x2\x2\x919\x91B\a\x92\x2\x2\x91A\x91C\t\t\x2\x2\x91B\x91A");
		sb.Append("\x3\x2\x2\x2\x91B\x91C\x3\x2\x2\x2\x91C\x91D\x3\x2\x2\x2\x91D");
		sb.Append("\x91E\x5\x19C\xCF\x2\x91E\x91F\a\x93\x2\x2\x91F\x9A3\x3\x2\x2");
		sb.Append("\x2\x920\x921\a\x17\x2\x2\x921\x923\a\x92\x2\x2\x922\x924\t");
		sb.Append("\t\x2\x2\x923\x922\x3\x2\x2\x2\x923\x924\x3\x2\x2\x2\x924\x925");
		sb.Append("\x3\x2\x2\x2\x925\x926\x5\x19C\xCF\x2\x926\x927\a\x93\x2\x2");
		sb.Append("\x927\x9A3\x3\x2\x2\x2\x928\x929\a\x18\x2\x2\x929\x92B\a\x92");
		sb.Append("\x2\x2\x92A\x92C\t\t\x2\x2\x92B\x92A\x3\x2\x2\x2\x92B\x92C\x3");
		sb.Append("\x2\x2\x2\x92C\x92D\x3\x2\x2\x2\x92D\x92E\x5\x19C\xCF\x2\x92E");
		sb.Append("\x92F\a\x93\x2\x2\x92F\x9A3\x3\x2\x2\x2\x930\x9A3\x5\x150\xA9");
		sb.Append("\x2\x931\x932\a\x15\x2\x2\x932\x933\a\x92\x2\x2\x933\x934\x5");
		sb.Append("\x122\x92\x2\x934\x935\a\x99\x2\x2\x935\x93A\x5\x122\x92\x2");
		sb.Append("\x936\x937\a\x99\x2\x2\x937\x939\x5\x122\x92\x2\x938\x936\x3");
		sb.Append("\x2\x2\x2\x939\x93C\x3\x2\x2\x2\x93A\x938\x3\x2\x2\x2\x93A\x93B");
		sb.Append("\x3\x2\x2\x2\x93B\x93D\x3\x2\x2\x2\x93C\x93A\x3\x2\x2\x2\x93D");
		sb.Append("\x93E\a\x93\x2\x2\x93E\x9A3\x3\x2\x2\x2\x93F\x940\a\x44\x2\x2");
		sb.Append("\x940\x941\a\x92\x2\x2\x941\x944\x5\x122\x92\x2\x942\x943\a");
		sb.Append("\x99\x2\x2\x943\x945\x5\x122\x92\x2\x944\x942\x3\x2\x2\x2\x944");
		sb.Append("\x945\x3\x2\x2\x2\x945\x946\x3\x2\x2\x2\x946\x948\a\x93\x2\x2");
		sb.Append("\x947\x949\x5\x13E\xA0\x2\x948\x947\x3\x2\x2\x2\x948\x949\x3");
		sb.Append("\x2\x2\x2\x949\x9A3\x3\x2\x2\x2\x94A\x94B\a\x45\x2\x2\x94B\x94C");
		sb.Append("\a\x92\x2\x2\x94C\x94F\x5\x122\x92\x2\x94D\x94E\a\x99\x2\x2");
		sb.Append("\x94E\x950\x5\x122\x92\x2\x94F\x94D\x3\x2\x2\x2\x94F\x950\x3");
		sb.Append("\x2\x2\x2\x950\x951\x3\x2\x2\x2\x951\x953\a\x93\x2\x2\x952\x954");
		sb.Append("\x5\x13E\xA0\x2\x953\x952\x3\x2\x2\x2\x953\x954\x3\x2\x2\x2");
		sb.Append("\x954\x9A3\x3\x2\x2\x2\x955\x956\a\x46\x2\x2\x956\x957\a\x92");
		sb.Append("\x2\x2\x957\x958\x5\x122\x92\x2\x958\x959\a\x93\x2\x2\x959\x9A3");
		sb.Append("\x3\x2\x2\x2\x95A\x95B\aG\x2\x2\x95B\x95C\a\x92\x2\x2\x95C\x95D");
		sb.Append("\x5\x122\x92\x2\x95D\x95F\a\x93\x2\x2\x95E\x960\x5\x13E\xA0");
		sb.Append("\x2\x95F\x95E\x3\x2\x2\x2\x95F\x960\x3\x2\x2\x2\x960\x9A3\x3");
		sb.Append("\x2\x2\x2\x961\x962\aH\x2\x2\x962\x963\a\x92\x2\x2\x963\x964");
		sb.Append("\x5\x122\x92\x2\x964\x965\a\x99\x2\x2\x965\x966\x5\x1C2\xE2");
		sb.Append("\x2\x966\x967\a\x93\x2\x2\x967\x9A3\x3\x2\x2\x2\x968\x969\a");
		sb.Append("\x88\x2\x2\x969\x96A\a\x92\x2\x2\x96A\x96B\x5\x122\x92\x2\x96B");
		sb.Append("\x96C\a\x93\x2\x2\x96C\x9A3\x3\x2\x2\x2\x96D\x96E\a\x89\x2\x2");
		sb.Append("\x96E\x96F\a\x92\x2\x2\x96F\x970\x5\x1A8\xD5\x2\x970\x971\a");
		sb.Append("\x93\x2\x2\x971\x9A3\x3\x2\x2\x2\x972\x973\aL\x2\x2\x973\x974");
		sb.Append("\a\x92\x2\x2\x974\x975\x5\x122\x92\x2\x975\x976\a\x99\x2\x2");
		sb.Append("\x976\x97B\x5\x198\xCD\x2\x977\x978\a\x99\x2\x2\x978\x97A\x5");
		sb.Append("\x198\xCD\x2\x979\x977\x3\x2\x2\x2\x97A\x97D\x3\x2\x2\x2\x97B");
		sb.Append("\x979\x3\x2\x2\x2\x97B\x97C\x3\x2\x2\x2\x97C\x97E\x3\x2\x2\x2");
		sb.Append("\x97D\x97B\x3\x2\x2\x2\x97E\x97F\a\x93\x2\x2\x97F\x9A3\x3\x2");
		sb.Append("\x2\x2\x980\x981\aM\x2\x2\x981\x982\a\x92\x2\x2\x982\x983\x5");
		sb.Append("\x122\x92\x2\x983\x984\a\x93\x2\x2\x984\x9A3\x3\x2\x2\x2\x985");
		sb.Append("\x986\aN\x2\x2\x986\x987\a\x92\x2\x2\x987\x988\x5\x122\x92\x2");
		sb.Append("\x988\x989\t\n\x2\x2\x989\x98C\x5\x198\xCD\x2\x98A\x98B\a\x99");
		sb.Append("\x2\x2\x98B\x98D\x5\x1A4\xD3\x2\x98C\x98A\x3\x2\x2\x2\x98C\x98D");
		sb.Append("\x3\x2\x2\x2\x98D\x98E\x3\x2\x2\x2\x98E\x990\a\x93\x2\x2\x98F");
		sb.Append("\x991\x5\x13E\xA0\x2\x990\x98F\x3\x2\x2\x2\x990\x991\x3\x2\x2");
		sb.Append("\x2\x991\x9A3\x3\x2\x2\x2\x992\x993\aI\x2\x2\x993\x994\a\x92");
		sb.Append("\x2\x2\x994\x995\x5\x1C2\xE2\x2\x995\x996\a\x93\x2\x2\x996\x9A3");
		sb.Append("\x3\x2\x2\x2\x997\x99A\aO\x2\x2\x998\x999\a\x92\x2\x2\x999\x99B");
		sb.Append("\a\x93\x2\x2\x99A\x998\x3\x2\x2\x2\x99A\x99B\x3\x2\x2\x2\x99B");
		sb.Append("\x99D\x3\x2\x2\x2\x99C\x99E\x5\x13E\xA0\x2\x99D\x99C\x3\x2\x2");
		sb.Append("\x2\x99D\x99E\x3\x2\x2\x2\x99E\x9A3\x3\x2\x2\x2\x99F\x9A0\a");
		sb.Append(";\x2\x2\x9A0\x9A1\a\x92\x2\x2\x9A1\x9A3\a\x93\x2\x2\x9A2\x8FF");
		sb.Append("\x3\x2\x2\x2\x9A2\x907\x3\x2\x2\x2\x9A2\x90F\x3\x2\x2\x2\x9A2");
		sb.Append("\x918\x3\x2\x2\x2\x9A2\x920\x3\x2\x2\x2\x9A2\x928\x3\x2\x2\x2");
		sb.Append("\x9A2\x930\x3\x2\x2\x2\x9A2\x931\x3\x2\x2\x2\x9A2\x93F\x3\x2");
		sb.Append("\x2\x2\x9A2\x94A\x3\x2\x2\x2\x9A2\x955\x3\x2\x2\x2\x9A2\x95A");
		sb.Append("\x3\x2\x2\x2\x9A2\x961\x3\x2\x2\x2\x9A2\x968\x3\x2\x2\x2\x9A2");
		sb.Append("\x96D\x3\x2\x2\x2\x9A2\x972\x3\x2\x2\x2\x9A2\x980\x3\x2\x2\x2");
		sb.Append("\x9A2\x985\x3\x2\x2\x2\x9A2\x992\x3\x2\x2\x2\x9A2\x997\x3\x2");
		sb.Append("\x2\x2\x9A2\x99F\x3\x2\x2\x2\x9A3\x14F\x3\x2\x2\x2\x9A4\x9A8");
		sb.Append("\a\x32\x2\x2\x9A5\x9A8\a\x33\x2\x2\x9A6\x9A8\a\x4\x2\x2\x9A7");
		sb.Append("\x9A4\x3\x2\x2\x2\x9A7\x9A5\x3\x2\x2\x2\x9A7\x9A6\x3\x2\x2\x2");
		sb.Append("\x9A8\x9A9\x3\x2\x2\x2\x9A9\x9AB\a\x92\x2\x2\x9AA\x9AC\x5\x19C");
		sb.Append("\xCF\x2\x9AB\x9AA\x3\x2\x2\x2\x9AB\x9AC\x3\x2\x2\x2\x9AC\x9AD");
		sb.Append("\x3\x2\x2\x2\x9AD\x9AF\a\x93\x2\x2\x9AE\x9B0\x5\x13E\xA0\x2");
		sb.Append("\x9AF\x9AE\x3\x2\x2\x2\x9AF\x9B0\x3\x2\x2\x2\x9B0\x151\x3\x2");
		sb.Append("\x2\x2\x9B1\x9B4\x5\x1C2\xE2\x2\x9B2\x9B4\x5\x154\xAB\x2\x9B3");
		sb.Append("\x9B1\x3\x2\x2\x2\x9B3\x9B2\x3\x2\x2\x2\x9B4\x153\x3\x2\x2\x2");
		sb.Append("\x9B5\x9BA\x5\x156\xAC\x2\x9B6\x9B7\a\xB7\x2\x2\x9B7\x9B9\x5");
		sb.Append("\x158\xAD\x2\x9B8\x9B6\x3\x2\x2\x2\x9B9\x9BC\x3\x2\x2\x2\x9BA");
		sb.Append("\x9B8\x3\x2\x2\x2\x9BA\x9BB\x3\x2\x2\x2\x9BB\x155\x3\x2\x2\x2");
		sb.Append("\x9BC\x9BA\x3\x2\x2\x2\x9BD\x9BE\x5\x198\xCD\x2\x9BE\x9BF\a");
		sb.Append("\xB7\x2\x2\x9BF\x9C0\x5\x15C\xAF\x2\x9C0\x9C3\x3\x2\x2\x2\x9C1");
		sb.Append("\x9C3\x5\x15A\xAE\x2\x9C2\x9BD\x3\x2\x2\x2\x9C2\x9C1\x3\x2\x2");
		sb.Append("\x2\x9C3\x9C9\x3\x2\x2\x2\x9C4\x9C6\a\x92\x2\x2\x9C5\x9C7\x5");
		sb.Append("\x160\xB1\x2\x9C6\x9C5\x3\x2\x2\x2\x9C6\x9C7\x3\x2\x2\x2\x9C7");
		sb.Append("\x9C8\x3\x2\x2\x2\x9C8\x9CA\a\x93\x2\x2\x9C9\x9C4\x3\x2\x2\x2");
		sb.Append("\x9C9\x9CA\x3\x2\x2\x2\x9CA\x157\x3\x2\x2\x2\x9CB\x9D1\x5\x15E");
		sb.Append("\xB0\x2\x9CC\x9CE\a\x92\x2\x2\x9CD\x9CF\x5\x160\xB1\x2\x9CE");
		sb.Append("\x9CD\x3\x2\x2\x2\x9CE\x9CF\x3\x2\x2\x2\x9CF\x9D0\x3\x2\x2\x2");
		sb.Append("\x9D0\x9D2\a\x93\x2\x2\x9D1\x9CC\x3\x2\x2\x2\x9D1\x9D2\x3\x2");
		sb.Append("\x2\x2\x9D2\x159\x3\x2\x2\x2\x9D3\x9D7\x5\x1CC\xE7\x2\x9D4\x9D7");
		sb.Append("\a\x13\x2\x2\x9D5\x9D7\a\x14\x2\x2\x9D6\x9D3\x3\x2\x2\x2\x9D6");
		sb.Append("\x9D4\x3\x2\x2\x2\x9D6\x9D5\x3\x2\x2\x2\x9D7\x15B\x3\x2\x2\x2");
		sb.Append("\x9D8\x9DD\x5\x1CC\xE7\x2\x9D9\x9DD\a\x33\x2\x2\x9DA\x9DD\a");
		sb.Append("\x32\x2\x2\x9DB\x9DD\a\x4\x2\x2\x9DC\x9D8\x3\x2\x2\x2\x9DC\x9D9");
		sb.Append("\x3\x2\x2\x2\x9DC\x9DA\x3\x2\x2\x2\x9DC\x9DB\x3\x2\x2\x2\x9DD");
		sb.Append("\x15D\x3\x2\x2\x2\x9DE\x9E9\x5\x1CC\xE7\x2\x9DF\x9E9\a\x33\x2");
		sb.Append("\x2\x9E0\x9E9\a\x32\x2\x2\x9E1\x9E9\a\x4\x2\x2\x9E2\x9E9\a\x13");
		sb.Append("\x2\x2\x9E3\x9E9\a\x14\x2\x2\x9E4\x9E9\a\xF\x2\x2\x9E5\x9E9");
		sb.Append("\aR\x2\x2\x9E6\x9E9\ay\x2\x2\x9E7\x9E9\a\x6\x2\x2\x9E8\x9DE");
		sb.Append("\x3\x2\x2\x2\x9E8\x9DF\x3\x2\x2\x2\x9E8\x9E0\x3\x2\x2\x2\x9E8");
		sb.Append("\x9E1\x3\x2\x2\x2\x9E8\x9E2\x3\x2\x2\x2\x9E8\x9E3\x3\x2\x2\x2");
		sb.Append("\x9E8\x9E4\x3\x2\x2\x2\x9E8\x9E5\x3\x2\x2\x2\x9E8\x9E6\x3\x2");
		sb.Append("\x2\x2\x9E8\x9E7\x3\x2\x2\x2\x9E9\x15F\x3\x2\x2\x2\x9EA\x9EC");
		sb.Append("\t\t\x2\x2\x9EB\x9EA\x3\x2\x2\x2\x9EB\x9EC\x3\x2\x2\x2\x9EC");
		sb.Append("\x9ED\x3\x2\x2\x2\x9ED\x9F2\x5\x162\xB2\x2\x9EE\x9EF\a\x99\x2");
		sb.Append("\x2\x9EF\x9F1\x5\x162\xB2\x2\x9F0\x9EE\x3\x2\x2\x2\x9F1\x9F4");
		sb.Append("\x3\x2\x2\x2\x9F2\x9F0\x3\x2\x2\x2\x9F2\x9F3\x3\x2\x2\x2\x9F3");
		sb.Append("\x161\x3\x2\x2\x2\x9F4\x9F2\x3\x2\x2\x2\x9F5\x9F7\x5\x10\t\x2");
		sb.Append("\x9F6\x9F5\x3\x2\x2\x2\x9F6\x9F7\x3\x2\x2\x2\x9F7\x9F8\x3\x2");
		sb.Append("\x2\x2\x9F8\x9F9\x5\x1A0\xD1\x2\x9F9\x163\x3\x2\x2\x2\x9FA\x9FB");
		sb.Append("\x5\x134\x9B\x2\x9FB\x9FC\a\v\x2\x2\x9FC\x9FD\x5\x134\x9B\x2");
		sb.Append("\x9FD\x165\x3\x2\x2\x2\x9FE\x9FF\x5\x168\xB5\x2\x9FF\x167\x3");
		sb.Append("\x2\x2\x2\xA00\xA04\x5\x16C\xB7\x2\xA01\xA03\x5\x16A\xB6\x2");
		sb.Append("\xA02\xA01\x3\x2\x2\x2\xA03\xA06\x3\x2\x2\x2\xA04\xA02\x3\x2");
		sb.Append("\x2\x2\xA04\xA05\x3\x2\x2\x2\xA05\x169\x3\x2\x2\x2\xA06\xA04");
		sb.Append("\x3\x2\x2\x2\xA07\xA0D\a\x8D\x2\x2\xA08\xA09\a\x8B\x2\x2\xA09");
		sb.Append("\xA0A\x5\x122\x92\x2\xA0A\xA0B\a\x8C\x2\x2\xA0B\xA0D\x3\x2\x2");
		sb.Append("\x2\xA0C\xA07\x3\x2\x2\x2\xA0C\xA08\x3\x2\x2\x2\xA0D\xA0E\x3");
		sb.Append("\x2\x2\x2\xA0E\xA0F\x5\x16C\xB7\x2\xA0F\x16B\x3\x2\x2\x2\xA10");
		sb.Append("\xA15\x5\x16E\xB8\x2\xA11\xA12\a\n\x2\x2\xA12\xA14\x5\x16E\xB8");
		sb.Append("\x2\xA13\xA11\x3\x2\x2\x2\xA14\xA17\x3\x2\x2\x2\xA15\xA13\x3");
		sb.Append("\x2\x2\x2\xA15\xA16\x3\x2\x2\x2\xA16\x16D\x3\x2\x2\x2\xA17\xA15");
		sb.Append("\x3\x2\x2\x2\xA18\xA1D\x5\x170\xB9\x2\xA19\xA1A\a\v\x2\x2\xA1A");
		sb.Append("\xA1C\x5\x170\xB9\x2\xA1B\xA19\x3\x2\x2\x2\xA1C\xA1F\x3\x2\x2");
		sb.Append("\x2\xA1D\xA1B\x3\x2\x2\x2\xA1D\xA1E\x3\x2\x2\x2\xA1E\x16F\x3");
		sb.Append("\x2\x2\x2\xA1F\xA1D\x3\x2\x2\x2\xA20\xA22\x5\x182\xC2\x2\xA21");
		sb.Append("\xA20\x3\x2\x2\x2\xA21\xA22\x3\x2\x2\x2\xA22\xA23\x3\x2\x2\x2");
		sb.Append("\xA23\xA26\x5\x172\xBA\x2\xA24\xA25\aU\x2\x2\xA25\xA27\x5\x172");
		sb.Append("\xBA\x2\xA26\xA24\x3\x2\x2\x2\xA26\xA27\x3\x2\x2\x2\xA27\x171");
		sb.Append("\x3\x2\x2\x2\xA28\xA2D\a\r\x2\x2\xA29\xA2D\a\f\x2\x2\xA2A\xA2B");
		sb.Append("\a\xE\x2\x2\xA2B\xA2D\x5\x176\xBC\x2\xA2C\xA28\x3\x2\x2\x2\xA2C");
		sb.Append("\xA29\x3\x2\x2\x2\xA2C\xA2A\x3\x2\x2\x2\xA2D\xA2F\x3\x2\x2\x2");
		sb.Append("\xA2E\xA30\x5\x182\xC2\x2\xA2F\xA2E\x3\x2\x2\x2\xA2F\xA30\x3");
		sb.Append("\x2\x2\x2\xA30\xA32\x3\x2\x2\x2\xA31\xA2C\x3\x2\x2\x2\xA31\xA32");
		sb.Append("\x3\x2\x2\x2\xA32\xA33\x3\x2\x2\x2\xA33\xA34\x5\x174\xBB\x2");
		sb.Append("\xA34\x173\x3\x2\x2\x2\xA35\xA3B\x5\x17A\xBE\x2\xA36\xA37\a");
		sb.Append("\x92\x2\x2\xA37\xA38\x5\x166\xB4\x2\xA38\xA39\a\x93\x2\x2\xA39");
		sb.Append("\xA3B\x3\x2\x2\x2\xA3A\xA35\x3\x2\x2\x2\xA3A\xA36\x3\x2\x2\x2");
		sb.Append("\xA3B\xA40\x3\x2\x2\x2\xA3C\xA3D\a\xF\x2\x2\xA3D\xA41\x5\x17E");
		sb.Append("\xC0\x2\xA3E\xA3F\a{\x2\x2\xA3F\xA41\x5\x180\xC1\x2\xA40\xA3C");
		sb.Append("\x3\x2\x2\x2\xA40\xA3E\x3\x2\x2\x2\xA40\xA41\x3\x2\x2\x2\xA41");
		sb.Append("\x175\x3\x2\x2\x2\xA42\xA43\a\x92\x2\x2\xA43\xA48\x5\x178\xBD");
		sb.Append("\x2\xA44\xA45\a\x99\x2\x2\xA45\xA47\x5\x178\xBD\x2\xA46\xA44");
		sb.Append("\x3\x2\x2\x2\xA47\xA4A\x3\x2\x2\x2\xA48\xA46\x3\x2\x2\x2\xA48");
		sb.Append("\xA49\x3\x2\x2\x2\xA49\xA4B\x3\x2\x2\x2\xA4A\xA48\x3\x2\x2\x2");
		sb.Append("\xA4B\xA4C\a\x93\x2\x2\xA4C\x177\x3\x2\x2\x2\xA4D\xA4E\x5\x1AC");
		sb.Append("\xD7\x2\xA4E\x179\x3\x2\x2\x2\xA4F\xA52\x5\x17C\xBF\x2\xA50");
		sb.Append("\xA52\x5\x194\xCB\x2\xA51\xA4F\x3\x2\x2\x2\xA51\xA50\x3\x2\x2");
		sb.Append("\x2\xA52\x17B\x3\x2\x2\x2\xA53\xA54\a\xC5\x2\x2\xA54\xA57\a");
		sb.Append("\x98\x2\x2\xA55\xA58\a\xC5\x2\x2\xA56\xA58\aV\x2\x2\xA57\xA55");
		sb.Append("\x3\x2\x2\x2\xA57\xA56\x3\x2\x2\x2\xA58\xA59\x3\x2\x2\x2\xA59");
		sb.Append("\xA5B\a\x92\x2\x2\xA5A\xA5C\x5\x19E\xD0\x2\xA5B\xA5A\x3\x2\x2");
		sb.Append("\x2\xA5B\xA5C\x3\x2\x2\x2\xA5C\xA5D\x3\x2\x2\x2\xA5D\xA5E\a");
		sb.Append("\x93\x2\x2\xA5E\x17D\x3\x2\x2\x2\xA5F\xA60\a\xC5\x2\x2\xA60");
		sb.Append("\xA61\a\x98\x2\x2\xA61\xA62\a\xC5\x2\x2\xA62\xA64\a\x92\x2\x2");
		sb.Append("\xA63\xA65\x5\x1AA\xD6\x2\xA64\xA63\x3\x2\x2\x2\xA64\xA65\x3");
		sb.Append("\x2\x2\x2\xA65\xA66\x3\x2\x2\x2\xA66\xA67\a\x93\x2\x2\xA67\x17F");
		sb.Append("\x3\x2\x2\x2\xA68\xA69\a\x92\x2\x2\xA69\xA6A\x5\x122\x92\x2");
		sb.Append("\xA6A\xA6B\a\x93\x2\x2\xA6B\x181\x3\x2\x2\x2\xA6C\xA76\a\x94");
		sb.Append("\x2\x2\xA6D\xA72\x5\x122\x92\x2\xA6E\xA70\a\x98\x2\x2\xA6F\xA71");
		sb.Append("\x5\x122\x92\x2\xA70\xA6F\x3\x2\x2\x2\xA70\xA71\x3\x2\x2\x2");
		sb.Append("\xA71\xA73\x3\x2\x2\x2\xA72\xA6E\x3\x2\x2\x2\xA72\xA73\x3\x2");
		sb.Append("\x2\x2\xA73\xA77\x3\x2\x2\x2\xA74\xA75\a\x98\x2\x2\xA75\xA77");
		sb.Append("\x5\x122\x92\x2\xA76\xA6D\x3\x2\x2\x2\xA76\xA74\x3\x2\x2\x2");
		sb.Append("\xA77\xA78\x3\x2\x2\x2\xA78\xA79\a\x95\x2\x2\xA79\x183\x3\x2");
		sb.Append("\x2\x2\xA7A\xA7B\a\xC5\x2\x2\xA7B\xA7D\a\x8F\x2\x2\xA7C\xA7A");
		sb.Append("\x3\x2\x2\x2\xA7C\xA7D\x3\x2\x2\x2\xA7D\xA7E\x3\x2\x2\x2\xA7E");
		sb.Append("\xA84\x5\x198\xCD\x2\xA7F\xA81\a\x92\x2\x2\xA80\xA82\x5\x1A8");
		sb.Append("\xD5\x2\xA81\xA80\x3\x2\x2\x2\xA81\xA82\x3\x2\x2\x2\xA82\xA83");
		sb.Append("\x3\x2\x2\x2\xA83\xA85\a\x93\x2\x2\xA84\xA7F\x3\x2\x2\x2\xA84");
		sb.Append("\xA85\x3\x2\x2\x2\xA85\xA87\x3\x2\x2\x2\xA86\xA88\x5\x186\xC4");
		sb.Append("\x2\xA87\xA86\x3\x2\x2\x2\xA87\xA88\x3\x2\x2\x2\xA88\x185\x3");
		sb.Append("\x2\x2\x2\xA89\xA8D\x5\x188\xC5\x2\xA8A\xA8C\x5\x188\xC5\x2");
		sb.Append("\xA8B\xA8A\x3\x2\x2\x2\xA8C\xA8F\x3\x2\x2\x2\xA8D\xA8B\x3\x2");
		sb.Append("\x2\x2\xA8D\xA8E\x3\x2\x2\x2\xA8E\x187\x3\x2\x2\x2\xA8F\xA8D");
		sb.Append("\x3\x2\x2\x2\xA90\xA92\a\x94\x2\x2\xA91\xA93\x5\x18A\xC6\x2");
		sb.Append("\xA92\xA91\x3\x2\x2\x2\xA92\xA93\x3\x2\x2\x2\xA93\xA94\x3\x2");
		sb.Append("\x2\x2\xA94\xA96\x5\x122\x92\x2\xA95\xA97\x5\x192\xCA\x2\xA96");
		sb.Append("\xA95\x3\x2\x2\x2\xA96\xA97\x3\x2\x2\x2\xA97\xA9A\x3\x2\x2\x2");
		sb.Append("\xA98\xA99\a\x10\x2\x2\xA99\xA9B\a\xC5\x2\x2\xA9A\xA98\x3\x2");
		sb.Append("\x2\x2\xA9A\xA9B\x3\x2\x2\x2\xA9B\xA9E\x3\x2\x2\x2\xA9C\xA9D");
		sb.Append("\a\xF\x2\x2\xA9D\xA9F\x5\x122\x92\x2\xA9E\xA9C\x3\x2\x2\x2\xA9E");
		sb.Append("\xA9F\x3\x2\x2\x2\xA9F\xAA0\x3\x2\x2\x2\xAA0\xAA1\a\x95\x2\x2");
		sb.Append("\xAA1\x189\x3\x2\x2\x2\xAA2\xAA3\a\x1A\x2\x2\xAA3\xAA4\x5\x18C");
		sb.Append("\xC7\x2\xAA4\xAA5\a \x2\x2\xAA5\x18B\x3\x2\x2\x2\xAA6\xAAB\x5");
		sb.Append("\x18E\xC8\x2\xAA7\xAA8\a\x99\x2\x2\xAA8\xAAA\x5\x18E\xC8\x2");
		sb.Append("\xAA9\xAA7\x3\x2\x2\x2\xAAA\xAAD\x3\x2\x2\x2\xAAB\xAA9\x3\x2");
		sb.Append("\x2\x2\xAAB\xAAC\x3\x2\x2\x2\xAAC\x18D\x3\x2\x2\x2\xAAD\xAAB");
		sb.Append("\x3\x2\x2\x2\xAAE\xAB6\a\xA6\x2\x2\xAAF\xAB6\x5\x190\xC9\x2");
		sb.Append("\xAB0\xAB3\x5\x122\x92\x2\xAB1\xAB2\a\x10\x2\x2\xAB2\xAB4\x5");
		sb.Append("\x1C8\xE5\x2\xAB3\xAB1\x3\x2\x2\x2\xAB3\xAB4\x3\x2\x2\x2\xAB4");
		sb.Append("\xAB6\x3\x2\x2\x2\xAB5\xAAE\x3\x2\x2\x2\xAB5\xAAF\x3\x2\x2\x2");
		sb.Append("\xAB5\xAB0\x3\x2\x2\x2\xAB6\x18F\x3\x2\x2\x2\xAB7\xAB8\a\xC5");
		sb.Append("\x2\x2\xAB8\xAB9\a\xB7\x2\x2\xAB9\xABC\a\xA6\x2\x2\xABA\xABB");
		sb.Append("\a\x10\x2\x2\xABB\xABD\a\xC5\x2\x2\xABC\xABA\x3\x2\x2\x2\xABC");
		sb.Append("\xABD\x3\x2\x2\x2\xABD\x191\x3\x2\x2\x2\xABE\xABF\a\xBD\x2\x2");
		sb.Append("\xABF\xAC0\a\xC5\x2\x2\xAC0\xAC1\a\x92\x2\x2\xAC1\xAC2\a\xC5");
		sb.Append("\x2\x2\xAC2\xAC3\a\x93\x2\x2\xAC3\x193\x3\x2\x2\x2\xAC4\xAC5");
		sb.Append("\a\xC5\x2\x2\xAC5\xAC7\a\x8F\x2\x2\xAC6\xAC4\x3\x2\x2\x2\xAC6");
		sb.Append("\xAC7\x3\x2\x2\x2\xAC7\xAC8\x3\x2\x2\x2\xAC8\xACE\x5\x198\xCD");
		sb.Append("\x2\xAC9\xACB\a\x92\x2\x2\xACA\xACC\x5\x1A8\xD5\x2\xACB\xACA");
		sb.Append("\x3\x2\x2\x2\xACB\xACC\x3\x2\x2\x2\xACC\xACD\x3\x2\x2\x2\xACD");
		sb.Append("\xACF\a\x93\x2\x2\xACE\xAC9\x3\x2\x2\x2\xACE\xACF\x3\x2\x2\x2");
		sb.Append("\xACF\xAD1\x3\x2\x2\x2\xAD0\xAD2\x5\x186\xC4\x2\xAD1\xAD0\x3");
		sb.Append("\x2\x2\x2\xAD1\xAD2\x3\x2\x2\x2\xAD2\xAD4\x3\x2\x2\x2\xAD3\xAD5");
		sb.Append("\x5\x196\xCC\x2\xAD4\xAD3\x3\x2\x2\x2\xAD4\xAD5\x3\x2\x2\x2");
		sb.Append("\xAD5\x195\x3\x2\x2\x2\xAD6\xAD7\a\xBD\x2\x2\xAD7\xADC\a\xC5");
		sb.Append("\x2\x2\xAD8\xAD9\a\x92\x2\x2\xAD9\xADA\x5\x1E2\xF2\x2\xADA\xADB");
		sb.Append("\a\x93\x2\x2\xADB\xADD\x3\x2\x2\x2\xADC\xAD8\x3\x2\x2\x2\xADC");
		sb.Append("\xADD\x3\x2\x2\x2\xADD\x197\x3\x2\x2\x2\xADE\xAE3\x5\x1CA\xE6");
		sb.Append("\x2\xADF\xAE0\a\xB7\x2\x2\xAE0\xAE2\x5\x1CA\xE6\x2\xAE1\xADF");
		sb.Append("\x3\x2\x2\x2\xAE2\xAE5\x3\x2\x2\x2\xAE3\xAE1\x3\x2\x2\x2\xAE3");
		sb.Append("\xAE4\x3\x2\x2\x2\xAE4\x199\x3\x2\x2\x2\xAE5\xAE3\x3\x2\x2\x2");
		sb.Append("\xAE6\xAE8\a\x9E\x2\x2\xAE7\xAE6\x3\x2\x2\x2\xAE7\xAE8\x3\x2");
		sb.Append("\x2\x2\xAE8\xAE9\x3\x2\x2\x2\xAE9\xAEE\x5\x1CA\xE6\x2\xAEA\xAEB");
		sb.Append("\a\x9E\x2\x2\xAEB\xAED\x5\x1CA\xE6\x2\xAEC\xAEA\x3\x2\x2\x2");
		sb.Append("\xAED\xAF0\x3\x2\x2\x2\xAEE\xAEC\x3\x2\x2\x2\xAEE\xAEF\x3\x2");
		sb.Append("\x2\x2\xAEF\x19B\x3\x2\x2\x2\xAF0\xAEE\x3\x2\x2\x2\xAF1\xAF6");
		sb.Append("\x5\x1A0\xD1\x2\xAF2\xAF3\a\x99\x2\x2\xAF3\xAF5\x5\x1A0\xD1");
		sb.Append("\x2\xAF4\xAF2\x3\x2\x2\x2\xAF5\xAF8\x3\x2\x2\x2\xAF6\xAF4\x3");
		sb.Append("\x2\x2\x2\xAF6\xAF7\x3\x2\x2\x2\xAF7\x19D\x3\x2\x2\x2\xAF8\xAF6");
		sb.Append("\x3\x2\x2\x2\xAF9\xAFE\x5\x1A2\xD2\x2\xAFA\xAFB\a\x99\x2\x2");
		sb.Append("\xAFB\xAFD\x5\x1A2\xD2\x2\xAFC\xAFA\x3\x2\x2\x2\xAFD\xB00\x3");
		sb.Append("\x2\x2\x2\xAFE\xAFC\x3\x2\x2\x2\xAFE\xAFF\x3\x2\x2\x2\xAFF\x19F");
		sb.Append("\x3\x2\x2\x2\xB00\xAFE\x3\x2\x2\x2\xB01\xB04\x5\x1A4\xD3\x2");
		sb.Append("\xB02\xB04\x5\x1AC\xD7\x2\xB03\xB01\x3\x2\x2\x2\xB03\xB02\x3");
		sb.Append("\x2\x2\x2\xB04\x1A1\x3\x2\x2\x2\xB05\xB08\x5\x1A6\xD4\x2\xB06");
		sb.Append("\xB08\x5\x1AE\xD8\x2\xB07\xB05\x3\x2\x2\x2\xB07\xB06\x3\x2\x2");
		sb.Append("\x2\xB08\x1A3\x3\x2\x2\x2\xB09\xB0A\a\xC5\x2\x2\xB0A\xB11\a");
		sb.Append("\x98\x2\x2\xB0B\xB12\x5\x122\x92\x2\xB0C\xB0E\a\x92\x2\x2\xB0D");
		sb.Append("\xB0F\x5\x1A8\xD5\x2\xB0E\xB0D\x3\x2\x2\x2\xB0E\xB0F\x3\x2\x2");
		sb.Append("\x2\xB0F\xB10\x3\x2\x2\x2\xB10\xB12\a\x93\x2\x2\xB11\xB0B\x3");
		sb.Append("\x2\x2\x2\xB11\xB0C\x3\x2\x2\x2\xB12\x1A5\x3\x2\x2\x2\xB13\xB14");
		sb.Append("\a\xC5\x2\x2\xB14\xB1B\a\x98\x2\x2\xB15\xB1C\x5\x1AC\xD7\x2");
		sb.Append("\xB16\xB18\a\x92\x2\x2\xB17\xB19\x5\x1AA\xD6\x2\xB18\xB17\x3");
		sb.Append("\x2\x2\x2\xB18\xB19\x3\x2\x2\x2\xB19\xB1A\x3\x2\x2\x2\xB1A\xB1C");
		sb.Append("\a\x93\x2\x2\xB1B\xB15\x3\x2\x2\x2\xB1B\xB16\x3\x2\x2\x2\xB1C");
		sb.Append("\x1A7\x3\x2\x2\x2\xB1D\xB22\x5\x122\x92\x2\xB1E\xB1F\a\x99\x2");
		sb.Append("\x2\xB1F\xB21\x5\x122\x92\x2\xB20\xB1E\x3\x2\x2\x2\xB21\xB24");
		sb.Append("\x3\x2\x2\x2\xB22\xB20\x3\x2\x2\x2\xB22\xB23\x3\x2\x2\x2\xB23");
		sb.Append("\x1A9\x3\x2\x2\x2\xB24\xB22\x3\x2\x2\x2\xB25\xB2A\x5\x1AE\xD8");
		sb.Append("\x2\xB26\xB27\a\x99\x2\x2\xB27\xB29\x5\x1AE\xD8\x2\xB28\xB26");
		sb.Append("\x3\x2\x2\x2\xB29\xB2C\x3\x2\x2\x2\xB2A\xB28\x3\x2\x2\x2\xB2A");
		sb.Append("\xB2B\x3\x2\x2\x2\xB2B\x1AB\x3\x2\x2\x2\xB2C\xB2A\x3\x2\x2\x2");
		sb.Append("\xB2D\xB38\x5\x1B2\xDA\x2\xB2E\xB38\x5\x1CE\xE8\x2\xB2F\xB38");
		sb.Append("\x5\x1B0\xD9\x2\xB30\xB38\x5\x1B8\xDD\x2\xB31\xB38\x5\x1B6\xDC");
		sb.Append("\x2\xB32\xB38\x5\x1BA\xDE\x2\xB33\xB38\x5\x1BC\xDF\x2\xB34\xB38");
		sb.Append("\x5\x1BE\xE0\x2\xB35\xB38\a\xA6\x2\x2\xB36\xB38\x5\x190\xC9");
		sb.Append("\x2\xB37\xB2D\x3\x2\x2\x2\xB37\xB2E\x3\x2\x2\x2\xB37\xB2F\x3");
		sb.Append("\x2\x2\x2\xB37\xB30\x3\x2\x2\x2\xB37\xB31\x3\x2\x2\x2\xB37\xB32");
		sb.Append("\x3\x2\x2\x2\xB37\xB33\x3\x2\x2\x2\xB37\xB34\x3\x2\x2\x2\xB37");
		sb.Append("\xB35\x3\x2\x2\x2\xB37\xB36\x3\x2\x2\x2\xB38\x1AD\x3\x2\x2\x2");
		sb.Append("\xB39\xB3C\x5\x1B4\xDB\x2\xB3A\xB3C\x5\x1AC\xD7\x2\xB3B\xB39");
		sb.Append("\x3\x2\x2\x2\xB3B\xB3A\x3\x2\x2\x2\xB3C\x1AF\x3\x2\x2\x2\xB3D");
		sb.Append("\xB43\x5\x122\x92\x2\xB3E\xB44\a\x38\x2\x2\xB3F\xB44\a\x39\x2");
		sb.Append("\x2\xB40\xB44\a\x66\x2\x2\xB41\xB44\a\x65\x2\x2\xB42\xB44\a");
		sb.Append("\x64\x2\x2\xB43\xB3E\x3\x2\x2\x2\xB43\xB3F\x3\x2\x2\x2\xB43");
		sb.Append("\xB40\x3\x2\x2\x2\xB43\xB41\x3\x2\x2\x2\xB43\xB42\x3\x2\x2\x2");
		sb.Append("\xB43\xB44\x3\x2\x2\x2\xB44\x1B1\x3\x2\x2\x2\xB45\xB46\aK\x2");
		sb.Append("\x2\xB46\x1B3\x3\x2\x2\x2\xB47\xB48\a\x33\x2\x2\xB48\x1B5\x3");
		sb.Append("\x2\x2\x2\xB49\xB4A\a\xA6\x2\x2\xB4A\xB4E\a\x9E\x2\x2\xB4B\xB4F");
		sb.Append("\x5\x1E2\xF2\x2\xB4C\xB4F\a\xC5\x2\x2\xB4D\xB4F\x5\x1E4\xF3");
		sb.Append("\x2\xB4E\xB4B\x3\x2\x2\x2\xB4E\xB4C\x3\x2\x2\x2\xB4E\xB4D\x3");
		sb.Append("\x2\x2\x2\xB4F\x1B7\x3\x2\x2\x2\xB50\xB54\x5\x1E2\xF2\x2\xB51");
		sb.Append("\xB54\a\xC5\x2\x2\xB52\xB54\x5\x1E4\xF3\x2\xB53\xB50\x3\x2\x2");
		sb.Append("\x2\xB53\xB51\x3\x2\x2\x2\xB53\xB52\x3\x2\x2\x2\xB54\xB55\x3");
		sb.Append("\x2\x2\x2\xB55\xB59\a\x98\x2\x2\xB56\xB5A\x5\x1E2\xF2\x2\xB57");
		sb.Append("\xB5A\a\xC5\x2\x2\xB58\xB5A\x5\x1E4\xF3\x2\xB59\xB56\x3\x2\x2");
		sb.Append("\x2\xB59\xB57\x3\x2\x2\x2\xB59\xB58\x3\x2\x2\x2\xB5A\x1B9\x3");
		sb.Append("\x2\x2\x2\xB5B\xB5F\x5\x1E2\xF2\x2\xB5C\xB5F\a\xC5\x2\x2\xB5D");
		sb.Append("\xB5F\x5\x1E4\xF3\x2\xB5E\xB5B\x3\x2\x2\x2\xB5E\xB5C\x3\x2\x2");
		sb.Append("\x2\xB5E\xB5D\x3\x2\x2\x2\xB5F\xB60\x3\x2\x2\x2\xB60\xB61\a");
		sb.Append("\x33\x2\x2\xB61\x1BB\x3\x2\x2\x2\xB62\xB66\x5\x1E2\xF2\x2\xB63");
		sb.Append("\xB66\a\xC5\x2\x2\xB64\xB66\x5\x1E4\xF3\x2\xB65\xB62\x3\x2\x2");
		sb.Append("\x2\xB65\xB63\x3\x2\x2\x2\xB65\xB64\x3\x2\x2\x2\xB66\xB67\x3");
		sb.Append("\x2\x2\x2\xB67\xB68\aJ\x2\x2\xB68\x1BD\x3\x2\x2\x2\xB69\xB6A");
		sb.Append("\a\x94\x2\x2\xB6A\xB6F\x5\x1C0\xE1\x2\xB6B\xB6C\a\x99\x2\x2");
		sb.Append("\xB6C\xB6E\x5\x1C0\xE1\x2\xB6D\xB6B\x3\x2\x2\x2\xB6E\xB71\x3");
		sb.Append("\x2\x2\x2\xB6F\xB6D\x3\x2\x2\x2\xB6F\xB70\x3\x2\x2\x2\xB70\xB72");
		sb.Append("\x3\x2\x2\x2\xB71\xB6F\x3\x2\x2\x2\xB72\xB73\a\x95\x2\x2\xB73");
		sb.Append("\x1BF\x3\x2\x2\x2\xB74\xB78\x5\x1B8\xDD\x2\xB75\xB78\x5\x1B6");
		sb.Append("\xDC\x2\xB76\xB78\x5\x1E8\xF5\x2\xB77\xB74\x3\x2\x2\x2\xB77");
		sb.Append("\xB75\x3\x2\x2\x2\xB77\xB76\x3\x2\x2\x2\xB78\x1C1\x3\x2\x2\x2");
		sb.Append("\xB79\xB7E\x5\x1C4\xE3\x2\xB7A\xB7B\a\xB7\x2\x2\xB7B\xB7D\x5");
		sb.Append("\x1C4\xE3\x2\xB7C\xB7A\x3\x2\x2\x2\xB7D\xB80\x3\x2\x2\x2\xB7E");
		sb.Append("\xB7C\x3\x2\x2\x2\xB7E\xB7F\x3\x2\x2\x2\xB7F\x1C3\x3\x2\x2\x2");
		sb.Append("\xB80\xB7E\x3\x2\x2\x2\xB81\xB92\x5\x1C6\xE4\x2\xB82\xB83\a");
		sb.Append("\x94\x2\x2\xB83\xB84\x5\x1E2\xF2\x2\xB84\xB86\a\x95\x2\x2\xB85");
		sb.Append("\xB87\a\x91\x2\x2\xB86\xB85\x3\x2\x2\x2\xB86\xB87\x3\x2\x2\x2");
		sb.Append("\xB87\xB93\x3\x2\x2\x2\xB88\xB8B\a\x92\x2\x2\xB89\xB8C\a\xC4");
		sb.Append("\x2\x2\xB8A\xB8C\a\xC3\x2\x2\xB8B\xB89\x3\x2\x2\x2\xB8B\xB8A");
		sb.Append("\x3\x2\x2\x2\xB8C\xB8D\x3\x2\x2\x2\xB8D\xB8F\a\x93\x2\x2\xB8E");
		sb.Append("\xB90\a\x91\x2\x2\xB8F\xB8E\x3\x2\x2\x2\xB8F\xB90\x3\x2\x2\x2");
		sb.Append("\xB90\xB93\x3\x2\x2\x2\xB91\xB93\a\x91\x2\x2\xB92\xB82\x3\x2");
		sb.Append("\x2\x2\xB92\xB88\x3\x2\x2\x2\xB92\xB91\x3\x2\x2\x2\xB92\xB93");
		sb.Append("\x3\x2\x2\x2\xB93\x1C5\x3\x2\x2\x2\xB94\xB9C\x5\x1C8\xE5\x2");
		sb.Append("\xB95\xB96\a\xBB\x2\x2\xB96\xB98\a\xB7\x2\x2\xB97\xB99\x5\x1C8");
		sb.Append("\xE5\x2\xB98\xB97\x3\x2\x2\x2\xB98\xB99\x3\x2\x2\x2\xB99\xB9B");
		sb.Append("\x3\x2\x2\x2\xB9A\xB95\x3\x2\x2\x2\xB9B\xB9E\x3\x2\x2\x2\xB9C");
		sb.Append("\xB9A\x3\x2\x2\x2\xB9C\xB9D\x3\x2\x2\x2\xB9D\x1C7\x3\x2\x2\x2");
		sb.Append("\xB9E\xB9C\x3\x2\x2\x2\xB9F\xBD4\a\xC5\x2\x2\xBA0\xBD4\a\xC2");
		sb.Append("\x2\x2\xBA1\xBD4\aV\x2\x2\xBA2\xBD4\a\x19\x2\x2\xBA3\xBD4\a");
		sb.Append("\t\x2\x2\xBA4\xBD4\a\r\x2\x2\xBA5\xBD4\a=\x2\x2\xBA6\xBD4\a");
		sb.Append("\x11\x2\x2\xBA7\xBD4\a\x12\x2\x2\xBA8\xBD4\a\x13\x2\x2\xBA9");
		sb.Append("\xBD4\a\x14\x2\x2\xBAA\xBD4\a\x15\x2\x2\xBAB\xBD4\a\x16\x2\x2");
		sb.Append("\xBAC\xBD4\a\x17\x2\x2\xBAD\xBD4\a\x18\x2\x2\xBAE\xBD4\a\x31");
		sb.Append("\x2\x2\xBAF\xBD4\a\x32\x2\x2\xBB0\xBD4\a\x33\x2\x2\xBB1\xBD4");
		sb.Append("\a{\x2\x2\xBB2\xBD4\a}\x2\x2\xBB3\xBD4\a~\x2\x2\xBB4\xBD4\a");
		sb.Append(">\x2\x2\xBB5\xBD4\a?\x2\x2\xBB6\xBD4\a@\x2\x2\xBB7\xBD4\aU\x2");
		sb.Append("\x2\xBB8\xBD4\a\x41\x2\x2\xBB9\xBD4\a\x42\x2\x2\xBBA\xBD4\a");
		sb.Append("\x43\x2\x2\xBBB\xBD4\a\x44\x2\x2\xBBC\xBD4\a\x45\x2\x2\xBBD");
		sb.Append("\xBD4\aH\x2\x2\xBBE\xBD4\aJ\x2\x2\xBBF\xBD4\aK\x2\x2\xBC0\xBD4");
		sb.Append("\aL\x2\x2\xBC1\xBD4\aM\x2\x2\xBC2\xBD4\aN\x2\x2\xBC3\xBD4\a");
		sb.Append("Q\x2\x2\xBC4\xBD4\aS\x2\x2\xBC5\xBD4\aT\x2\x2\xBC6\xBD4\aW\x2");
		sb.Append("\x2\xBC7\xBD4\a\x4\x2\x2\xBC8\xBD4\a$\x2\x2\xBC9\xBD4\a%\x2");
		sb.Append("\x2\xBCA\xBD4\a!\x2\x2\xBCB\xBD4\a&\x2\x2\xBCC\xBD4\a#\x2\x2");
		sb.Append("\xBCD\xBD4\av\x2\x2\xBCE\xBD4\aw\x2\x2\xBCF\xBD4\ax\x2\x2\xBD0");
		sb.Append("\xBD4\a\x82\x2\x2\xBD1\xBD4\az\x2\x2\xBD2\xBD4\a|\x2\x2\xBD3");
		sb.Append("\xB9F\x3\x2\x2\x2\xBD3\xBA0\x3\x2\x2\x2\xBD3\xBA1\x3\x2\x2\x2");
		sb.Append("\xBD3\xBA2\x3\x2\x2\x2\xBD3\xBA3\x3\x2\x2\x2\xBD3\xBA4\x3\x2");
		sb.Append("\x2\x2\xBD3\xBA5\x3\x2\x2\x2\xBD3\xBA6\x3\x2\x2\x2\xBD3\xBA7");
		sb.Append("\x3\x2\x2\x2\xBD3\xBA8\x3\x2\x2\x2\xBD3\xBA9\x3\x2\x2\x2\xBD3");
		sb.Append("\xBAA\x3\x2\x2\x2\xBD3\xBAB\x3\x2\x2\x2\xBD3\xBAC\x3\x2\x2\x2");
		sb.Append("\xBD3\xBAD\x3\x2\x2\x2\xBD3\xBAE\x3\x2\x2\x2\xBD3\xBAF\x3\x2");
		sb.Append("\x2\x2\xBD3\xBB0\x3\x2\x2\x2\xBD3\xBB1\x3\x2\x2\x2\xBD3\xBB2");
		sb.Append("\x3\x2\x2\x2\xBD3\xBB3\x3\x2\x2\x2\xBD3\xBB4\x3\x2\x2\x2\xBD3");
		sb.Append("\xBB5\x3\x2\x2\x2\xBD3\xBB6\x3\x2\x2\x2\xBD3\xBB7\x3\x2\x2\x2");
		sb.Append("\xBD3\xBB8\x3\x2\x2\x2\xBD3\xBB9\x3\x2\x2\x2\xBD3\xBBA\x3\x2");
		sb.Append("\x2\x2\xBD3\xBBB\x3\x2\x2\x2\xBD3\xBBC\x3\x2\x2\x2\xBD3\xBBD");
		sb.Append("\x3\x2\x2\x2\xBD3\xBBE\x3\x2\x2\x2\xBD3\xBBF\x3\x2\x2\x2\xBD3");
		sb.Append("\xBC0\x3\x2\x2\x2\xBD3\xBC1\x3\x2\x2\x2\xBD3\xBC2\x3\x2\x2\x2");
		sb.Append("\xBD3\xBC3\x3\x2\x2\x2\xBD3\xBC4\x3\x2\x2\x2\xBD3\xBC5\x3\x2");
		sb.Append("\x2\x2\xBD3\xBC6\x3\x2\x2\x2\xBD3\xBC7\x3\x2\x2\x2\xBD3\xBC8");
		sb.Append("\x3\x2\x2\x2\xBD3\xBC9\x3\x2\x2\x2\xBD3\xBCA\x3\x2\x2\x2\xBD3");
		sb.Append("\xBCB\x3\x2\x2\x2\xBD3\xBCC\x3\x2\x2\x2\xBD3\xBCD\x3\x2\x2\x2");
		sb.Append("\xBD3\xBCE\x3\x2\x2\x2\xBD3\xBCF\x3\x2\x2\x2\xBD3\xBD0\x3\x2");
		sb.Append("\x2\x2\xBD3\xBD1\x3\x2\x2\x2\xBD3\xBD2\x3\x2\x2\x2\xBD4\x1C9");
		sb.Append("\x3\x2\x2\x2\xBD5\xBD9\a\xC5\x2\x2\xBD6\xBD9\a\x31\x2\x2\xBD7");
		sb.Append("\xBD9\a\xC2\x2\x2\xBD8\xBD5\x3\x2\x2\x2\xBD8\xBD6\x3\x2\x2\x2");
		sb.Append("\xBD8\xBD7\x3\x2\x2\x2\xBD9\x1CB\x3\x2\x2\x2\xBDA\xBDD\a\xC5");
		sb.Append("\x2\x2\xBDB\xBDD\a\xC2\x2\x2\xBDC\xBDA\x3\x2\x2\x2\xBDC\xBDB");
		sb.Append("\x3\x2\x2\x2\xBDD\x1CD\x3\x2\x2\x2\xBDE\xBE0\x5\x1D0\xE9\x2");
		sb.Append("\xBDF\xBE1\x5\x1D2\xEA\x2\xBE0\xBDF\x3\x2\x2\x2\xBE0\xBE1\x3");
		sb.Append("\x2\x2\x2\xBE1\xBE3\x3\x2\x2\x2\xBE2\xBE4\x5\x1D4\xEB\x2\xBE3");
		sb.Append("\xBE2\x3\x2\x2\x2\xBE3\xBE4\x3\x2\x2\x2\xBE4\xBE6\x3\x2\x2\x2");
		sb.Append("\xBE5\xBE7\x5\x1D6\xEC\x2\xBE6\xBE5\x3\x2\x2\x2\xBE6\xBE7\x3");
		sb.Append("\x2\x2\x2\xBE7\xBE9\x3\x2\x2\x2\xBE8\xBEA\x5\x1D8\xED\x2\xBE9");
		sb.Append("\xBE8\x3\x2\x2\x2\xBE9\xBEA\x3\x2\x2\x2\xBEA\xBEC\x3\x2\x2\x2");
		sb.Append("\xBEB\xBED\x5\x1DA\xEE\x2\xBEC\xBEB\x3\x2\x2\x2\xBEC\xBED\x3");
		sb.Append("\x2\x2\x2\xBED\xBEF\x3\x2\x2\x2\xBEE\xBF0\x5\x1DC\xEF\x2\xBEF");
		sb.Append("\xBEE\x3\x2\x2\x2\xBEF\xBF0\x3\x2\x2\x2\xBF0\xBF2\x3\x2\x2\x2");
		sb.Append("\xBF1\xBF3\x5\x1DE\xF0\x2\xBF2\xBF1\x3\x2\x2\x2\xBF2\xBF3\x3");
		sb.Append("\x2\x2\x2\xBF3\xBF5\x3\x2\x2\x2\xBF4\xBF6\x5\x1E0\xF1\x2\xBF5");
		sb.Append("\xBF4\x3\x2\x2\x2\xBF5\xBF6\x3\x2\x2\x2\xBF6\xC54\x3\x2\x2\x2");
		sb.Append("\xBF7\xBF9\x5\x1D2\xEA\x2\xBF8\xBFA\x5\x1D4\xEB\x2\xBF9\xBF8");
		sb.Append("\x3\x2\x2\x2\xBF9\xBFA\x3\x2\x2\x2\xBFA\xBFC\x3\x2\x2\x2\xBFB");
		sb.Append("\xBFD\x5\x1D6\xEC\x2\xBFC\xBFB\x3\x2\x2\x2\xBFC\xBFD\x3\x2\x2");
		sb.Append("\x2\xBFD\xBFF\x3\x2\x2\x2\xBFE\xC00\x5\x1D8\xED\x2\xBFF\xBFE");
		sb.Append("\x3\x2\x2\x2\xBFF\xC00\x3\x2\x2\x2\xC00\xC02\x3\x2\x2\x2\xC01");
		sb.Append("\xC03\x5\x1DA\xEE\x2\xC02\xC01\x3\x2\x2\x2\xC02\xC03\x3\x2\x2");
		sb.Append("\x2\xC03\xC05\x3\x2\x2\x2\xC04\xC06\x5\x1DC\xEF\x2\xC05\xC04");
		sb.Append("\x3\x2\x2\x2\xC05\xC06\x3\x2\x2\x2\xC06\xC08\x3\x2\x2\x2\xC07");
		sb.Append("\xC09\x5\x1DE\xF0\x2\xC08\xC07\x3\x2\x2\x2\xC08\xC09\x3\x2\x2");
		sb.Append("\x2\xC09\xC0B\x3\x2\x2\x2\xC0A\xC0C\x5\x1E0\xF1\x2\xC0B\xC0A");
		sb.Append("\x3\x2\x2\x2\xC0B\xC0C\x3\x2\x2\x2\xC0C\xC54\x3\x2\x2\x2\xC0D");
		sb.Append("\xC0F\x5\x1D4\xEB\x2\xC0E\xC10\x5\x1D6\xEC\x2\xC0F\xC0E\x3\x2");
		sb.Append("\x2\x2\xC0F\xC10\x3\x2\x2\x2\xC10\xC12\x3\x2\x2\x2\xC11\xC13");
		sb.Append("\x5\x1D8\xED\x2\xC12\xC11\x3\x2\x2\x2\xC12\xC13\x3\x2\x2\x2");
		sb.Append("\xC13\xC15\x3\x2\x2\x2\xC14\xC16\x5\x1DA\xEE\x2\xC15\xC14\x3");
		sb.Append("\x2\x2\x2\xC15\xC16\x3\x2\x2\x2\xC16\xC18\x3\x2\x2\x2\xC17\xC19");
		sb.Append("\x5\x1DC\xEF\x2\xC18\xC17\x3\x2\x2\x2\xC18\xC19\x3\x2\x2\x2");
		sb.Append("\xC19\xC1B\x3\x2\x2\x2\xC1A\xC1C\x5\x1DE\xF0\x2\xC1B\xC1A\x3");
		sb.Append("\x2\x2\x2\xC1B\xC1C\x3\x2\x2\x2\xC1C\xC1E\x3\x2\x2\x2\xC1D\xC1F");
		sb.Append("\x5\x1E0\xF1\x2\xC1E\xC1D\x3\x2\x2\x2\xC1E\xC1F\x3\x2\x2\x2");
		sb.Append("\xC1F\xC54\x3\x2\x2\x2\xC20\xC22\x5\x1D6\xEC\x2\xC21\xC23\x5");
		sb.Append("\x1D8\xED\x2\xC22\xC21\x3\x2\x2\x2\xC22\xC23\x3\x2\x2\x2\xC23");
		sb.Append("\xC25\x3\x2\x2\x2\xC24\xC26\x5\x1DA\xEE\x2\xC25\xC24\x3\x2\x2");
		sb.Append("\x2\xC25\xC26\x3\x2\x2\x2\xC26\xC28\x3\x2\x2\x2\xC27\xC29\x5");
		sb.Append("\x1DC\xEF\x2\xC28\xC27\x3\x2\x2\x2\xC28\xC29\x3\x2\x2\x2\xC29");
		sb.Append("\xC2B\x3\x2\x2\x2\xC2A\xC2C\x5\x1DE\xF0\x2\xC2B\xC2A\x3\x2\x2");
		sb.Append("\x2\xC2B\xC2C\x3\x2\x2\x2\xC2C\xC2E\x3\x2\x2\x2\xC2D\xC2F\x5");
		sb.Append("\x1E0\xF1\x2\xC2E\xC2D\x3\x2\x2\x2\xC2E\xC2F\x3\x2\x2\x2\xC2F");
		sb.Append("\xC54\x3\x2\x2\x2\xC30\xC32\x5\x1D8\xED\x2\xC31\xC33\x5\x1DA");
		sb.Append("\xEE\x2\xC32\xC31\x3\x2\x2\x2\xC32\xC33\x3\x2\x2\x2\xC33\xC35");
		sb.Append("\x3\x2\x2\x2\xC34\xC36\x5\x1DC\xEF\x2\xC35\xC34\x3\x2\x2\x2");
		sb.Append("\xC35\xC36\x3\x2\x2\x2\xC36\xC38\x3\x2\x2\x2\xC37\xC39\x5\x1DE");
		sb.Append("\xF0\x2\xC38\xC37\x3\x2\x2\x2\xC38\xC39\x3\x2\x2\x2\xC39\xC3B");
		sb.Append("\x3\x2\x2\x2\xC3A\xC3C\x5\x1E0\xF1\x2\xC3B\xC3A\x3\x2\x2\x2");
		sb.Append("\xC3B\xC3C\x3\x2\x2\x2\xC3C\xC54\x3\x2\x2\x2\xC3D\xC3F\x5\x1DA");
		sb.Append("\xEE\x2\xC3E\xC40\x5\x1DC\xEF\x2\xC3F\xC3E\x3\x2\x2\x2\xC3F");
		sb.Append("\xC40\x3\x2\x2\x2\xC40\xC42\x3\x2\x2\x2\xC41\xC43\x5\x1DE\xF0");
		sb.Append("\x2\xC42\xC41\x3\x2\x2\x2\xC42\xC43\x3\x2\x2\x2\xC43\xC45\x3");
		sb.Append("\x2\x2\x2\xC44\xC46\x5\x1E0\xF1\x2\xC45\xC44\x3\x2\x2\x2\xC45");
		sb.Append("\xC46\x3\x2\x2\x2\xC46\xC54\x3\x2\x2\x2\xC47\xC49\x5\x1DC\xEF");
		sb.Append("\x2\xC48\xC4A\x5\x1DE\xF0\x2\xC49\xC48\x3\x2\x2\x2\xC49\xC4A");
		sb.Append("\x3\x2\x2\x2\xC4A\xC4C\x3\x2\x2\x2\xC4B\xC4D\x5\x1E0\xF1\x2");
		sb.Append("\xC4C\xC4B\x3\x2\x2\x2\xC4C\xC4D\x3\x2\x2\x2\xC4D\xC54\x3\x2");
		sb.Append("\x2\x2\xC4E\xC50\x5\x1DE\xF0\x2\xC4F\xC51\x5\x1E0\xF1\x2\xC50");
		sb.Append("\xC4F\x3\x2\x2\x2\xC50\xC51\x3\x2\x2\x2\xC51\xC54\x3\x2\x2\x2");
		sb.Append("\xC52\xC54\x5\x1E0\xF1\x2\xC53\xBDE\x3\x2\x2\x2\xC53\xBF7\x3");
		sb.Append("\x2\x2\x2\xC53\xC0D\x3\x2\x2\x2\xC53\xC20\x3\x2\x2\x2\xC53\xC30");
		sb.Append("\x3\x2\x2\x2\xC53\xC3D\x3\x2\x2\x2\xC53\xC47\x3\x2\x2\x2\xC53");
		sb.Append("\xC4E\x3\x2\x2\x2\xC53\xC52\x3\x2\x2\x2\xC54\x1CF\x3\x2\x2\x2");
		sb.Append("\xC55\xC59\x5\x1E8\xF5\x2\xC56\xC59\a\xC5\x2\x2\xC57\xC59\x5");
		sb.Append("\x1E4\xF3\x2\xC58\xC55\x3\x2\x2\x2\xC58\xC56\x3\x2\x2\x2\xC58");
		sb.Append("\xC57\x3\x2\x2\x2\xC59\xC5A\x3\x2\x2\x2\xC5A\xC5B\t\v\x2\x2");
		sb.Append("\xC5B\x1D1\x3\x2\x2\x2\xC5C\xC60\x5\x1E8\xF5\x2\xC5D\xC60\a");
		sb.Append("\xC5\x2\x2\xC5E\xC60\x5\x1E4\xF3\x2\xC5F\xC5C\x3\x2\x2\x2\xC5F");
		sb.Append("\xC5D\x3\x2\x2\x2\xC5F\xC5E\x3\x2\x2\x2\xC60\xC61\x3\x2\x2\x2");
		sb.Append("\xC61\xC62\t\f\x2\x2\xC62\x1D3\x3\x2\x2\x2\xC63\xC67\x5\x1E8");
		sb.Append("\xF5\x2\xC64\xC67\a\xC5\x2\x2\xC65\xC67\x5\x1E4\xF3\x2\xC66");
		sb.Append("\xC63\x3\x2\x2\x2\xC66\xC64\x3\x2\x2\x2\xC66\xC65\x3\x2\x2\x2");
		sb.Append("\xC67\xC68\x3\x2\x2\x2\xC68\xC69\t\r\x2\x2\xC69\x1D5\x3\x2\x2");
		sb.Append("\x2\xC6A\xC6E\x5\x1E8\xF5\x2\xC6B\xC6E\a\xC5\x2\x2\xC6C\xC6E");
		sb.Append("\x5\x1E4\xF3\x2\xC6D\xC6A\x3\x2\x2\x2\xC6D\xC6B\x3\x2\x2\x2");
		sb.Append("\xC6D\xC6C\x3\x2\x2\x2\xC6E\xC6F\x3\x2\x2\x2\xC6F\xC70\t\xE");
		sb.Append("\x2\x2\xC70\x1D7\x3\x2\x2\x2\xC71\xC75\x5\x1E8\xF5\x2\xC72\xC75");
		sb.Append("\a\xC5\x2\x2\xC73\xC75\x5\x1E4\xF3\x2\xC74\xC71\x3\x2\x2\x2");
		sb.Append("\xC74\xC72\x3\x2\x2\x2\xC74\xC73\x3\x2\x2\x2\xC75\xC76\x3\x2");
		sb.Append("\x2\x2\xC76\xC77\t\xF\x2\x2\xC77\x1D9\x3\x2\x2\x2\xC78\xC7C");
		sb.Append("\x5\x1E8\xF5\x2\xC79\xC7C\a\xC5\x2\x2\xC7A\xC7C\x5\x1E4\xF3");
		sb.Append("\x2\xC7B\xC78\x3\x2\x2\x2\xC7B\xC79\x3\x2\x2\x2\xC7B\xC7A\x3");
		sb.Append("\x2\x2\x2\xC7C\xC7D\x3\x2\x2\x2\xC7D\xC7E\t\x10\x2\x2\xC7E\x1DB");
		sb.Append("\x3\x2\x2\x2\xC7F\xC83\x5\x1E8\xF5\x2\xC80\xC83\a\xC5\x2\x2");
		sb.Append("\xC81\xC83\x5\x1E4\xF3\x2\xC82\xC7F\x3\x2\x2\x2\xC82\xC80\x3");
		sb.Append("\x2\x2\x2\xC82\xC81\x3\x2\x2\x2\xC83\xC84\x3\x2\x2\x2\xC84\xC85");
		sb.Append("\t\x11\x2\x2\xC85\x1DD\x3\x2\x2\x2\xC86\xC8A\x5\x1E8\xF5\x2");
		sb.Append("\xC87\xC8A\a\xC5\x2\x2\xC88\xC8A\x5\x1E4\xF3\x2\xC89\xC86\x3");
		sb.Append("\x2\x2\x2\xC89\xC87\x3\x2\x2\x2\xC89\xC88\x3\x2\x2\x2\xC8A\xC8B");
		sb.Append("\x3\x2\x2\x2\xC8B\xC8C\t\x12\x2\x2\xC8C\x1DF\x3\x2\x2\x2\xC8D");
		sb.Append("\xC91\x5\x1E8\xF5\x2\xC8E\xC91\a\xC5\x2\x2\xC8F\xC91\x5\x1E4");
		sb.Append("\xF3\x2\xC90\xC8D\x3\x2\x2\x2\xC90\xC8E\x3\x2\x2\x2\xC90\xC8F");
		sb.Append("\x3\x2\x2\x2\xC91\xC92\x3\x2\x2\x2\xC92\xC93\t\x13\x2\x2\xC93");
		sb.Append("\x1E1\x3\x2\x2\x2\xC94\xC95\t\x14\x2\x2\xC95\x1E3\x3\x2\x2\x2");
		sb.Append("\xC96\xC99\a\x91\x2\x2\xC97\xC98\a\x98\x2\x2\xC98\xC9A\x5\x19A");
		sb.Append("\xCE\x2\xC99\xC97\x3\x2\x2\x2\xC99\xC9A\x3\x2\x2\x2\xC9A\x1E5");
		sb.Append("\x3\x2\x2\x2\xC9B\xCA1\x5\x1E8\xF5\x2\xC9C\xCA1\x5\x1EA\xF6");
		sb.Append("\x2\xC9D\xCA1\am\x2\x2\xC9E\xCA1\an\x2\x2\xC9F\xCA1\ao\x2\x2");
		sb.Append("\xCA0\xC9B\x3\x2\x2\x2\xCA0\xC9C\x3\x2\x2\x2\xCA0\xC9D\x3\x2");
		sb.Append("\x2\x2\xCA0\xC9E\x3\x2\x2\x2\xCA0\xC9F\x3\x2\x2\x2\xCA1\x1E7");
		sb.Append("\x3\x2\x2\x2\xCA2\xCA5\a\xA3\x2\x2\xCA3\xCA5\a\xA0\x2\x2\xCA4");
		sb.Append("\xCA2\x3\x2\x2\x2\xCA4\xCA3\x3\x2\x2\x2\xCA4\xCA5\x3\x2\x2\x2");
		sb.Append("\xCA5\xCA6\x3\x2\x2\x2\xCA6\xCA7\x5\x1E2\xF2\x2\xCA7\x1E9\x3");
		sb.Append("\x2\x2\x2\xCA8\xCAB\a\xC4\x2\x2\xCA9\xCAB\a\xC3\x2\x2\xCAA\xCA8");
		sb.Append("\x3\x2\x2\x2\xCAA\xCA9\x3\x2\x2\x2\xCAB\x1EB\x3\x2\x2\x2\xCAC");
		sb.Append("\xCB0\x5\x1E6\xF4\x2\xCAD\xCB0\x5\x1EE\xF8\x2\xCAE\xCB0\x5\x1F0");
		sb.Append("\xF9\x2\xCAF\xCAC\x3\x2\x2\x2\xCAF\xCAD\x3\x2\x2\x2\xCAF\xCAE");
		sb.Append("\x3\x2\x2\x2\xCB0\x1ED\x3\x2\x2\x2\xCB1\xCB2\a\x96\x2\x2\xCB2");
		sb.Append("\xCB3\x5\x1F4\xFB\x2\xCB3\xCB4\a\x97\x2\x2\xCB4\x1EF\x3\x2\x2");
		sb.Append("\x2\xCB5\xCB7\a\x94\x2\x2\xCB6\xCB8\x5\x1F2\xFA\x2\xCB7\xCB6");
		sb.Append("\x3\x2\x2\x2\xCB7\xCB8\x3\x2\x2\x2\xCB8\xCB9\x3\x2\x2\x2\xCB9");
		sb.Append("\xCBA\a\x95\x2\x2\xCBA\x1F1\x3\x2\x2\x2\xCBB\xCC0\x5\x1EC\xF7");
		sb.Append("\x2\xCBC\xCBD\a\x99\x2\x2\xCBD\xCBF\x5\x1EC\xF7\x2\xCBE\xCBC");
		sb.Append("\x3\x2\x2\x2\xCBF\xCC2\x3\x2\x2\x2\xCC0\xCBE\x3\x2\x2\x2\xCC0");
		sb.Append("\xCC1\x3\x2\x2\x2\xCC1\xCC4\x3\x2\x2\x2\xCC2\xCC0\x3\x2\x2\x2");
		sb.Append("\xCC3\xCC5\a\x99\x2\x2\xCC4\xCC3\x3\x2\x2\x2\xCC4\xCC5\x3\x2");
		sb.Append("\x2\x2\xCC5\x1F3\x3\x2\x2\x2\xCC6\xCCB\x5\x1F6\xFC\x2\xCC7\xCC8");
		sb.Append("\a\x99\x2\x2\xCC8\xCCA\x5\x1F6\xFC\x2\xCC9\xCC7\x3\x2\x2\x2");
		sb.Append("\xCCA\xCCD\x3\x2\x2\x2\xCCB\xCC9\x3\x2\x2\x2\xCCB\xCCC\x3\x2");
		sb.Append("\x2\x2\xCCC\xCCF\x3\x2\x2\x2\xCCD\xCCB\x3\x2\x2\x2\xCCE\xCD0");
		sb.Append("\a\x99\x2\x2\xCCF\xCCE\x3\x2\x2\x2\xCCF\xCD0\x3\x2\x2\x2\xCD0");
		sb.Append("\x1F5\x3\x2\x2\x2\xCD1\xCD4\x5\x1EA\xF6\x2\xCD2\xCD4\x5\x1C8");
		sb.Append("\xE5\x2\xCD3\xCD1\x3\x2\x2\x2\xCD3\xCD2\x3\x2\x2\x2\xCD4\xCD5");
		sb.Append("\x3\x2\x2\x2\xCD5\xCD6\a\x98\x2\x2\xCD6\xCD7\x5\x1EC\xF7\x2");
		sb.Append("\xCD7\x1F7\x3\x2\x2\x2\x1D7\x1FA\x1FC\x204\x206\x214\x218\x21B");
		sb.Append("\x21E\x223\x226\x22A\x233\x23C\x243\x252\x255\x25C\x268\x270");
		sb.Append("\x273\x276\x27B\x28B\x28E\x295\x299\x29F\x2A2\x2A6\x2AB\x2AF");
		sb.Append("\x2B3\x2B8\x2BC\x2C5\x2C8\x2CA\x2CF\x2D3\x2D8\x2E2\x2E8\x2EC");
		sb.Append("\x2F2\x2F6\x2FB\x2FF\x305\x30A\x313\x318\x31B\x322\x327\x32F");
		sb.Append("\x335\x33B\x33F\x343\x346\x349\x34D\x351\x356\x35A\x35F\x363");
		sb.Append("\x36A\x370\x377\x37B\x382\x387\x38D\x397\x39F\x3A6\x3AC\x3B0");
		sb.Append("\x3B3\x3BA\x3BF\x3C1\x3C7\x3CD\x3DC\x3E1\x3E5\x3EB\x3EE\x3F3");
		sb.Append("\x3F9\x404\x40B\x40E\x411\x415\x417\x41D\x420\x427\x42F\x432");
		sb.Append("\x434\x43B\x442\x448\x44C\x453\x458\x45B\x460\x469\x46D\x47D");
		sb.Append("\x485\x48B\x490\x493\x496\x49A\x49D\x4A3\x4AE\x4B3\x4B6\x4C8");
		sb.Append("\x4CD\x4D5\x4DC\x4E0\x4E7\x4F5\x4F7\x4FD\x50C\x50F\x514\x51C");
		sb.Append("\x520\x524\x527\x52C\x531\x534\x538\x53F\x547\x54F\x556\x55C");
		sb.Append("\x55E\x563\x56B\x570\x574\x577\x57E\x58A\x598\x59D\x5A5\x5AB");
		sb.Append("\x5AE\x5B5\x5BB\x5C1\x5C8\x5CE\x5D1\x5D4\x5D9\x5E1\x5ED\x5F0");
		sb.Append("\x5F9\x5FF\x603\x606\x609\x613\x619\x61C\x621\x624\x628\x62E");
		sb.Append("\x631\x637\x644\x649\x64B\x654\x657\x65A\x662\x66B\x66E\x676");
		sb.Append("\x67C\x680\x683\x68A\x690\x699\x6A6\x6AD\x6B6\x6B9\x6BC\x6C3");
		sb.Append("\x6C9\x6CE\x6D4\x6DA\x6DD\x6E5\x6EB\x6EF\x6F2\x6F5\x6FC\x700");
		sb.Append("\x707\x70B\x70F\x713\x715\x726\x72A\x72D\x731\x734\x73F\x748");
		sb.Append("\x74E\x750\x765\x76C\x772\x777\x77F\x782\x78B\x794\x797\x799");
		sb.Append("\x79C\x7A0\x7A3\x7A6\x7B0\x7BE\x7C1\x7CC\x7CF\x7D5\x7DC\x7E4");
		sb.Append("\x7EC\x7F2\x7FB\x801\x805\x809\x80B\x80F\x817\x81D\x821\x825");
		sb.Append("\x827\x82B\x82F\x834\x83D\x840\x844\x84E\x852\x854\x85F\x862");
		sb.Append("\x869\x871\x87C\x88A\x897\x89A\x89E\x8A7\x8AC\x8AF\x8B3\x8BB");
		sb.Append("\x8C1\x8C5\x8CF\x8D6\x8DB\x8DF\x8E5\x8EA\x8EE\x8F6\x8F9\x8FD");
		sb.Append("\x902\x90A\x913\x91B\x923\x92B\x93A\x944\x948\x94F\x953\x95F");
		sb.Append("\x97B\x98C\x990\x99A\x99D\x9A2\x9A7\x9AB\x9AF\x9B3\x9BA\x9C2");
		sb.Append("\x9C6\x9C9\x9CE\x9D1\x9D6\x9DC\x9E8\x9EB\x9F2\x9F6\xA04\xA0C");
		sb.Append("\xA15\xA1D\xA21\xA26\xA2C\xA2F\xA31\xA3A\xA40\xA48\xA51\xA57");
		sb.Append("\xA5B\xA64\xA70\xA72\xA76\xA7C\xA81\xA84\xA87\xA8D\xA92\xA96");
		sb.Append("\xA9A\xA9E\xAAB\xAB3\xAB5\xABC\xAC6\xACB\xACE\xAD1\xAD4\xADC");
		sb.Append("\xAE3\xAE7\xAEE\xAF6\xAFE\xB03\xB07\xB0E\xB11\xB18\xB1B\xB22");
		sb.Append("\xB2A\xB37\xB3B\xB43\xB4E\xB53\xB59\xB5E\xB65\xB6F\xB77\xB7E");
		sb.Append("\xB86\xB8B\xB8F\xB92\xB98\xB9C\xBD3\xBD8\xBDC\xBE0\xBE3\xBE6");
		sb.Append("\xBE9\xBEC\xBEF\xBF2\xBF5\xBF9\xBFC\xBFF\xC02\xC05\xC08\xC0B");
		sb.Append("\xC0F\xC12\xC15\xC18\xC1B\xC1E\xC22\xC25\xC28\xC2B\xC2E\xC32");
		sb.Append("\xC35\xC38\xC3B\xC3F\xC42\xC45\xC49\xC4C\xC50\xC53\xC58\xC5F");
		sb.Append("\xC66\xC6D\xC74\xC7B\xC82\xC89\xC90\xC99\xCA0\xCA4\xCAA\xCAF");
		sb.Append("\xCB7\xCC0\xCC4\xCCB\xCCF\xCD3");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());


}
