//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Src\Espertech\NEsper-master\NEsper\grammar\EsperEPL2Grammar.g4 by ANTLR 4.5.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace com.espertech.esper.epl.generated {

  using System;
  using System.Collections.Generic;
  
  using com.espertech.esper.compat;
  using com.espertech.esper.compat.collections;
  using com.espertech.esper.compat.logging;

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.3")]
[System.CLSCompliant(false)]
public partial class EsperEPL2GrammarParser : Parser {
	public const int
		CREATE=1, WINDOW=2, IN_SET=3, BETWEEN=4, LIKE=5, REGEXP=6, ESCAPE=7, OR_EXPR=8, 
		AND_EXPR=9, NOT_EXPR=10, EVERY_EXPR=11, EVERY_DISTINCT_EXPR=12, WHERE=13, 
		AS=14, SUM=15, AVG=16, MAX=17, MIN=18, COALESCE=19, MEDIAN=20, STDDEV=21, 
		AVEDEV=22, COUNT=23, SELECT=24, CASE=25, ELSE=26, WHEN=27, THEN=28, END=29, 
		FROM=30, OUTER=31, INNER=32, JOIN=33, LEFT=34, RIGHT=35, FULL=36, ON=37, 
		IS=38, BY=39, GROUP=40, HAVING=41, DISTINCT=42, ALL=43, ANY=44, SOME=45, 
		OUTPUT=46, EVENTS=47, FIRST=48, LAST=49, INSERT=50, INTO=51, VALUES=52, 
		ORDER=53, ASC=54, DESC=55, RSTREAM=56, ISTREAM=57, IRSTREAM=58, SCHEMA=59, 
		UNIDIRECTIONAL=60, RETAINUNION=61, RETAININTERSECTION=62, PATTERN=63, 
		SQL=64, METADATASQL=65, PREVIOUS=66, PREVIOUSTAIL=67, PREVIOUSCOUNT=68, 
		PREVIOUSWINDOW=69, PRIOR=70, EXISTS=71, WEEKDAY=72, LW=73, INSTANCEOF=74, 
		TYPEOF=75, CAST=76, CURRENT_TIMESTAMP=77, DELETE=78, SNAPSHOT=79, SET=80, 
		VARIABLE=81, TABLE=82, UNTIL=83, AT=84, INDEX=85, TIMEPERIOD_YEAR=86, 
		TIMEPERIOD_YEARS=87, TIMEPERIOD_MONTH=88, TIMEPERIOD_MONTHS=89, TIMEPERIOD_WEEK=90, 
		TIMEPERIOD_WEEKS=91, TIMEPERIOD_DAY=92, TIMEPERIOD_DAYS=93, TIMEPERIOD_HOUR=94, 
		TIMEPERIOD_HOURS=95, TIMEPERIOD_MINUTE=96, TIMEPERIOD_MINUTES=97, TIMEPERIOD_SEC=98, 
		TIMEPERIOD_SECOND=99, TIMEPERIOD_SECONDS=100, TIMEPERIOD_MILLISEC=101, 
		TIMEPERIOD_MILLISECOND=102, TIMEPERIOD_MILLISECONDS=103, BOOLEAN_TRUE=104, 
		BOOLEAN_FALSE=105, VALUE_NULL=106, ROW_LIMIT_EXPR=107, OFFSET=108, UPDATE=109, 
		MATCH_RECOGNIZE=110, MATCH_RECOGNIZE_PERMUTE=111, MEASURES=112, DEFINE=113, 
		PARTITION=114, MATCHES=115, AFTER=116, FOR=117, WHILE=118, USING=119, 
		MERGE=120, MATCHED=121, EXPRESSIONDECL=122, NEWKW=123, START=124, CONTEXT=125, 
		INITIATED=126, TERMINATED=127, DATAFLOW=128, CUBE=129, ROLLUP=130, GROUPING=131, 
		GROUPING_ID=132, SETS=133, FOLLOWMAX_BEGIN=134, FOLLOWMAX_END=135, FOLLOWED_BY=136, 
		GOES=137, EQUALS=138, SQL_NE=139, QUESTION=140, LPAREN=141, RPAREN=142, 
		LBRACK=143, RBRACK=144, LCURLY=145, RCURLY=146, COLON=147, COMMA=148, 
		EQUAL=149, LNOT=150, BNOT=151, NOT_EQUAL=152, DIV=153, DIV_ASSIGN=154, 
		PLUS=155, PLUS_ASSIGN=156, INC=157, MINUS=158, MINUS_ASSIGN=159, DEC=160, 
		STAR=161, STAR_ASSIGN=162, MOD=163, MOD_ASSIGN=164, GE=165, GT=166, LE=167, 
		LT=168, BXOR=169, BXOR_ASSIGN=170, BOR=171, BOR_ASSIGN=172, LOR=173, BAND=174, 
		BAND_ASSIGN=175, LAND=176, SEMI=177, DOT=178, NUM_LONG=179, NUM_DOUBLE=180, 
		NUM_FLOAT=181, ESCAPECHAR=182, ESCAPEBACKTICK=183, ATCHAR=184, WS=185, 
		SL_COMMENT=186, ML_COMMENT=187, TICKED_STRING_LITERAL=188, QUOTED_STRING_LITERAL=189, 
		STRING_LITERAL=190, IDENT=191, IntegerLiteral=192, FloatingPointLiteral=193;
	public const int
		RULE_startPatternExpressionRule = 0, RULE_startEPLExpressionRule = 1, 
		RULE_startEventPropertyRule = 2, RULE_startJsonValueRule = 3, RULE_expressionDecl = 4, 
		RULE_expressionDialect = 5, RULE_expressionDef = 6, RULE_expressionLambdaDecl = 7, 
		RULE_annotationEnum = 8, RULE_elementValuePairsEnum = 9, RULE_elementValuePairEnum = 10, 
		RULE_elementValueEnum = 11, RULE_elementValueArrayEnum = 12, RULE_eplExpression = 13, 
		RULE_contextExpr = 14, RULE_selectExpr = 15, RULE_onExpr = 16, RULE_onStreamExpr = 17, 
		RULE_updateExpr = 18, RULE_updateDetails = 19, RULE_onMergeExpr = 20, 
		RULE_mergeItem = 21, RULE_mergeMatched = 22, RULE_mergeMatchedItem = 23, 
		RULE_mergeUnmatched = 24, RULE_mergeUnmatchedItem = 25, RULE_mergeInsert = 26, 
		RULE_onSelectExpr = 27, RULE_onUpdateExpr = 28, RULE_onSelectInsertExpr = 29, 
		RULE_outputClauseInsert = 30, RULE_onDeleteExpr = 31, RULE_onSetExpr = 32, 
		RULE_onSetAssignmentList = 33, RULE_onSetAssignment = 34, RULE_onExprFrom = 35, 
		RULE_createWindowExpr = 36, RULE_createWindowExprModelAfter = 37, RULE_createIndexExpr = 38, 
		RULE_createIndexColumnList = 39, RULE_createIndexColumn = 40, RULE_createVariableExpr = 41, 
		RULE_createTableExpr = 42, RULE_createTableColumnList = 43, RULE_createTableColumn = 44, 
		RULE_createTableColumnPlain = 45, RULE_createColumnList = 46, RULE_createColumnListElement = 47, 
		RULE_createSelectionList = 48, RULE_createSelectionListElement = 49, RULE_createSchemaExpr = 50, 
		RULE_createSchemaDef = 51, RULE_fafDelete = 52, RULE_fafUpdate = 53, RULE_fafInsert = 54, 
		RULE_createDataflow = 55, RULE_gopList = 56, RULE_gop = 57, RULE_gopParams = 58, 
		RULE_gopParamsItemList = 59, RULE_gopParamsItem = 60, RULE_gopParamsItemMany = 61, 
		RULE_gopParamsItemAs = 62, RULE_gopOut = 63, RULE_gopOutItem = 64, RULE_gopOutTypeList = 65, 
		RULE_gopOutTypeParam = 66, RULE_gopOutTypeItem = 67, RULE_gopDetail = 68, 
		RULE_gopConfig = 69, RULE_createContextExpr = 70, RULE_createExpressionExpr = 71, 
		RULE_createContextDetail = 72, RULE_contextContextNested = 73, RULE_createContextChoice = 74, 
		RULE_createContextDistinct = 75, RULE_createContextRangePoint = 76, RULE_createContextFilter = 77, 
		RULE_createContextPartitionItem = 78, RULE_createContextCoalesceItem = 79, 
		RULE_createContextGroupItem = 80, RULE_createSchemaQual = 81, RULE_variantList = 82, 
		RULE_variantListElement = 83, RULE_intoTableExpr = 84, RULE_insertIntoExpr = 85, 
		RULE_columnList = 86, RULE_fromClause = 87, RULE_regularJoin = 88, RULE_outerJoinList = 89, 
		RULE_outerJoin = 90, RULE_outerJoinIdent = 91, RULE_outerJoinIdentPair = 92, 
		RULE_whereClause = 93, RULE_selectClause = 94, RULE_selectionList = 95, 
		RULE_selectionListElement = 96, RULE_selectionListElementExpr = 97, RULE_selectionListElementAnno = 98, 
		RULE_streamSelector = 99, RULE_streamExpression = 100, RULE_forExpr = 101, 
		RULE_patternInclusionExpression = 102, RULE_databaseJoinExpression = 103, 
		RULE_methodJoinExpression = 104, RULE_viewExpression = 105, RULE_groupByListExpr = 106, 
		RULE_groupByListChoice = 107, RULE_groupByCubeOrRollup = 108, RULE_groupByGroupingSets = 109, 
		RULE_groupBySetsChoice = 110, RULE_groupByCombinableExpr = 111, RULE_orderByListExpr = 112, 
		RULE_orderByListElement = 113, RULE_havingClause = 114, RULE_outputLimit = 115, 
		RULE_outputLimitAndTerm = 116, RULE_outputLimitAfter = 117, RULE_rowLimit = 118, 
		RULE_crontabLimitParameterSet = 119, RULE_whenClause = 120, RULE_elseClause = 121, 
		RULE_matchRecog = 122, RULE_matchRecogPartitionBy = 123, RULE_matchRecogMeasures = 124, 
		RULE_matchRecogMeasureItem = 125, RULE_matchRecogMatchesSelection = 126, 
		RULE_matchRecogPattern = 127, RULE_matchRecogMatchesAfterSkip = 128, RULE_matchRecogMatchesInterval = 129, 
		RULE_matchRecogPatternAlteration = 130, RULE_matchRecogPatternConcat = 131, 
		RULE_matchRecogPatternUnary = 132, RULE_matchRecogPatternNested = 133, 
		RULE_matchRecogPatternPermute = 134, RULE_matchRecogPatternAtom = 135, 
		RULE_matchRecogPatternRepeat = 136, RULE_matchRecogDefine = 137, RULE_matchRecogDefineItem = 138, 
		RULE_expression = 139, RULE_caseExpression = 140, RULE_evalOrExpression = 141, 
		RULE_evalAndExpression = 142, RULE_bitWiseExpression = 143, RULE_negatedExpression = 144, 
		RULE_evalEqualsExpression = 145, RULE_evalRelationalExpression = 146, 
		RULE_inSubSelectQuery = 147, RULE_concatenationExpr = 148, RULE_additiveExpression = 149, 
		RULE_multiplyExpression = 150, RULE_unaryExpression = 151, RULE_substitutionCanChain = 152, 
		RULE_chainedFunction = 153, RULE_newAssign = 154, RULE_rowSubSelectExpression = 155, 
		RULE_subSelectGroupExpression = 156, RULE_existsSubSelectExpression = 157, 
		RULE_subQueryExpr = 158, RULE_subSelectFilterExpr = 159, RULE_arrayExpression = 160, 
		RULE_builtinFunc = 161, RULE_firstLastWindowAggregation = 162, RULE_eventPropertyOrLibFunction = 163, 
		RULE_libFunction = 164, RULE_libFunctionWithClass = 165, RULE_libFunctionNoClass = 166, 
		RULE_funcIdentTop = 167, RULE_funcIdentInner = 168, RULE_funcIdentChained = 169, 
		RULE_libFunctionArgs = 170, RULE_libFunctionArgItem = 171, RULE_betweenList = 172, 
		RULE_patternExpression = 173, RULE_followedByExpression = 174, RULE_followedByRepeat = 175, 
		RULE_orExpression = 176, RULE_andExpression = 177, RULE_matchUntilExpression = 178, 
		RULE_qualifyExpression = 179, RULE_guardPostFix = 180, RULE_distinctExpressionList = 181, 
		RULE_distinctExpressionAtom = 182, RULE_atomicExpression = 183, RULE_observerExpression = 184, 
		RULE_guardWhereExpression = 185, RULE_guardWhileExpression = 186, RULE_matchUntilRange = 187, 
		RULE_eventFilterExpression = 188, RULE_propertyExpression = 189, RULE_propertyExpressionAtomic = 190, 
		RULE_propertyExpressionSelect = 191, RULE_propertyExpressionAnnotation = 192, 
		RULE_propertySelectionList = 193, RULE_propertySelectionListElement = 194, 
		RULE_propertyStreamSelector = 195, RULE_patternFilterExpression = 196, 
		RULE_patternFilterAnnotation = 197, RULE_classIdentifier = 198, RULE_slashIdentifier = 199, 
		RULE_expressionListWithNamed = 200, RULE_expressionListWithNamedWithTime = 201, 
		RULE_expressionWithNamed = 202, RULE_expressionWithNamedWithTime = 203, 
		RULE_expressionNamedParameter = 204, RULE_expressionNamedParameterWithTime = 205, 
		RULE_expressionList = 206, RULE_expressionWithTimeList = 207, RULE_expressionWithTime = 208, 
		RULE_expressionWithTimeInclLast = 209, RULE_expressionQualifyable = 210, 
		RULE_lastWeekdayOperand = 211, RULE_lastOperand = 212, RULE_frequencyOperand = 213, 
		RULE_rangeOperand = 214, RULE_lastOperator = 215, RULE_weekDayOperator = 216, 
		RULE_numericParameterList = 217, RULE_numericListParameter = 218, RULE_eventProperty = 219, 
		RULE_eventPropertyAtomic = 220, RULE_eventPropertyIdent = 221, RULE_keywordAllowedIdent = 222, 
		RULE_escapableStr = 223, RULE_escapableIdent = 224, RULE_timePeriod = 225, 
		RULE_yearPart = 226, RULE_monthPart = 227, RULE_weekPart = 228, RULE_dayPart = 229, 
		RULE_hourPart = 230, RULE_minutePart = 231, RULE_secondPart = 232, RULE_millisecondPart = 233, 
		RULE_number = 234, RULE_substitution = 235, RULE_constant = 236, RULE_numberconstant = 237, 
		RULE_stringconstant = 238, RULE_jsonvalue = 239, RULE_jsonobject = 240, 
		RULE_jsonarray = 241, RULE_jsonelements = 242, RULE_jsonmembers = 243, 
		RULE_jsonpair = 244;
	public static readonly string[] ruleNames = {
		"startPatternExpressionRule", "startEPLExpressionRule", "startEventPropertyRule", 
		"startJsonValueRule", "expressionDecl", "expressionDialect", "expressionDef", 
		"expressionLambdaDecl", "annotationEnum", "elementValuePairsEnum", "elementValuePairEnum", 
		"elementValueEnum", "elementValueArrayEnum", "eplExpression", "contextExpr", 
		"selectExpr", "onExpr", "onStreamExpr", "updateExpr", "updateDetails", 
		"onMergeExpr", "mergeItem", "mergeMatched", "mergeMatchedItem", "mergeUnmatched", 
		"mergeUnmatchedItem", "mergeInsert", "onSelectExpr", "onUpdateExpr", "onSelectInsertExpr", 
		"outputClauseInsert", "onDeleteExpr", "onSetExpr", "onSetAssignmentList", 
		"onSetAssignment", "onExprFrom", "createWindowExpr", "createWindowExprModelAfter", 
		"createIndexExpr", "createIndexColumnList", "createIndexColumn", "createVariableExpr", 
		"createTableExpr", "createTableColumnList", "createTableColumn", "createTableColumnPlain", 
		"createColumnList", "createColumnListElement", "createSelectionList", 
		"createSelectionListElement", "createSchemaExpr", "createSchemaDef", "fafDelete", 
		"fafUpdate", "fafInsert", "createDataflow", "gopList", "gop", "gopParams", 
		"gopParamsItemList", "gopParamsItem", "gopParamsItemMany", "gopParamsItemAs", 
		"gopOut", "gopOutItem", "gopOutTypeList", "gopOutTypeParam", "gopOutTypeItem", 
		"gopDetail", "gopConfig", "createContextExpr", "createExpressionExpr", 
		"createContextDetail", "contextContextNested", "createContextChoice", 
		"createContextDistinct", "createContextRangePoint", "createContextFilter", 
		"createContextPartitionItem", "createContextCoalesceItem", "createContextGroupItem", 
		"createSchemaQual", "variantList", "variantListElement", "intoTableExpr", 
		"insertIntoExpr", "columnList", "fromClause", "regularJoin", "outerJoinList", 
		"outerJoin", "outerJoinIdent", "outerJoinIdentPair", "whereClause", "selectClause", 
		"selectionList", "selectionListElement", "selectionListElementExpr", "selectionListElementAnno", 
		"streamSelector", "streamExpression", "forExpr", "patternInclusionExpression", 
		"databaseJoinExpression", "methodJoinExpression", "viewExpression", "groupByListExpr", 
		"groupByListChoice", "groupByCubeOrRollup", "groupByGroupingSets", "groupBySetsChoice", 
		"groupByCombinableExpr", "orderByListExpr", "orderByListElement", "havingClause", 
		"outputLimit", "outputLimitAndTerm", "outputLimitAfter", "rowLimit", "crontabLimitParameterSet", 
		"whenClause", "elseClause", "matchRecog", "matchRecogPartitionBy", "matchRecogMeasures", 
		"matchRecogMeasureItem", "matchRecogMatchesSelection", "matchRecogPattern", 
		"matchRecogMatchesAfterSkip", "matchRecogMatchesInterval", "matchRecogPatternAlteration", 
		"matchRecogPatternConcat", "matchRecogPatternUnary", "matchRecogPatternNested", 
		"matchRecogPatternPermute", "matchRecogPatternAtom", "matchRecogPatternRepeat", 
		"matchRecogDefine", "matchRecogDefineItem", "expression", "caseExpression", 
		"evalOrExpression", "evalAndExpression", "bitWiseExpression", "negatedExpression", 
		"evalEqualsExpression", "evalRelationalExpression", "inSubSelectQuery", 
		"concatenationExpr", "additiveExpression", "multiplyExpression", "unaryExpression", 
		"substitutionCanChain", "chainedFunction", "newAssign", "rowSubSelectExpression", 
		"subSelectGroupExpression", "existsSubSelectExpression", "subQueryExpr", 
		"subSelectFilterExpr", "arrayExpression", "builtinFunc", "firstLastWindowAggregation", 
		"eventPropertyOrLibFunction", "libFunction", "libFunctionWithClass", "libFunctionNoClass", 
		"funcIdentTop", "funcIdentInner", "funcIdentChained", "libFunctionArgs", 
		"libFunctionArgItem", "betweenList", "patternExpression", "followedByExpression", 
		"followedByRepeat", "orExpression", "andExpression", "matchUntilExpression", 
		"qualifyExpression", "guardPostFix", "distinctExpressionList", "distinctExpressionAtom", 
		"atomicExpression", "observerExpression", "guardWhereExpression", "guardWhileExpression", 
		"matchUntilRange", "eventFilterExpression", "propertyExpression", "propertyExpressionAtomic", 
		"propertyExpressionSelect", "propertyExpressionAnnotation", "propertySelectionList", 
		"propertySelectionListElement", "propertyStreamSelector", "patternFilterExpression", 
		"patternFilterAnnotation", "classIdentifier", "slashIdentifier", "expressionListWithNamed", 
		"expressionListWithNamedWithTime", "expressionWithNamed", "expressionWithNamedWithTime", 
		"expressionNamedParameter", "expressionNamedParameterWithTime", "expressionList", 
		"expressionWithTimeList", "expressionWithTime", "expressionWithTimeInclLast", 
		"expressionQualifyable", "lastWeekdayOperand", "lastOperand", "frequencyOperand", 
		"rangeOperand", "lastOperator", "weekDayOperator", "numericParameterList", 
		"numericListParameter", "eventProperty", "eventPropertyAtomic", "eventPropertyIdent", 
		"keywordAllowedIdent", "escapableStr", "escapableIdent", "timePeriod", 
		"yearPart", "monthPart", "weekPart", "dayPart", "hourPart", "minutePart", 
		"secondPart", "millisecondPart", "number", "substitution", "constant", 
		"numberconstant", "stringconstant", "jsonvalue", "jsonobject", "jsonarray", 
		"jsonelements", "jsonmembers", "jsonpair"
	};

	private static readonly string[] _LiteralNames = {
		null, "'create'", "'window'", "'in'", "'between'", "'like'", "'regexp'", 
		"'escape'", "'or'", "'and'", "'not'", "'every'", "'every-distinct'", "'where'", 
		"'as'", "'sum'", "'avg'", "'max'", "'min'", "'coalesce'", "'median'", 
		"'stddev'", "'avedev'", "'count'", "'select'", "'case'", "'else'", "'when'", 
		"'then'", "'end'", "'from'", "'outer'", "'inner'", "'join'", "'left'", 
		"'right'", "'full'", "'on'", "'is'", "'by'", "'group'", "'having'", "'distinct'", 
		"'all'", "'any'", "'some'", "'output'", "'events'", "'first'", "'last'", 
		"'insert'", "'into'", "'values'", "'order'", "'asc'", "'desc'", "'rstream'", 
		"'istream'", "'irstream'", "'schema'", "'unidirectional'", "'retain-union'", 
		"'retain-intersection'", "'pattern'", "'sql'", "'metadatasql'", "'prev'", 
		"'prevtail'", "'prevcount'", "'prevwindow'", "'prior'", "'exists'", "'weekday'", 
		"'lastweekday'", "'instanceof'", "'typeof'", "'cast'", "'current_timestamp'", 
		"'delete'", "'snapshot'", "'set'", "'variable'", "'table'", "'until'", 
		"'at'", "'index'", "'year'", "'years'", "'month'", "'months'", "'week'", 
		"'weeks'", "'day'", "'days'", "'hour'", "'hours'", "'minute'", "'minutes'", 
		"'sec'", "'second'", "'seconds'", "'msec'", "'millisecond'", "'milliseconds'", 
		"'true'", "'false'", "'null'", "'limit'", "'offset'", "'update'", "'match_recognize'", 
		"'match_recognize_permute'", "'measures'", "'define'", "'partition'", 
		"'matches'", "'after'", "'for'", "'while'", "'using'", "'merge'", "'matched'", 
		"'expression'", "'new'", "'start'", "'context'", "'initiated'", "'terminated'", 
		"'dataflow'", "'cube'", "'rollup'", "'grouping'", "'grouping_id'", "'sets'", 
		"'-['", "']>'", "'->'", "'=>'", "'='", "'<>'", "'?'", "'('", "')'", "'['", 
		"']'", "'{'", "'}'", "':'", "','", "'=='", "'!'", "'~'", "'!='", "'/'", 
		"'/='", "'+'", "'+='", "'++'", "'-'", "'-='", "'--'", "'*'", "'*='", "'%'", 
		"'%='", "'>='", "'>'", "'<='", "'<'", "'^'", "'^='", "'|'", "'|='", "'||'", 
		"'&'", "'&='", "'&&'", "';'", "'.'", "'\\u18FF'", "'\\u18FE'", "'\\u18FD'", 
		"'\\'", "'`'", "'@'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "CREATE", "WINDOW", "IN_SET", "BETWEEN", "LIKE", "REGEXP", "ESCAPE", 
		"OR_EXPR", "AND_EXPR", "NOT_EXPR", "EVERY_EXPR", "EVERY_DISTINCT_EXPR", 
		"WHERE", "AS", "SUM", "AVG", "MAX", "MIN", "COALESCE", "MEDIAN", "STDDEV", 
		"AVEDEV", "COUNT", "SELECT", "CASE", "ELSE", "WHEN", "THEN", "END", "FROM", 
		"OUTER", "INNER", "JOIN", "LEFT", "RIGHT", "FULL", "ON", "IS", "BY", "GROUP", 
		"HAVING", "DISTINCT", "ALL", "ANY", "SOME", "OUTPUT", "EVENTS", "FIRST", 
		"LAST", "INSERT", "INTO", "VALUES", "ORDER", "ASC", "DESC", "RSTREAM", 
		"ISTREAM", "IRSTREAM", "SCHEMA", "UNIDIRECTIONAL", "RETAINUNION", "RETAININTERSECTION", 
		"PATTERN", "SQL", "METADATASQL", "PREVIOUS", "PREVIOUSTAIL", "PREVIOUSCOUNT", 
		"PREVIOUSWINDOW", "PRIOR", "EXISTS", "WEEKDAY", "LW", "INSTANCEOF", "TYPEOF", 
		"CAST", "CURRENT_TIMESTAMP", "DELETE", "SNAPSHOT", "SET", "VARIABLE", 
		"TABLE", "UNTIL", "AT", "INDEX", "TIMEPERIOD_YEAR", "TIMEPERIOD_YEARS", 
		"TIMEPERIOD_MONTH", "TIMEPERIOD_MONTHS", "TIMEPERIOD_WEEK", "TIMEPERIOD_WEEKS", 
		"TIMEPERIOD_DAY", "TIMEPERIOD_DAYS", "TIMEPERIOD_HOUR", "TIMEPERIOD_HOURS", 
		"TIMEPERIOD_MINUTE", "TIMEPERIOD_MINUTES", "TIMEPERIOD_SEC", "TIMEPERIOD_SECOND", 
		"TIMEPERIOD_SECONDS", "TIMEPERIOD_MILLISEC", "TIMEPERIOD_MILLISECOND", 
		"TIMEPERIOD_MILLISECONDS", "BOOLEAN_TRUE", "BOOLEAN_FALSE", "VALUE_NULL", 
		"ROW_LIMIT_EXPR", "OFFSET", "UPDATE", "MATCH_RECOGNIZE", "MATCH_RECOGNIZE_PERMUTE", 
		"MEASURES", "DEFINE", "PARTITION", "MATCHES", "AFTER", "FOR", "WHILE", 
		"USING", "MERGE", "MATCHED", "EXPRESSIONDECL", "NEWKW", "START", "CONTEXT", 
		"INITIATED", "TERMINATED", "DATAFLOW", "CUBE", "ROLLUP", "GROUPING", "GROUPING_ID", 
		"SETS", "FOLLOWMAX_BEGIN", "FOLLOWMAX_END", "FOLLOWED_BY", "GOES", "EQUALS", 
		"SQL_NE", "QUESTION", "LPAREN", "RPAREN", "LBRACK", "RBRACK", "LCURLY", 
		"RCURLY", "COLON", "COMMA", "EQUAL", "LNOT", "BNOT", "NOT_EQUAL", "DIV", 
		"DIV_ASSIGN", "PLUS", "PLUS_ASSIGN", "INC", "MINUS", "MINUS_ASSIGN", "DEC", 
		"STAR", "STAR_ASSIGN", "MOD", "MOD_ASSIGN", "GE", "GT", "LE", "LT", "BXOR", 
		"BXOR_ASSIGN", "BOR", "BOR_ASSIGN", "LOR", "BAND", "BAND_ASSIGN", "LAND", 
		"SEMI", "DOT", "NUM_LONG", "NUM_DOUBLE", "NUM_FLOAT", "ESCAPECHAR", "ESCAPEBACKTICK", 
		"ATCHAR", "WS", "SL_COMMENT", "ML_COMMENT", "TICKED_STRING_LITERAL", "QUOTED_STRING_LITERAL", 
		"STRING_LITERAL", "IDENT", "IntegerLiteral", "FloatingPointLiteral"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "EsperEPL2Grammar.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }


		// provide nice error messages
		private System.Collections.Generic.Stack<string> paraphrases =
			new System.Collections.Generic.Stack<string>();

		// static information initialized once
		private static System.Collections.Generic.IDictionary<int, string> lexerTokenParaphases =
			       new System.Collections.Generic.Dictionary<int, string>();
		private static System.Collections.Generic.IDictionary<int, string> parserTokenParaphases =
				   new System.Collections.Generic.Dictionary<int, string>();
		private static System.Collections.Generic.ISet<string> parserKeywordSet =
				   new System.Collections.Generic.HashSet<string>();
		private static System.Collections.Generic.ISet<int> afterScriptTokens =
				   new System.Collections.Generic.HashSet<int>();

		private static readonly Object _iLock = new Object();

		public System.Collections.Generic.Stack<string> GetParaphrases()
		{
			return paraphrases;
		}

		public System.Collections.Generic.ISet<string> GetKeywords()
		{
			GetParserTokenParaphrases();
			return parserKeywordSet;
		}

		public static System.Collections.Generic.IDictionary<int, string> GetLexerTokenParaphrases()
		{
			lock(_iLock)
			{ 
				if (lexerTokenParaphases.Count == 0)
				{
					lexerTokenParaphases.Put(IDENT, "an identifier");
					lexerTokenParaphases.Put(FOLLOWED_BY, "an followed-by '->'");
					lexerTokenParaphases.Put(EQUALS, "an equals '='");
					lexerTokenParaphases.Put(SQL_NE, "a sql-style not equals '<>'");
					lexerTokenParaphases.Put(QUESTION, "a questionmark '?'");
					lexerTokenParaphases.Put(LPAREN, "an opening parenthesis '('");
					lexerTokenParaphases.Put(RPAREN, "a closing parenthesis ')'");
					lexerTokenParaphases.Put(LBRACK, "a left angle bracket '['");
					lexerTokenParaphases.Put(RBRACK, "a right angle bracket ']'");
					lexerTokenParaphases.Put(LCURLY, "a left curly bracket '{'");
					lexerTokenParaphases.Put(RCURLY, "a right curly bracket '}'");
					lexerTokenParaphases.Put(COLON, "a colon ':'");
					lexerTokenParaphases.Put(COMMA, "a comma ','");
					lexerTokenParaphases.Put(EQUAL, "an equals compare '=='");
					lexerTokenParaphases.Put(LNOT, "a not '!'");
					lexerTokenParaphases.Put(BNOT, "a binary not '~'");
					lexerTokenParaphases.Put(NOT_EQUAL, "a not equals '!='");
					lexerTokenParaphases.Put(DIV, "a division operator '\'");
					lexerTokenParaphases.Put(DIV_ASSIGN, "a division assign '/='");
					lexerTokenParaphases.Put(PLUS, "a plus operator '+'");
					lexerTokenParaphases.Put(PLUS_ASSIGN, "a plus assign '+='");
					lexerTokenParaphases.Put(INC, "an increment operator '++'");
					lexerTokenParaphases.Put(MINUS, "a minus '-'");
					lexerTokenParaphases.Put(MINUS_ASSIGN, "a minus assign '-='");
					lexerTokenParaphases.Put(DEC, "a decrement operator '--'");
					lexerTokenParaphases.Put(STAR, "a star '*'");
					lexerTokenParaphases.Put(STAR_ASSIGN, "a star assign '*='");
					lexerTokenParaphases.Put(MOD, "a modulo");
					lexerTokenParaphases.Put(MOD_ASSIGN, "a modulo assign");
					lexerTokenParaphases.Put(GE, "a greater equals '>='");
					lexerTokenParaphases.Put(GT, "a greater then '>'");
					lexerTokenParaphases.Put(LE, "a less equals '<='");
					lexerTokenParaphases.Put(LT, "a lesser then '<'");
					lexerTokenParaphases.Put(BXOR, "a binary xor '^'");
					lexerTokenParaphases.Put(BXOR_ASSIGN, "a binary xor assign '^='");
					lexerTokenParaphases.Put(BOR, "a binary or '|'");
					lexerTokenParaphases.Put(BOR_ASSIGN, "a binary or assign '|='");
					lexerTokenParaphases.Put(LOR, "a logical or '||'");
					lexerTokenParaphases.Put(BAND, "a binary and '&'");
					lexerTokenParaphases.Put(BAND_ASSIGN, "a binary and assign '&='");
					lexerTokenParaphases.Put(LAND, "a logical and '&&'");
					lexerTokenParaphases.Put(SEMI, "a semicolon ';'");
					lexerTokenParaphases.Put(DOT, "a dot '.'");
				}
			}
			
			return lexerTokenParaphases;
		}

		public static System.Collections.Generic.IDictionary<int, string> GetParserTokenParaphrases()
		{
			lock(_iLock)
			{ 
				if (parserTokenParaphases.Count == 0)
				{
					parserTokenParaphases.Put(CREATE, "'create'");
					parserTokenParaphases.Put(WINDOW, "'window'");
					parserTokenParaphases.Put(IN_SET, "'in'");
					parserTokenParaphases.Put(BETWEEN, "'between'");
					parserTokenParaphases.Put(LIKE, "'like'");
					parserTokenParaphases.Put(REGEXP, "'regexp'");
					parserTokenParaphases.Put(ESCAPE, "'escape'");
					parserTokenParaphases.Put(OR_EXPR, "'or'");
					parserTokenParaphases.Put(AND_EXPR, "'and'");
					parserTokenParaphases.Put(NOT_EXPR, "'not'");
					parserTokenParaphases.Put(EVERY_EXPR, "'every'");
					parserTokenParaphases.Put(EVERY_DISTINCT_EXPR, "'every-distinct'");
					parserTokenParaphases.Put(WHERE, "'where'");
					parserTokenParaphases.Put(AS, "'as'");	
					parserTokenParaphases.Put(SUM, "'sum'");
					parserTokenParaphases.Put(AVG, "'avg'");
					parserTokenParaphases.Put(MAX, "'max'");
					parserTokenParaphases.Put(MIN, "'min'");
					parserTokenParaphases.Put(COALESCE, "'coalesce'");
					parserTokenParaphases.Put(MEDIAN, "'median'");
					parserTokenParaphases.Put(STDDEV, "'stddev'");
					parserTokenParaphases.Put(AVEDEV, "'avedev'");
					parserTokenParaphases.Put(COUNT, "'count'");
					parserTokenParaphases.Put(SELECT, "'select'");
					parserTokenParaphases.Put(CASE, "'case'");
					parserTokenParaphases.Put(ELSE, "'else'");
					parserTokenParaphases.Put(WHEN, "'when'");
					parserTokenParaphases.Put(THEN, "'then'");
					parserTokenParaphases.Put(END, "'end'");
					parserTokenParaphases.Put(FROM, "'from'");
					parserTokenParaphases.Put(OUTER, "'outer'");
					parserTokenParaphases.Put(INNER, "'inner'");
					parserTokenParaphases.Put(JOIN, "'join'");
					parserTokenParaphases.Put(LEFT, "'left'");
					parserTokenParaphases.Put(RIGHT, "'right'");
					parserTokenParaphases.Put(FULL, "'full'");
					parserTokenParaphases.Put(ON, "'on'");	
					parserTokenParaphases.Put(IS, "'is'");
					parserTokenParaphases.Put(BY, "'by'");
					parserTokenParaphases.Put(GROUP, "'group'");
					parserTokenParaphases.Put(HAVING, "'having'");
					parserTokenParaphases.Put(ALL, "'all'");
					parserTokenParaphases.Put(ANY, "'any'");
					parserTokenParaphases.Put(SOME, "'some'");
					parserTokenParaphases.Put(OUTPUT, "'output'");
					parserTokenParaphases.Put(EVENTS, "'events'");
					parserTokenParaphases.Put(FIRST, "'first'");
					parserTokenParaphases.Put(LAST, "'last'");
					parserTokenParaphases.Put(INSERT, "'insert'");
					parserTokenParaphases.Put(INTO, "'into'");
					parserTokenParaphases.Put(ORDER, "'order'");
					parserTokenParaphases.Put(ASC, "'asc'");
					parserTokenParaphases.Put(DESC, "'desc'");
					parserTokenParaphases.Put(RSTREAM, "'rstream'");
					parserTokenParaphases.Put(ISTREAM, "'istream'");
					parserTokenParaphases.Put(IRSTREAM, "'irstream'");
					parserTokenParaphases.Put(SCHEMA, "'schema'");
					parserTokenParaphases.Put(UNIDIRECTIONAL, "'unidirectional'");
					parserTokenParaphases.Put(RETAINUNION, "'retain-union'");
					parserTokenParaphases.Put(RETAININTERSECTION, "'retain-intersection'");
					parserTokenParaphases.Put(PATTERN, "'pattern'");
					parserTokenParaphases.Put(SQL, "'sql'");
					parserTokenParaphases.Put(METADATASQL, "'metadatasql'");
					parserTokenParaphases.Put(PREVIOUS, "'prev'");
					parserTokenParaphases.Put(PREVIOUSTAIL, "'prevtail'");
					parserTokenParaphases.Put(PREVIOUSCOUNT, "'prevcount'");
					parserTokenParaphases.Put(PREVIOUSWINDOW, "'prevwindow'");
					parserTokenParaphases.Put(PRIOR, "'prior'");
					parserTokenParaphases.Put(EXISTS, "'exists'");
					parserTokenParaphases.Put(WEEKDAY, "'weekday'");
					parserTokenParaphases.Put(LW, "'lastweekday'");
					parserTokenParaphases.Put(INSTANCEOF, "'instanceof'");
					parserTokenParaphases.Put(TYPEOF, "'typeof'");
					parserTokenParaphases.Put(CAST, "'cast'");
					parserTokenParaphases.Put(CURRENT_TIMESTAMP, "'current_timestamp'");
					parserTokenParaphases.Put(DELETE, "'delete'");
					parserTokenParaphases.Put(DISTINCT, "'distinct'");
					parserTokenParaphases.Put(SNAPSHOT, "'snapshot'");
					parserTokenParaphases.Put(SET, "'set'");
					parserTokenParaphases.Put(VARIABLE, "'variable'");
					parserTokenParaphases.Put(TABLE, "'table'");
					parserTokenParaphases.Put(INDEX, "'index'");
					parserTokenParaphases.Put(UNTIL, "'until'");
					parserTokenParaphases.Put(AT, "'at'");
					parserTokenParaphases.Put(TIMEPERIOD_YEAR, "'year'");
					parserTokenParaphases.Put(TIMEPERIOD_YEARS, "'years'");
					parserTokenParaphases.Put(TIMEPERIOD_MONTH, "'month'");
					parserTokenParaphases.Put(TIMEPERIOD_MONTHS, "'months'");
					parserTokenParaphases.Put(TIMEPERIOD_WEEK, "'week'");
					parserTokenParaphases.Put(TIMEPERIOD_WEEKS, "'weeks'");
					parserTokenParaphases.Put(TIMEPERIOD_DAY, "'day'");
					parserTokenParaphases.Put(TIMEPERIOD_DAYS, "'days'");
					parserTokenParaphases.Put(TIMEPERIOD_HOUR, "'hour'");
					parserTokenParaphases.Put(TIMEPERIOD_HOURS, "'hours'");
					parserTokenParaphases.Put(TIMEPERIOD_MINUTE, "'minute'");
					parserTokenParaphases.Put(TIMEPERIOD_MINUTES, "'minutes'");
					parserTokenParaphases.Put(TIMEPERIOD_SEC, "'sec'");
					parserTokenParaphases.Put(TIMEPERIOD_SECOND, "'second'");
					parserTokenParaphases.Put(TIMEPERIOD_SECONDS, "'seconds'");
					parserTokenParaphases.Put(TIMEPERIOD_MILLISEC, "'msec'");
					parserTokenParaphases.Put(TIMEPERIOD_MILLISECOND, "'millisecond'");
					parserTokenParaphases.Put(TIMEPERIOD_MILLISECONDS, "'milliseconds'");
					parserTokenParaphases.Put(BOOLEAN_TRUE, "'true'");
					parserTokenParaphases.Put(BOOLEAN_FALSE, "'false'");
					parserTokenParaphases.Put(VALUE_NULL, "'null'");
					parserTokenParaphases.Put(ROW_LIMIT_EXPR, "'limit'");
					parserTokenParaphases.Put(OFFSET, "'offset'");
					parserTokenParaphases.Put(UPDATE, "'update'");
					parserTokenParaphases.Put(MATCH_RECOGNIZE, "'match_recognize'");
					parserTokenParaphases.Put(MEASURES, "'measures'");
					parserTokenParaphases.Put(DEFINE, "'define'");
					parserTokenParaphases.Put(PARTITION, "'partition'");
					parserTokenParaphases.Put(MATCHES, "'matches'");
					parserTokenParaphases.Put(AFTER, "'after'");
					parserTokenParaphases.Put(FOR, "'for'");
					parserTokenParaphases.Put(WHILE, "'while'");
					parserTokenParaphases.Put(MERGE, "'merge'");
					parserTokenParaphases.Put(MATCHED, "'matched'");
					parserTokenParaphases.Put(CONTEXT, "'context'");
					parserTokenParaphases.Put(START, "'start'");
					parserTokenParaphases.Put(END, "'end'");
					parserTokenParaphases.Put(INITIATED, "'initiated'");
					parserTokenParaphases.Put(TERMINATED, "'terminated'");
					parserTokenParaphases.Put(USING, "'using'");
					parserTokenParaphases.Put(EXPRESSIONDECL, "'expression'");
					parserTokenParaphases.Put(NEWKW, "'new'");
					parserTokenParaphases.Put(DATAFLOW, "'dataflow'");
					parserTokenParaphases.Put(VALUES, "'values'");
					parserTokenParaphases.Put(CUBE, "'cube'");
					parserTokenParaphases.Put(ROLLUP, "'rollup'");
					parserTokenParaphases.Put(GROUPING, "'grouping'");
					parserTokenParaphases.Put(GROUPING_ID, "'grouping_id'");
					parserTokenParaphases.Put(SETS, "'sets'");

					parserKeywordSet = new HashSet<string>(
						parserTokenParaphases.Values);
				}
			}

			return parserTokenParaphases;
		}

		public static System.Collections.Generic.ISet<int> GetAfterScriptTokens()
		{
			if (afterScriptTokens.Count == 0)
			{
				afterScriptTokens.Add(CREATE);
				afterScriptTokens.Add(EXPRESSIONDECL);
				afterScriptTokens.Add(SELECT);
				afterScriptTokens.Add(INSERT);
				afterScriptTokens.Add(ON);
				afterScriptTokens.Add(DELETE);
				afterScriptTokens.Add(UPDATE);
				afterScriptTokens.Add(ATCHAR);
			}

			return afterScriptTokens;
		}

	public EsperEPL2GrammarParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class StartPatternExpressionRuleContext : ParserRuleContext {
		public PatternExpressionContext patternExpression() {
			return GetRuleContext<PatternExpressionContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(EsperEPL2GrammarParser.Eof, 0); }
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public ExpressionDeclContext[] expressionDecl() {
			return GetRuleContexts<ExpressionDeclContext>();
		}
		public ExpressionDeclContext expressionDecl(int i) {
			return GetRuleContext<ExpressionDeclContext>(i);
		}
		public StartPatternExpressionRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startPatternExpressionRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStartPatternExpressionRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStartPatternExpressionRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartPatternExpressionRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartPatternExpressionRuleContext startPatternExpressionRule() {
		StartPatternExpressionRuleContext _localctx = new StartPatternExpressionRuleContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_startPatternExpressionRule);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 494;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==EXPRESSIONDECL || _la==ATCHAR) {
				{
				State = 492;
				switch (_input.La(1)) {
				case ATCHAR:
					{
					State = 490; annotationEnum();
					}
					break;
				case EXPRESSIONDECL:
					{
					State = 491; expressionDecl();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 496;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 497; patternExpression();
			State = 498; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartEPLExpressionRuleContext : ParserRuleContext {
		public EplExpressionContext eplExpression() {
			return GetRuleContext<EplExpressionContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(EsperEPL2GrammarParser.Eof, 0); }
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public ExpressionDeclContext[] expressionDecl() {
			return GetRuleContexts<ExpressionDeclContext>();
		}
		public ExpressionDeclContext expressionDecl(int i) {
			return GetRuleContext<ExpressionDeclContext>(i);
		}
		public StartEPLExpressionRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startEPLExpressionRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStartEPLExpressionRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStartEPLExpressionRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartEPLExpressionRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartEPLExpressionRuleContext startEPLExpressionRule() {
		StartEPLExpressionRuleContext _localctx = new StartEPLExpressionRuleContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_startEPLExpressionRule);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 504;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==EXPRESSIONDECL || _la==ATCHAR) {
				{
				State = 502;
				switch (_input.La(1)) {
				case ATCHAR:
					{
					State = 500; annotationEnum();
					}
					break;
				case EXPRESSIONDECL:
					{
					State = 501; expressionDecl();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 506;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 507; eplExpression();
			State = 508; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartEventPropertyRuleContext : ParserRuleContext {
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(EsperEPL2GrammarParser.Eof, 0); }
		public StartEventPropertyRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startEventPropertyRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStartEventPropertyRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStartEventPropertyRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartEventPropertyRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartEventPropertyRuleContext startEventPropertyRule() {
		StartEventPropertyRuleContext _localctx = new StartEventPropertyRuleContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_startEventPropertyRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 510; eventProperty();
			State = 511; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartJsonValueRuleContext : ParserRuleContext {
		public JsonvalueContext jsonvalue() {
			return GetRuleContext<JsonvalueContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(EsperEPL2GrammarParser.Eof, 0); }
		public StartJsonValueRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startJsonValueRule; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStartJsonValueRule(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStartJsonValueRule(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartJsonValueRule(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartJsonValueRuleContext startJsonValueRule() {
		StartJsonValueRuleContext _localctx = new StartJsonValueRuleContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_startJsonValueRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 513; jsonvalue();
			State = 514; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionDeclContext : ParserRuleContext {
		public IToken array;
		public IToken name;
		public IToken alias;
		public ITerminalNode EXPRESSIONDECL() { return GetToken(EsperEPL2GrammarParser.EXPRESSIONDECL, 0); }
		public ExpressionDefContext expressionDef() {
			return GetRuleContext<ExpressionDefContext>(0);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ExpressionDialectContext expressionDialect() {
			return GetRuleContext<ExpressionDialectContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode FOR() { return GetToken(EsperEPL2GrammarParser.FOR, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public ExpressionDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionDecl; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionDeclContext expressionDecl() {
		ExpressionDeclContext _localctx = new ExpressionDeclContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_expressionDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 516; Match(EXPRESSIONDECL);
			State = 518;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				{
				State = 517; classIdentifier();
				}
				break;
			}
			State = 522;
			_la = _input.La(1);
			if (_la==LBRACK) {
				{
				State = 520; _localctx.array = Match(LBRACK);
				State = 521; Match(RBRACK);
				}
			}

			State = 525;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
			case 1:
				{
				State = 524; expressionDialect();
				}
				break;
			}
			State = 527; _localctx.name = Match(IDENT);
			State = 533;
			_la = _input.La(1);
			if (_la==LPAREN) {
				{
				State = 528; Match(LPAREN);
				State = 530;
				_la = _input.La(1);
				if (_la==IDENT) {
					{
					State = 529; columnList();
					}
				}

				State = 532; Match(RPAREN);
				}
			}

			State = 537;
			_la = _input.La(1);
			if (_la==IDENT) {
				{
				State = 535; _localctx.alias = Match(IDENT);
				State = 536; Match(FOR);
				}
			}

			State = 539; expressionDef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionDialectContext : ParserRuleContext {
		public IToken d;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ExpressionDialectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionDialect; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionDialect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionDialect(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionDialect(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionDialectContext expressionDialect() {
		ExpressionDialectContext _localctx = new ExpressionDialectContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_expressionDialect);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 541; _localctx.d = Match(IDENT);
			State = 542; Match(COLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionDefContext : ParserRuleContext {
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public ExpressionLambdaDeclContext expressionLambdaDecl() {
			return GetRuleContext<ExpressionLambdaDeclContext>(0);
		}
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public StringconstantContext stringconstant() {
			return GetRuleContext<StringconstantContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ExpressionDefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionDef; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionDef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionDef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionDef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionDefContext expressionDef() {
		ExpressionDefContext _localctx = new ExpressionDefContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_expressionDef);
		try {
			State = 555;
			switch (_input.La(1)) {
			case LCURLY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 544; Match(LCURLY);
				State = 546;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,10,_ctx) ) {
				case 1:
					{
					State = 545; expressionLambdaDecl();
					}
					break;
				}
				State = 548; expression();
				State = 549; Match(RCURLY);
				}
				break;
			case LBRACK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 551; Match(LBRACK);
				State = 552; stringconstant();
				State = 553; Match(RBRACK);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionLambdaDeclContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode GOES() { return GetToken(EsperEPL2GrammarParser.GOES, 0); }
		public ITerminalNode FOLLOWED_BY() { return GetToken(EsperEPL2GrammarParser.FOLLOWED_BY, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionLambdaDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionLambdaDecl; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionLambdaDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionLambdaDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionLambdaDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionLambdaDeclContext expressionLambdaDecl() {
		ExpressionLambdaDeclContext _localctx = new ExpressionLambdaDeclContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_expressionLambdaDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 562;
			switch (_input.La(1)) {
			case IDENT:
				{
				State = 557; _localctx.i = Match(IDENT);
				}
				break;
			case LPAREN:
				{
				{
				State = 558; Match(LPAREN);
				State = 559; columnList();
				State = 560; Match(RPAREN);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 564;
			_la = _input.La(1);
			if ( !(_la==FOLLOWED_BY || _la==GOES) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnnotationEnumContext : ParserRuleContext {
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ElementValuePairsEnumContext elementValuePairsEnum() {
			return GetRuleContext<ElementValuePairsEnumContext>(0);
		}
		public ElementValueEnumContext elementValueEnum() {
			return GetRuleContext<ElementValueEnumContext>(0);
		}
		public AnnotationEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_annotationEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterAnnotationEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitAnnotationEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnnotationEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnnotationEnumContext annotationEnum() {
		AnnotationEnumContext _localctx = new AnnotationEnumContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_annotationEnum);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 566; Match(ATCHAR);
			State = 567; classIdentifier();
			State = 574;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,14,_ctx) ) {
			case 1:
				{
				State = 568; Match(LPAREN);
				State = 571;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,13,_ctx) ) {
				case 1:
					{
					State = 569; elementValuePairsEnum();
					}
					break;

				case 2:
					{
					State = 570; elementValueEnum();
					}
					break;
				}
				State = 573; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementValuePairsEnumContext : ParserRuleContext {
		public ElementValuePairEnumContext[] elementValuePairEnum() {
			return GetRuleContexts<ElementValuePairEnumContext>();
		}
		public ElementValuePairEnumContext elementValuePairEnum(int i) {
			return GetRuleContext<ElementValuePairEnumContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ElementValuePairsEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementValuePairsEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElementValuePairsEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElementValuePairsEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementValuePairsEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementValuePairsEnumContext elementValuePairsEnum() {
		ElementValuePairsEnumContext _localctx = new ElementValuePairsEnumContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_elementValuePairsEnum);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 576; elementValuePairEnum();
			State = 581;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 577; Match(COMMA);
				State = 578; elementValuePairEnum();
				}
				}
				State = 583;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementValuePairEnumContext : ParserRuleContext {
		public IToken i;
		public ElementValueEnumContext elementValueEnum() {
			return GetRuleContext<ElementValueEnumContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ElementValuePairEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementValuePairEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElementValuePairEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElementValuePairEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementValuePairEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementValuePairEnumContext elementValuePairEnum() {
		ElementValuePairEnumContext _localctx = new ElementValuePairEnumContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_elementValuePairEnum);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 584; _localctx.i = Match(IDENT);
			State = 585; Match(EQUALS);
			State = 586; elementValueEnum();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementValueEnumContext : ParserRuleContext {
		public IToken v;
		public AnnotationEnumContext annotationEnum() {
			return GetRuleContext<AnnotationEnumContext>(0);
		}
		public ElementValueArrayEnumContext elementValueArrayEnum() {
			return GetRuleContext<ElementValueArrayEnumContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ElementValueEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementValueEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElementValueEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElementValueEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementValueEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementValueEnumContext elementValueEnum() {
		ElementValueEnumContext _localctx = new ElementValueEnumContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_elementValueEnum);
		try {
			State = 593;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,16,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 588; annotationEnum();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 589; elementValueArrayEnum();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 590; constant();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 591; _localctx.v = Match(IDENT);
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 592; classIdentifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementValueArrayEnumContext : ParserRuleContext {
		public ElementValueEnumContext[] elementValueEnum() {
			return GetRuleContexts<ElementValueEnumContext>();
		}
		public ElementValueEnumContext elementValueEnum(int i) {
			return GetRuleContext<ElementValueEnumContext>(i);
		}
		public ElementValueArrayEnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementValueArrayEnum; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElementValueArrayEnum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElementValueArrayEnum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementValueArrayEnum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementValueArrayEnumContext elementValueArrayEnum() {
		ElementValueArrayEnumContext _localctx = new ElementValueArrayEnumContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_elementValueArrayEnum);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 595; Match(LCURLY);
			State = 604;
			_la = _input.La(1);
			if (((((_la - 47)) & ~0x3f) == 0 && ((1L << (_la - 47)) & ((1L << (EVENTS - 47)) | (1L << (BOOLEAN_TRUE - 47)) | (1L << (BOOLEAN_FALSE - 47)) | (1L << (VALUE_NULL - 47)))) != 0) || ((((_la - 145)) & ~0x3f) == 0 && ((1L << (_la - 145)) & ((1L << (LCURLY - 145)) | (1L << (PLUS - 145)) | (1L << (MINUS - 145)) | (1L << (ATCHAR - 145)) | (1L << (TICKED_STRING_LITERAL - 145)) | (1L << (QUOTED_STRING_LITERAL - 145)) | (1L << (STRING_LITERAL - 145)) | (1L << (IDENT - 145)) | (1L << (IntegerLiteral - 145)) | (1L << (FloatingPointLiteral - 145)))) != 0)) {
				{
				State = 596; elementValueEnum();
				State = 601;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,17,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 597; Match(COMMA);
						State = 598; elementValueEnum();
						}
						} 
					}
					State = 603;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,17,_ctx);
				}
				}
			}

			State = 607;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 606; Match(COMMA);
				}
			}

			State = 609; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EplExpressionContext : ParserRuleContext {
		public SelectExprContext selectExpr() {
			return GetRuleContext<SelectExprContext>(0);
		}
		public CreateWindowExprContext createWindowExpr() {
			return GetRuleContext<CreateWindowExprContext>(0);
		}
		public CreateIndexExprContext createIndexExpr() {
			return GetRuleContext<CreateIndexExprContext>(0);
		}
		public CreateVariableExprContext createVariableExpr() {
			return GetRuleContext<CreateVariableExprContext>(0);
		}
		public CreateTableExprContext createTableExpr() {
			return GetRuleContext<CreateTableExprContext>(0);
		}
		public CreateSchemaExprContext createSchemaExpr() {
			return GetRuleContext<CreateSchemaExprContext>(0);
		}
		public CreateContextExprContext createContextExpr() {
			return GetRuleContext<CreateContextExprContext>(0);
		}
		public CreateExpressionExprContext createExpressionExpr() {
			return GetRuleContext<CreateExpressionExprContext>(0);
		}
		public OnExprContext onExpr() {
			return GetRuleContext<OnExprContext>(0);
		}
		public UpdateExprContext updateExpr() {
			return GetRuleContext<UpdateExprContext>(0);
		}
		public CreateDataflowContext createDataflow() {
			return GetRuleContext<CreateDataflowContext>(0);
		}
		public FafDeleteContext fafDelete() {
			return GetRuleContext<FafDeleteContext>(0);
		}
		public FafUpdateContext fafUpdate() {
			return GetRuleContext<FafUpdateContext>(0);
		}
		public FafInsertContext fafInsert() {
			return GetRuleContext<FafInsertContext>(0);
		}
		public ContextExprContext contextExpr() {
			return GetRuleContext<ContextExprContext>(0);
		}
		public ForExprContext forExpr() {
			return GetRuleContext<ForExprContext>(0);
		}
		public EplExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eplExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEplExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEplExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEplExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EplExpressionContext eplExpression() {
		EplExpressionContext _localctx = new EplExpressionContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_eplExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 612;
			_la = _input.La(1);
			if (_la==CONTEXT) {
				{
				State = 611; contextExpr();
				}
			}

			State = 628;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,21,_ctx) ) {
			case 1:
				{
				State = 614; selectExpr();
				}
				break;

			case 2:
				{
				State = 615; createWindowExpr();
				}
				break;

			case 3:
				{
				State = 616; createIndexExpr();
				}
				break;

			case 4:
				{
				State = 617; createVariableExpr();
				}
				break;

			case 5:
				{
				State = 618; createTableExpr();
				}
				break;

			case 6:
				{
				State = 619; createSchemaExpr();
				}
				break;

			case 7:
				{
				State = 620; createContextExpr();
				}
				break;

			case 8:
				{
				State = 621; createExpressionExpr();
				}
				break;

			case 9:
				{
				State = 622; onExpr();
				}
				break;

			case 10:
				{
				State = 623; updateExpr();
				}
				break;

			case 11:
				{
				State = 624; createDataflow();
				}
				break;

			case 12:
				{
				State = 625; fafDelete();
				}
				break;

			case 13:
				{
				State = 626; fafUpdate();
				}
				break;

			case 14:
				{
				State = 627; fafInsert();
				}
				break;
			}
			State = 631;
			_la = _input.La(1);
			if (_la==FOR) {
				{
				State = 630; forExpr();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ContextExprContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode CONTEXT() { return GetToken(EsperEPL2GrammarParser.CONTEXT, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ContextExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_contextExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterContextExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitContextExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContextExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ContextExprContext contextExpr() {
		ContextExprContext _localctx = new ContextExprContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_contextExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 633; Match(CONTEXT);
			State = 634; _localctx.i = Match(IDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectExprContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectClauseContext selectClause() {
			return GetRuleContext<SelectClauseContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(EsperEPL2GrammarParser.INTO, 0); }
		public IntoTableExprContext intoTableExpr() {
			return GetRuleContext<IntoTableExprContext>(0);
		}
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public InsertIntoExprContext insertIntoExpr() {
			return GetRuleContext<InsertIntoExprContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public FromClauseContext fromClause() {
			return GetRuleContext<FromClauseContext>(0);
		}
		public MatchRecogContext matchRecog() {
			return GetRuleContext<MatchRecogContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode GROUP() { return GetToken(EsperEPL2GrammarParser.GROUP, 0); }
		public ITerminalNode[] BY() { return GetTokens(EsperEPL2GrammarParser.BY); }
		public ITerminalNode BY(int i) {
			return GetToken(EsperEPL2GrammarParser.BY, i);
		}
		public GroupByListExprContext groupByListExpr() {
			return GetRuleContext<GroupByListExprContext>(0);
		}
		public ITerminalNode HAVING() { return GetToken(EsperEPL2GrammarParser.HAVING, 0); }
		public HavingClauseContext havingClause() {
			return GetRuleContext<HavingClauseContext>(0);
		}
		public ITerminalNode OUTPUT() { return GetToken(EsperEPL2GrammarParser.OUTPUT, 0); }
		public OutputLimitContext outputLimit() {
			return GetRuleContext<OutputLimitContext>(0);
		}
		public ITerminalNode ORDER() { return GetToken(EsperEPL2GrammarParser.ORDER, 0); }
		public OrderByListExprContext orderByListExpr() {
			return GetRuleContext<OrderByListExprContext>(0);
		}
		public ITerminalNode ROW_LIMIT_EXPR() { return GetToken(EsperEPL2GrammarParser.ROW_LIMIT_EXPR, 0); }
		public RowLimitContext rowLimit() {
			return GetRuleContext<RowLimitContext>(0);
		}
		public SelectExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectExprContext selectExpr() {
		SelectExprContext _localctx = new SelectExprContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_selectExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 638;
			_la = _input.La(1);
			if (_la==INTO) {
				{
				State = 636; Match(INTO);
				State = 637; intoTableExpr();
				}
			}

			State = 642;
			_la = _input.La(1);
			if (_la==INSERT) {
				{
				State = 640; Match(INSERT);
				State = 641; insertIntoExpr();
				}
			}

			State = 644; Match(SELECT);
			State = 645; selectClause();
			State = 648;
			_la = _input.La(1);
			if (_la==FROM) {
				{
				State = 646; Match(FROM);
				State = 647; fromClause();
				}
			}

			State = 651;
			_la = _input.La(1);
			if (_la==MATCH_RECOGNIZE) {
				{
				State = 650; matchRecog();
				}
			}

			State = 655;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 653; Match(WHERE);
				State = 654; whereClause();
				}
			}

			State = 660;
			_la = _input.La(1);
			if (_la==GROUP) {
				{
				State = 657; Match(GROUP);
				State = 658; Match(BY);
				State = 659; groupByListExpr();
				}
			}

			State = 664;
			_la = _input.La(1);
			if (_la==HAVING) {
				{
				State = 662; Match(HAVING);
				State = 663; havingClause();
				}
			}

			State = 668;
			_la = _input.La(1);
			if (_la==OUTPUT) {
				{
				State = 666; Match(OUTPUT);
				State = 667; outputLimit();
				}
			}

			State = 673;
			_la = _input.La(1);
			if (_la==ORDER) {
				{
				State = 670; Match(ORDER);
				State = 671; Match(BY);
				State = 672; orderByListExpr();
				}
			}

			State = 677;
			_la = _input.La(1);
			if (_la==ROW_LIMIT_EXPR) {
				{
				State = 675; Match(ROW_LIMIT_EXPR);
				State = 676; rowLimit();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnExprContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(EsperEPL2GrammarParser.ON, 0); }
		public OnStreamExprContext onStreamExpr() {
			return GetRuleContext<OnStreamExprContext>(0);
		}
		public OnDeleteExprContext onDeleteExpr() {
			return GetRuleContext<OnDeleteExprContext>(0);
		}
		public OnSelectExprContext onSelectExpr() {
			return GetRuleContext<OnSelectExprContext>(0);
		}
		public OnSetExprContext onSetExpr() {
			return GetRuleContext<OnSetExprContext>(0);
		}
		public OnUpdateExprContext onUpdateExpr() {
			return GetRuleContext<OnUpdateExprContext>(0);
		}
		public OnMergeExprContext onMergeExpr() {
			return GetRuleContext<OnMergeExprContext>(0);
		}
		public OnSelectInsertExprContext[] onSelectInsertExpr() {
			return GetRuleContexts<OnSelectInsertExprContext>();
		}
		public OnSelectInsertExprContext onSelectInsertExpr(int i) {
			return GetRuleContext<OnSelectInsertExprContext>(i);
		}
		public OutputClauseInsertContext outputClauseInsert() {
			return GetRuleContext<OutputClauseInsertContext>(0);
		}
		public OnExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnExprContext onExpr() {
		OnExprContext _localctx = new OnExprContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_onExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 679; Match(ON);
			State = 680; onStreamExpr();
			State = 696;
			switch (_input.La(1)) {
			case DELETE:
				{
				State = 681; onDeleteExpr();
				}
				break;
			case SELECT:
			case INSERT:
				{
				State = 682; onSelectExpr();
				State = 691;
				_la = _input.La(1);
				if (_la==INSERT) {
					{
					State = 684;
					_errHandler.Sync(this);
					_la = _input.La(1);
					do {
						{
						{
						State = 683; onSelectInsertExpr();
						}
						}
						State = 686;
						_errHandler.Sync(this);
						_la = _input.La(1);
					} while ( _la==INSERT );
					State = 689;
					_la = _input.La(1);
					if (_la==OUTPUT) {
						{
						State = 688; outputClauseInsert();
						}
					}

					}
				}

				}
				break;
			case SET:
				{
				State = 693; onSetExpr();
				}
				break;
			case UPDATE:
				{
				State = 694; onUpdateExpr();
				}
				break;
			case MERGE:
				{
				State = 695; onMergeExpr();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnStreamExprContext : ParserRuleContext {
		public IToken i;
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public PatternInclusionExpressionContext patternInclusionExpression() {
			return GetRuleContext<PatternInclusionExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public OnStreamExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onStreamExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnStreamExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnStreamExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnStreamExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnStreamExprContext onStreamExpr() {
		OnStreamExprContext _localctx = new OnStreamExprContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_onStreamExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 700;
			switch (_input.La(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 698; eventFilterExpression();
				}
				break;
			case PATTERN:
				{
				State = 699; patternInclusionExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 705;
			switch (_input.La(1)) {
			case AS:
				{
				State = 702; Match(AS);
				State = 703; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 704; _localctx.i = Match(IDENT);
				}
				break;
			case SELECT:
			case INSERT:
			case DELETE:
			case SET:
			case UPDATE:
			case MERGE:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdateExprContext : ParserRuleContext {
		public ITerminalNode UPDATE() { return GetToken(EsperEPL2GrammarParser.UPDATE, 0); }
		public ITerminalNode ISTREAM() { return GetToken(EsperEPL2GrammarParser.ISTREAM, 0); }
		public UpdateDetailsContext updateDetails() {
			return GetRuleContext<UpdateDetailsContext>(0);
		}
		public UpdateExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updateExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterUpdateExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitUpdateExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdateExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UpdateExprContext updateExpr() {
		UpdateExprContext _localctx = new UpdateExprContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_updateExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 707; Match(UPDATE);
			State = 708; Match(ISTREAM);
			State = 709; updateDetails();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UpdateDetailsContext : ParserRuleContext {
		public IToken i;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public OnSetAssignmentListContext onSetAssignmentList() {
			return GetRuleContext<OnSetAssignmentListContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public UpdateDetailsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_updateDetails; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterUpdateDetails(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitUpdateDetails(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdateDetails(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UpdateDetailsContext updateDetails() {
		UpdateDetailsContext _localctx = new UpdateDetailsContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_updateDetails);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 711; classIdentifier();
			State = 715;
			switch (_input.La(1)) {
			case AS:
				{
				State = 712; Match(AS);
				State = 713; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 714; _localctx.i = Match(IDENT);
				}
				break;
			case SET:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 717; Match(SET);
			State = 718; onSetAssignmentList();
			State = 721;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 719; Match(WHERE);
				State = 720; whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnMergeExprContext : ParserRuleContext {
		public IToken n;
		public IToken i;
		public ITerminalNode MERGE() { return GetToken(EsperEPL2GrammarParser.MERGE, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode INTO() { return GetToken(EsperEPL2GrammarParser.INTO, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public MergeItemContext[] mergeItem() {
			return GetRuleContexts<MergeItemContext>();
		}
		public MergeItemContext mergeItem(int i) {
			return GetRuleContext<MergeItemContext>(i);
		}
		public OnMergeExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onMergeExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnMergeExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnMergeExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnMergeExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnMergeExprContext onMergeExpr() {
		OnMergeExprContext _localctx = new OnMergeExprContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_onMergeExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 723; Match(MERGE);
			State = 725;
			_la = _input.La(1);
			if (_la==INTO) {
				{
				State = 724; Match(INTO);
				}
			}

			State = 727; _localctx.n = Match(IDENT);
			State = 731;
			switch (_input.La(1)) {
			case AS:
				{
				State = 728; Match(AS);
				State = 729; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 730; _localctx.i = Match(IDENT);
				}
				break;
			case WHERE:
			case WHEN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 735;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 733; Match(WHERE);
				State = 734; whereClause();
				}
			}

			State = 738;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 737; mergeItem();
				}
				}
				State = 740;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WHEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeItemContext : ParserRuleContext {
		public MergeMatchedContext mergeMatched() {
			return GetRuleContext<MergeMatchedContext>(0);
		}
		public MergeUnmatchedContext mergeUnmatched() {
			return GetRuleContext<MergeUnmatchedContext>(0);
		}
		public MergeItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeItemContext mergeItem() {
		MergeItemContext _localctx = new MergeItemContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_mergeItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 744;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,45,_ctx) ) {
			case 1:
				{
				State = 742; mergeMatched();
				}
				break;

			case 2:
				{
				State = 743; mergeUnmatched();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeMatchedContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public ITerminalNode MATCHED() { return GetToken(EsperEPL2GrammarParser.MATCHED, 0); }
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public MergeMatchedItemContext[] mergeMatchedItem() {
			return GetRuleContexts<MergeMatchedItemContext>();
		}
		public MergeMatchedItemContext mergeMatchedItem(int i) {
			return GetRuleContext<MergeMatchedItemContext>(i);
		}
		public MergeMatchedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeMatched; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeMatched(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeMatched(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeMatched(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeMatchedContext mergeMatched() {
		MergeMatchedContext _localctx = new MergeMatchedContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_mergeMatched);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 746; Match(WHEN);
			State = 747; Match(MATCHED);
			State = 750;
			_la = _input.La(1);
			if (_la==AND_EXPR) {
				{
				State = 748; Match(AND_EXPR);
				State = 749; expression();
				}
			}

			State = 753;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 752; mergeMatchedItem();
				}
				}
				State = 755;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==THEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeMatchedItemContext : ParserRuleContext {
		public IToken u;
		public IToken d;
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public MergeInsertContext mergeInsert() {
			return GetRuleContext<MergeInsertContext>(0);
		}
		public ITerminalNode DELETE() { return GetToken(EsperEPL2GrammarParser.DELETE, 0); }
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public OnSetAssignmentListContext onSetAssignmentList() {
			return GetRuleContext<OnSetAssignmentListContext>(0);
		}
		public ITerminalNode UPDATE() { return GetToken(EsperEPL2GrammarParser.UPDATE, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public MergeMatchedItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeMatchedItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeMatchedItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeMatchedItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeMatchedItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeMatchedItemContext mergeMatchedItem() {
		MergeMatchedItemContext _localctx = new MergeMatchedItemContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_mergeMatchedItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 757; Match(THEN);
			State = 772;
			switch (_input.La(1)) {
			case UPDATE:
				{
				{
				State = 758; _localctx.u = Match(UPDATE);
				State = 759; Match(SET);
				State = 760; onSetAssignmentList();
				}
				State = 764;
				_la = _input.La(1);
				if (_la==WHERE) {
					{
					State = 762; Match(WHERE);
					State = 763; whereClause();
					}
				}

				}
				break;
			case DELETE:
				{
				State = 766; _localctx.d = Match(DELETE);
				State = 769;
				_la = _input.La(1);
				if (_la==WHERE) {
					{
					State = 767; Match(WHERE);
					State = 768; whereClause();
					}
				}

				}
				break;
			case INSERT:
				{
				State = 771; mergeInsert();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUnmatchedContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public ITerminalNode NOT_EXPR() { return GetToken(EsperEPL2GrammarParser.NOT_EXPR, 0); }
		public ITerminalNode MATCHED() { return GetToken(EsperEPL2GrammarParser.MATCHED, 0); }
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public MergeUnmatchedItemContext[] mergeUnmatchedItem() {
			return GetRuleContexts<MergeUnmatchedItemContext>();
		}
		public MergeUnmatchedItemContext mergeUnmatchedItem(int i) {
			return GetRuleContext<MergeUnmatchedItemContext>(i);
		}
		public MergeUnmatchedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUnmatched; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeUnmatched(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeUnmatched(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeUnmatched(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeUnmatchedContext mergeUnmatched() {
		MergeUnmatchedContext _localctx = new MergeUnmatchedContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_mergeUnmatched);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 774; Match(WHEN);
			State = 775; Match(NOT_EXPR);
			State = 776; Match(MATCHED);
			State = 779;
			_la = _input.La(1);
			if (_la==AND_EXPR) {
				{
				State = 777; Match(AND_EXPR);
				State = 778; expression();
				}
			}

			State = 782;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 781; mergeUnmatchedItem();
				}
				}
				State = 784;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==THEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeUnmatchedItemContext : ParserRuleContext {
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public MergeInsertContext mergeInsert() {
			return GetRuleContext<MergeInsertContext>(0);
		}
		public MergeUnmatchedItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeUnmatchedItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeUnmatchedItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeUnmatchedItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeUnmatchedItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeUnmatchedItemContext mergeUnmatchedItem() {
		MergeUnmatchedItemContext _localctx = new MergeUnmatchedItemContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_mergeUnmatchedItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 786; Match(THEN);
			State = 787; mergeInsert();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeInsertContext : ParserRuleContext {
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(EsperEPL2GrammarParser.INTO, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public MergeInsertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeInsert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMergeInsert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMergeInsert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeInsert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeInsertContext mergeInsert() {
		MergeInsertContext _localctx = new MergeInsertContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_mergeInsert);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 789; Match(INSERT);
			State = 792;
			_la = _input.La(1);
			if (_la==INTO) {
				{
				State = 790; Match(INTO);
				State = 791; classIdentifier();
				}
			}

			State = 798;
			_la = _input.La(1);
			if (_la==LPAREN) {
				{
				State = 794; Match(LPAREN);
				State = 795; columnList();
				State = 796; Match(RPAREN);
				}
			}

			State = 800; Match(SELECT);
			State = 801; selectionList();
			State = 804;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 802; Match(WHERE);
				State = 803; whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSelectExprContext : ParserRuleContext {
		public IToken d;
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public InsertIntoExprContext insertIntoExpr() {
			return GetRuleContext<InsertIntoExprContext>(0);
		}
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public OnExprFromContext onExprFrom() {
			return GetRuleContext<OnExprFromContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode GROUP() { return GetToken(EsperEPL2GrammarParser.GROUP, 0); }
		public ITerminalNode[] BY() { return GetTokens(EsperEPL2GrammarParser.BY); }
		public ITerminalNode BY(int i) {
			return GetToken(EsperEPL2GrammarParser.BY, i);
		}
		public GroupByListExprContext groupByListExpr() {
			return GetRuleContext<GroupByListExprContext>(0);
		}
		public ITerminalNode HAVING() { return GetToken(EsperEPL2GrammarParser.HAVING, 0); }
		public HavingClauseContext havingClause() {
			return GetRuleContext<HavingClauseContext>(0);
		}
		public ITerminalNode ORDER() { return GetToken(EsperEPL2GrammarParser.ORDER, 0); }
		public OrderByListExprContext orderByListExpr() {
			return GetRuleContext<OrderByListExprContext>(0);
		}
		public ITerminalNode ROW_LIMIT_EXPR() { return GetToken(EsperEPL2GrammarParser.ROW_LIMIT_EXPR, 0); }
		public RowLimitContext rowLimit() {
			return GetRuleContext<RowLimitContext>(0);
		}
		public ITerminalNode DELETE() { return GetToken(EsperEPL2GrammarParser.DELETE, 0); }
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public OnSelectExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSelectExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSelectExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSelectExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSelectExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSelectExprContext onSelectExpr() {
		OnSelectExprContext _localctx = new OnSelectExprContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_onSelectExpr);
		 paraphrases.Push("on-select clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 808;
			_la = _input.La(1);
			if (_la==INSERT) {
				{
				State = 806; Match(INSERT);
				State = 807; insertIntoExpr();
				}
			}

			State = 810; Match(SELECT);
			State = 815;
			_la = _input.La(1);
			if (_la==AND_EXPR || _la==DELETE) {
				{
				State = 812;
				_la = _input.La(1);
				if (_la==AND_EXPR) {
					{
					State = 811; Match(AND_EXPR);
					}
				}

				State = 814; _localctx.d = Match(DELETE);
				}
			}

			State = 818;
			_la = _input.La(1);
			if (_la==DISTINCT) {
				{
				State = 817; Match(DISTINCT);
				}
			}

			State = 820; selectionList();
			State = 822;
			_la = _input.La(1);
			if (_la==FROM) {
				{
				State = 821; onExprFrom();
				}
			}

			State = 826;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 824; Match(WHERE);
				State = 825; whereClause();
				}
			}

			State = 831;
			_la = _input.La(1);
			if (_la==GROUP) {
				{
				State = 828; Match(GROUP);
				State = 829; Match(BY);
				State = 830; groupByListExpr();
				}
			}

			State = 835;
			_la = _input.La(1);
			if (_la==HAVING) {
				{
				State = 833; Match(HAVING);
				State = 834; havingClause();
				}
			}

			State = 840;
			_la = _input.La(1);
			if (_la==ORDER) {
				{
				State = 837; Match(ORDER);
				State = 838; Match(BY);
				State = 839; orderByListExpr();
				}
			}

			State = 844;
			_la = _input.La(1);
			if (_la==ROW_LIMIT_EXPR) {
				{
				State = 842; Match(ROW_LIMIT_EXPR);
				State = 843; rowLimit();
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnUpdateExprContext : ParserRuleContext {
		public IToken n;
		public IToken i;
		public ITerminalNode UPDATE() { return GetToken(EsperEPL2GrammarParser.UPDATE, 0); }
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public OnSetAssignmentListContext onSetAssignmentList() {
			return GetRuleContext<OnSetAssignmentListContext>(0);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public OnUpdateExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onUpdateExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnUpdateExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnUpdateExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnUpdateExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnUpdateExprContext onUpdateExpr() {
		OnUpdateExprContext _localctx = new OnUpdateExprContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_onUpdateExpr);
		 paraphrases.Push("on-update clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 846; Match(UPDATE);
			State = 847; _localctx.n = Match(IDENT);
			State = 851;
			switch (_input.La(1)) {
			case AS:
				{
				State = 848; Match(AS);
				State = 849; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 850; _localctx.i = Match(IDENT);
				}
				break;
			case SET:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 853; Match(SET);
			State = 854; onSetAssignmentList();
			State = 857;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 855; Match(WHERE);
				State = 856; whereClause();
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSelectInsertExprContext : ParserRuleContext {
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public InsertIntoExprContext insertIntoExpr() {
			return GetRuleContext<InsertIntoExprContext>(0);
		}
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public OnSelectInsertExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSelectInsertExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSelectInsertExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSelectInsertExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSelectInsertExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSelectInsertExprContext onSelectInsertExpr() {
		OnSelectInsertExprContext _localctx = new OnSelectInsertExprContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_onSelectInsertExpr);
		 paraphrases.Push("on-select-insert clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 859; Match(INSERT);
			State = 860; insertIntoExpr();
			State = 861; Match(SELECT);
			State = 862; selectionList();
			State = 865;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 863; Match(WHERE);
				State = 864; whereClause();
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OutputClauseInsertContext : ParserRuleContext {
		public IToken f;
		public IToken a;
		public ITerminalNode OUTPUT() { return GetToken(EsperEPL2GrammarParser.OUTPUT, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public OutputClauseInsertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outputClauseInsert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOutputClauseInsert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOutputClauseInsert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOutputClauseInsert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OutputClauseInsertContext outputClauseInsert() {
		OutputClauseInsertContext _localctx = new OutputClauseInsertContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_outputClauseInsert);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 867; Match(OUTPUT);
			State = 870;
			switch (_input.La(1)) {
			case FIRST:
				{
				State = 868; _localctx.f = Match(FIRST);
				}
				break;
			case ALL:
				{
				State = 869; _localctx.a = Match(ALL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnDeleteExprContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(EsperEPL2GrammarParser.DELETE, 0); }
		public OnExprFromContext onExprFrom() {
			return GetRuleContext<OnExprFromContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public OnDeleteExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onDeleteExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnDeleteExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnDeleteExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnDeleteExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnDeleteExprContext onDeleteExpr() {
		OnDeleteExprContext _localctx = new OnDeleteExprContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_onDeleteExpr);
		 paraphrases.Push("on-delete clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 872; Match(DELETE);
			State = 873; onExprFrom();
			State = 876;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 874; Match(WHERE);
				State = 875; whereClause();
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSetExprContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public OnSetAssignmentListContext onSetAssignmentList() {
			return GetRuleContext<OnSetAssignmentListContext>(0);
		}
		public OnSetExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSetExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSetExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSetExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSetExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSetExprContext onSetExpr() {
		OnSetExprContext _localctx = new OnSetExprContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_onSetExpr);
		 paraphrases.Push("on-set clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 878; Match(SET);
			State = 879; onSetAssignmentList();
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSetAssignmentListContext : ParserRuleContext {
		public OnSetAssignmentContext[] onSetAssignment() {
			return GetRuleContexts<OnSetAssignmentContext>();
		}
		public OnSetAssignmentContext onSetAssignment(int i) {
			return GetRuleContext<OnSetAssignmentContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public OnSetAssignmentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSetAssignmentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSetAssignmentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSetAssignmentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSetAssignmentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSetAssignmentListContext onSetAssignmentList() {
		OnSetAssignmentListContext _localctx = new OnSetAssignmentListContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_onSetAssignmentList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 881; onSetAssignment();
			State = 886;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 882; Match(COMMA);
				State = 883; onSetAssignment();
				}
				}
				State = 888;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnSetAssignmentContext : ParserRuleContext {
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public OnSetAssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onSetAssignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnSetAssignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnSetAssignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnSetAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnSetAssignmentContext onSetAssignment() {
		OnSetAssignmentContext _localctx = new OnSetAssignmentContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_onSetAssignment);
		try {
			State = 894;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,72,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 889; eventProperty();
				State = 890; Match(EQUALS);
				State = 891; expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 893; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OnExprFromContext : ParserRuleContext {
		public IToken n;
		public IToken i;
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public OnExprFromContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_onExprFrom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOnExprFrom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOnExprFrom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnExprFrom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OnExprFromContext onExprFrom() {
		OnExprFromContext _localctx = new OnExprFromContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_onExprFrom);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 896; Match(FROM);
			State = 897; _localctx.n = Match(IDENT);
			State = 901;
			switch (_input.La(1)) {
			case AS:
				{
				State = 898; Match(AS);
				State = 899; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 900; _localctx.i = Match(IDENT);
				}
				break;
			case Eof:
			case WHERE:
			case GROUP:
			case HAVING:
			case INSERT:
			case ORDER:
			case ROW_LIMIT_EXPR:
			case FOR:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateWindowExprContext : ParserRuleContext {
		public IToken i;
		public IToken ru;
		public IToken ri;
		public IToken i1;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateWindowExprModelAfterContext createWindowExprModelAfter() {
			return GetRuleContext<CreateWindowExprModelAfterContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public CreateColumnListContext createColumnList() {
			return GetRuleContext<CreateColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public ViewExpressionContext[] viewExpression() {
			return GetRuleContexts<ViewExpressionContext>();
		}
		public ViewExpressionContext viewExpression(int i) {
			return GetRuleContext<ViewExpressionContext>(i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode RETAINUNION() { return GetToken(EsperEPL2GrammarParser.RETAINUNION, 0); }
		public ITerminalNode RETAININTERSECTION() { return GetToken(EsperEPL2GrammarParser.RETAININTERSECTION, 0); }
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CreateWindowExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createWindowExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateWindowExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateWindowExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateWindowExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateWindowExprContext createWindowExpr() {
		CreateWindowExprContext _localctx = new CreateWindowExprContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_createWindowExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 903; Match(CREATE);
			State = 904; Match(WINDOW);
			State = 905; _localctx.i = Match(IDENT);
			State = 915;
			_la = _input.La(1);
			if (_la==DOT) {
				{
				State = 906; Match(DOT);
				State = 907; viewExpression();
				State = 912;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==DOT) {
					{
					{
					State = 908; Match(DOT);
					State = 909; viewExpression();
					}
					}
					State = 914;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 919;
			switch (_input.La(1)) {
			case RETAINUNION:
				{
				State = 917; _localctx.ru = Match(RETAINUNION);
				}
				break;
			case RETAININTERSECTION:
				{
				State = 918; _localctx.ri = Match(RETAININTERSECTION);
				}
				break;
			case AS:
			case SELECT:
			case EVENTS:
			case LPAREN:
			case TICKED_STRING_LITERAL:
			case IDENT:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 922;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 921; Match(AS);
				}
			}

			State = 929;
			switch (_input.La(1)) {
			case SELECT:
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 924; createWindowExprModelAfter();
				}
				break;
			case LPAREN:
				{
				State = 925; Match(LPAREN);
				State = 926; createColumnList();
				State = 927; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 936;
			_la = _input.La(1);
			if (_la==INSERT) {
				{
				State = 931; _localctx.i1 = Match(INSERT);
				State = 934;
				_la = _input.La(1);
				if (_la==WHERE) {
					{
					State = 932; Match(WHERE);
					State = 933; expression();
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateWindowExprModelAfterContext : ParserRuleContext {
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public CreateSelectionListContext createSelectionList() {
			return GetRuleContext<CreateSelectionListContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public CreateWindowExprModelAfterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createWindowExprModelAfter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateWindowExprModelAfter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateWindowExprModelAfter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateWindowExprModelAfter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateWindowExprModelAfterContext createWindowExprModelAfter() {
		CreateWindowExprModelAfterContext _localctx = new CreateWindowExprModelAfterContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_createWindowExprModelAfter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 942;
			_la = _input.La(1);
			if (_la==SELECT) {
				{
				State = 938; Match(SELECT);
				State = 939; createSelectionList();
				State = 940; Match(FROM);
				}
			}

			State = 944; classIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexExprContext : ParserRuleContext {
		public IToken u;
		public IToken n;
		public IToken w;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode INDEX() { return GetToken(EsperEPL2GrammarParser.INDEX, 0); }
		public ITerminalNode ON() { return GetToken(EsperEPL2GrammarParser.ON, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public CreateIndexColumnListContext createIndexColumnList() {
			return GetRuleContext<CreateIndexColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public CreateIndexExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndexExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateIndexExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateIndexExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateIndexExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexExprContext createIndexExpr() {
		CreateIndexExprContext _localctx = new CreateIndexExprContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_createIndexExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 946; Match(CREATE);
			State = 948;
			_la = _input.La(1);
			if (_la==IDENT) {
				{
				State = 947; _localctx.u = Match(IDENT);
				}
			}

			State = 950; Match(INDEX);
			State = 951; _localctx.n = Match(IDENT);
			State = 952; Match(ON);
			State = 953; _localctx.w = Match(IDENT);
			State = 954; Match(LPAREN);
			State = 955; createIndexColumnList();
			State = 956; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexColumnListContext : ParserRuleContext {
		public CreateIndexColumnContext[] createIndexColumn() {
			return GetRuleContexts<CreateIndexColumnContext>();
		}
		public CreateIndexColumnContext createIndexColumn(int i) {
			return GetRuleContext<CreateIndexColumnContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateIndexColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndexColumnList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateIndexColumnList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateIndexColumnList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateIndexColumnList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexColumnListContext createIndexColumnList() {
		CreateIndexColumnListContext _localctx = new CreateIndexColumnListContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_createIndexColumnList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 958; createIndexColumn();
			State = 963;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 959; Match(COMMA);
				State = 960; createIndexColumn();
				}
				}
				State = 965;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexColumnContext : ParserRuleContext {
		public IToken c;
		public IToken t;
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public CreateIndexColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndexColumn; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateIndexColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateIndexColumn(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateIndexColumn(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexColumnContext createIndexColumn() {
		CreateIndexColumnContext _localctx = new CreateIndexColumnContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_createIndexColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 966; _localctx.c = Match(IDENT);
			State = 968;
			_la = _input.La(1);
			if (_la==IDENT) {
				{
				State = 967; _localctx.t = Match(IDENT);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateVariableExprContext : ParserRuleContext {
		public IToken c;
		public IToken arr;
		public IToken p;
		public IToken n;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode VARIABLE() { return GetToken(EsperEPL2GrammarParser.VARIABLE, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public CreateVariableExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createVariableExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateVariableExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateVariableExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateVariableExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateVariableExprContext createVariableExpr() {
		CreateVariableExprContext _localctx = new CreateVariableExprContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_createVariableExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 970; Match(CREATE);
			State = 972;
			_la = _input.La(1);
			if (_la==IDENT) {
				{
				State = 971; _localctx.c = Match(IDENT);
				}
			}

			State = 974; Match(VARIABLE);
			State = 975; classIdentifier();
			State = 981;
			_la = _input.La(1);
			if (_la==LBRACK) {
				{
				State = 976; _localctx.arr = Match(LBRACK);
				State = 978;
				_la = _input.La(1);
				if (_la==IDENT) {
					{
					State = 977; _localctx.p = Match(IDENT);
					}
				}

				State = 980; Match(RBRACK);
				}
			}

			State = 983; _localctx.n = Match(IDENT);
			State = 986;
			_la = _input.La(1);
			if (_la==EQUALS) {
				{
				State = 984; Match(EQUALS);
				State = 985; expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableExprContext : ParserRuleContext {
		public IToken n;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode TABLE() { return GetToken(EsperEPL2GrammarParser.TABLE, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public CreateTableColumnListContext createTableColumnList() {
			return GetRuleContext<CreateTableColumnListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateTableExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateTableExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateTableExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTableExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableExprContext createTableExpr() {
		CreateTableExprContext _localctx = new CreateTableExprContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_createTableExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 988; Match(CREATE);
			State = 989; Match(TABLE);
			State = 990; _localctx.n = Match(IDENT);
			State = 992;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 991; Match(AS);
				}
			}

			State = 994; Match(LPAREN);
			State = 995; createTableColumnList();
			State = 996; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableColumnListContext : ParserRuleContext {
		public CreateTableColumnContext[] createTableColumn() {
			return GetRuleContexts<CreateTableColumnContext>();
		}
		public CreateTableColumnContext createTableColumn(int i) {
			return GetRuleContext<CreateTableColumnContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateTableColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableColumnList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateTableColumnList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateTableColumnList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTableColumnList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableColumnListContext createTableColumnList() {
		CreateTableColumnListContext _localctx = new CreateTableColumnListContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_createTableColumnList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 998; createTableColumn();
			State = 1003;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 999; Match(COMMA);
				State = 1000; createTableColumn();
				}
				}
				State = 1005;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableColumnContext : ParserRuleContext {
		public IToken n;
		public IToken p;
		public IToken k;
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public CreateTableColumnPlainContext createTableColumnPlain() {
			return GetRuleContext<CreateTableColumnPlainContext>(0);
		}
		public BuiltinFuncContext builtinFunc() {
			return GetRuleContext<BuiltinFuncContext>(0);
		}
		public LibFunctionContext libFunction() {
			return GetRuleContext<LibFunctionContext>(0);
		}
		public PropertyExpressionAnnotationContext[] propertyExpressionAnnotation() {
			return GetRuleContexts<PropertyExpressionAnnotationContext>();
		}
		public PropertyExpressionAnnotationContext propertyExpressionAnnotation(int i) {
			return GetRuleContext<PropertyExpressionAnnotationContext>(i);
		}
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public CreateTableColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableColumn; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateTableColumn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateTableColumn(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTableColumn(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableColumnContext createTableColumn() {
		CreateTableColumnContext _localctx = new CreateTableColumnContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_createTableColumn);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1006; _localctx.n = Match(IDENT);
			State = 1010;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,91,_ctx) ) {
			case 1:
				{
				State = 1007; createTableColumnPlain();
				}
				break;

			case 2:
				{
				State = 1008; builtinFunc();
				}
				break;

			case 3:
				{
				State = 1009; libFunction();
				}
				break;
			}
			State = 1013;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,92,_ctx) ) {
			case 1:
				{
				State = 1012; _localctx.p = Match(IDENT);
				}
				break;
			}
			State = 1016;
			_la = _input.La(1);
			if (_la==IDENT) {
				{
				State = 1015; _localctx.k = Match(IDENT);
				}
			}

			State = 1022;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ATCHAR) {
				{
				State = 1020;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,94,_ctx) ) {
				case 1:
					{
					State = 1018; propertyExpressionAnnotation();
					}
					break;

				case 2:
					{
					State = 1019; annotationEnum();
					}
					break;
				}
				}
				State = 1024;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateTableColumnPlainContext : ParserRuleContext {
		public IToken b;
		public IToken p;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateTableColumnPlainContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createTableColumnPlain; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateTableColumnPlain(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateTableColumnPlain(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateTableColumnPlain(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateTableColumnPlainContext createTableColumnPlain() {
		CreateTableColumnPlainContext _localctx = new CreateTableColumnPlainContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_createTableColumnPlain);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1025; classIdentifier();
			State = 1031;
			_la = _input.La(1);
			if (_la==LBRACK) {
				{
				State = 1026; _localctx.b = Match(LBRACK);
				State = 1028;
				_la = _input.La(1);
				if (_la==IDENT) {
					{
					State = 1027; _localctx.p = Match(IDENT);
					}
				}

				State = 1030; Match(RBRACK);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateColumnListContext : ParserRuleContext {
		public CreateColumnListElementContext[] createColumnListElement() {
			return GetRuleContexts<CreateColumnListElementContext>();
		}
		public CreateColumnListElementContext createColumnListElement(int i) {
			return GetRuleContext<CreateColumnListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createColumnList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateColumnList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateColumnList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateColumnList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateColumnListContext createColumnList() {
		CreateColumnListContext _localctx = new CreateColumnListContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_createColumnList);
		 paraphrases.Push("column list"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1033; createColumnListElement();
			State = 1038;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1034; Match(COMMA);
				State = 1035; createColumnListElement();
				}
				}
				State = 1040;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateColumnListElementContext : ParserRuleContext {
		public IToken b;
		public IToken p;
		public ClassIdentifierContext[] classIdentifier() {
			return GetRuleContexts<ClassIdentifierContext>();
		}
		public ClassIdentifierContext classIdentifier(int i) {
			return GetRuleContext<ClassIdentifierContext>(i);
		}
		public ITerminalNode VALUE_NULL() { return GetToken(EsperEPL2GrammarParser.VALUE_NULL, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateColumnListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createColumnListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateColumnListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateColumnListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateColumnListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateColumnListElementContext createColumnListElement() {
		CreateColumnListElementContext _localctx = new CreateColumnListElementContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_createColumnListElement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1041; classIdentifier();
			State = 1051;
			switch (_input.La(1)) {
			case VALUE_NULL:
				{
				State = 1042; Match(VALUE_NULL);
				}
				break;
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				{
				State = 1043; classIdentifier();
				State = 1049;
				_la = _input.La(1);
				if (_la==LBRACK) {
					{
					State = 1044; _localctx.b = Match(LBRACK);
					State = 1046;
					_la = _input.La(1);
					if (_la==IDENT) {
						{
						State = 1045; _localctx.p = Match(IDENT);
						}
					}

					State = 1048; Match(RBRACK);
					}
				}

				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSelectionListContext : ParserRuleContext {
		public CreateSelectionListElementContext[] createSelectionListElement() {
			return GetRuleContexts<CreateSelectionListElementContext>();
		}
		public CreateSelectionListElementContext createSelectionListElement(int i) {
			return GetRuleContext<CreateSelectionListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateSelectionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSelectionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSelectionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSelectionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSelectionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSelectionListContext createSelectionList() {
		CreateSelectionListContext _localctx = new CreateSelectionListContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_createSelectionList);
		 paraphrases.Push("select clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1053; createSelectionListElement();
			State = 1058;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1054; Match(COMMA);
				State = 1055; createSelectionListElement();
				}
				}
				State = 1060;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSelectionListElementContext : ParserRuleContext {
		public IToken s;
		public IToken i;
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public CreateSelectionListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSelectionListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSelectionListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSelectionListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSelectionListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSelectionListElementContext createSelectionListElement() {
		CreateSelectionListElementContext _localctx = new CreateSelectionListElementContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_createSelectionListElement);
		int _la;
		try {
			State = 1071;
			switch (_input.La(1)) {
			case STAR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1061; _localctx.s = Match(STAR);
				}
				break;
			case WINDOW:
			case ESCAPE:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PRIOR:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case CONTEXT:
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1062; eventProperty();
				State = 1065;
				_la = _input.La(1);
				if (_la==AS) {
					{
					State = 1063; Match(AS);
					State = 1064; _localctx.i = Match(IDENT);
					}
				}

				}
				break;
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case PLUS:
			case MINUS:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1067; constant();
				State = 1068; Match(AS);
				State = 1069; _localctx.i = Match(IDENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSchemaExprContext : ParserRuleContext {
		public IToken keyword;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public CreateSchemaDefContext createSchemaDef() {
			return GetRuleContext<CreateSchemaDefContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateSchemaExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSchemaExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSchemaExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSchemaExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSchemaExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSchemaExprContext createSchemaExpr() {
		CreateSchemaExprContext _localctx = new CreateSchemaExprContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_createSchemaExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1073; Match(CREATE);
			State = 1075;
			_la = _input.La(1);
			if (_la==IDENT) {
				{
				State = 1074; _localctx.keyword = Match(IDENT);
				}
			}

			State = 1077; createSchemaDef();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSchemaDefContext : ParserRuleContext {
		public IToken name;
		public ITerminalNode SCHEMA() { return GetToken(EsperEPL2GrammarParser.SCHEMA, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public VariantListContext variantList() {
			return GetRuleContext<VariantListContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateSchemaQualContext[] createSchemaQual() {
			return GetRuleContexts<CreateSchemaQualContext>();
		}
		public CreateSchemaQualContext createSchemaQual(int i) {
			return GetRuleContext<CreateSchemaQualContext>(i);
		}
		public CreateColumnListContext createColumnList() {
			return GetRuleContext<CreateColumnListContext>(0);
		}
		public CreateSchemaDefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSchemaDef; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSchemaDef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSchemaDef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSchemaDef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSchemaDefContext createSchemaDef() {
		CreateSchemaDefContext _localctx = new CreateSchemaDefContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_createSchemaDef);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1079; Match(SCHEMA);
			State = 1080; _localctx.name = Match(IDENT);
			State = 1082;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 1081; Match(AS);
				}
			}

			State = 1090;
			switch (_input.La(1)) {
			case EVENTS:
			case STAR:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 1084; variantList();
				}
				break;
			case LPAREN:
				{
				State = 1085; Match(LPAREN);
				State = 1087;
				_la = _input.La(1);
				if (_la==EVENTS || _la==TICKED_STRING_LITERAL || _la==IDENT) {
					{
					State = 1086; createColumnList();
					}
				}

				State = 1089; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1095;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==IDENT) {
				{
				{
				State = 1092; createSchemaQual();
				}
				}
				State = 1097;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FafDeleteContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode DELETE() { return GetToken(EsperEPL2GrammarParser.DELETE, 0); }
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public FafDeleteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fafDelete; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFafDelete(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFafDelete(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFafDelete(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FafDeleteContext fafDelete() {
		FafDeleteContext _localctx = new FafDeleteContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_fafDelete);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1098; Match(DELETE);
			State = 1099; Match(FROM);
			State = 1100; classIdentifier();
			State = 1104;
			switch (_input.La(1)) {
			case AS:
				{
				State = 1101; Match(AS);
				State = 1102; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 1103; _localctx.i = Match(IDENT);
				}
				break;
			case Eof:
			case WHERE:
			case FOR:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1108;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 1106; Match(WHERE);
				State = 1107; whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FafUpdateContext : ParserRuleContext {
		public ITerminalNode UPDATE() { return GetToken(EsperEPL2GrammarParser.UPDATE, 0); }
		public UpdateDetailsContext updateDetails() {
			return GetRuleContext<UpdateDetailsContext>(0);
		}
		public FafUpdateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fafUpdate; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFafUpdate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFafUpdate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFafUpdate(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FafUpdateContext fafUpdate() {
		FafUpdateContext _localctx = new FafUpdateContext(_ctx, State);
		EnterRule(_localctx, 106, RULE_fafUpdate);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1110; Match(UPDATE);
			State = 1111; updateDetails();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FafInsertContext : ParserRuleContext {
		public ITerminalNode INSERT() { return GetToken(EsperEPL2GrammarParser.INSERT, 0); }
		public InsertIntoExprContext insertIntoExpr() {
			return GetRuleContext<InsertIntoExprContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(EsperEPL2GrammarParser.VALUES, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public FafInsertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fafInsert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFafInsert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFafInsert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFafInsert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FafInsertContext fafInsert() {
		FafInsertContext _localctx = new FafInsertContext(_ctx, State);
		EnterRule(_localctx, 108, RULE_fafInsert);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1113; Match(INSERT);
			State = 1114; insertIntoExpr();
			State = 1115; Match(VALUES);
			State = 1116; Match(LPAREN);
			State = 1117; expressionList();
			State = 1118; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDataflowContext : ParserRuleContext {
		public IToken name;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode DATAFLOW() { return GetToken(EsperEPL2GrammarParser.DATAFLOW, 0); }
		public GopListContext gopList() {
			return GetRuleContext<GopListContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateDataflowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDataflow; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateDataflow(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateDataflow(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateDataflow(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateDataflowContext createDataflow() {
		CreateDataflowContext _localctx = new CreateDataflowContext(_ctx, State);
		EnterRule(_localctx, 110, RULE_createDataflow);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1120; Match(CREATE);
			State = 1121; Match(DATAFLOW);
			State = 1122; _localctx.name = Match(IDENT);
			State = 1124;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 1123; Match(AS);
				}
			}

			State = 1126; gopList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopListContext : ParserRuleContext {
		public GopContext[] gop() {
			return GetRuleContexts<GopContext>();
		}
		public GopContext gop(int i) {
			return GetRuleContext<GopContext>(i);
		}
		public GopListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopListContext gopList() {
		GopListContext _localctx = new GopListContext(_ctx, State);
		EnterRule(_localctx, 112, RULE_gopList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1128; gop();
			State = 1132;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==CREATE || _la==SELECT || _la==ATCHAR || _la==IDENT) {
				{
				{
				State = 1129; gop();
				}
				}
				State = 1134;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopContext : ParserRuleContext {
		public IToken opName;
		public IToken s;
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public GopParamsContext gopParams() {
			return GetRuleContext<GopParamsContext>(0);
		}
		public GopOutContext gopOut() {
			return GetRuleContext<GopOutContext>(0);
		}
		public GopDetailContext gopDetail() {
			return GetRuleContext<GopDetailContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public CreateSchemaExprContext createSchemaExpr() {
			return GetRuleContext<CreateSchemaExprContext>(0);
		}
		public GopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopContext gop() {
		GopContext _localctx = new GopContext(_ctx, State);
		EnterRule(_localctx, 114, RULE_gop);
		int _la;
		try {
			State = 1162;
			switch (_input.La(1)) {
			case SELECT:
			case ATCHAR:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1138;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==ATCHAR) {
					{
					{
					State = 1135; annotationEnum();
					}
					}
					State = 1140;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1143;
				switch (_input.La(1)) {
				case IDENT:
					{
					State = 1141; _localctx.opName = Match(IDENT);
					}
					break;
				case SELECT:
					{
					State = 1142; _localctx.s = Match(SELECT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1146;
				_la = _input.La(1);
				if (_la==LPAREN) {
					{
					State = 1145; gopParams();
					}
				}

				State = 1149;
				_la = _input.La(1);
				if (_la==FOLLOWED_BY) {
					{
					State = 1148; gopOut();
					}
				}

				State = 1151; Match(LCURLY);
				State = 1153;
				_la = _input.La(1);
				if (_la==SELECT || _la==IDENT) {
					{
					State = 1152; gopDetail();
					}
				}

				State = 1156;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 1155; Match(COMMA);
					}
				}

				State = 1158; Match(RCURLY);
				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1159; createSchemaExpr();
				State = 1160; Match(COMMA);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public GopParamsItemListContext gopParamsItemList() {
			return GetRuleContext<GopParamsItemListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public GopParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParams; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParams(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParams(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParams(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsContext gopParams() {
		GopParamsContext _localctx = new GopParamsContext(_ctx, State);
		EnterRule(_localctx, 116, RULE_gopParams);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1164; Match(LPAREN);
			State = 1165; gopParamsItemList();
			State = 1166; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsItemListContext : ParserRuleContext {
		public GopParamsItemContext[] gopParamsItem() {
			return GetRuleContexts<GopParamsItemContext>();
		}
		public GopParamsItemContext gopParamsItem(int i) {
			return GetRuleContext<GopParamsItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GopParamsItemListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParamsItemList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParamsItemList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParamsItemList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParamsItemList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsItemListContext gopParamsItemList() {
		GopParamsItemListContext _localctx = new GopParamsItemListContext(_ctx, State);
		EnterRule(_localctx, 118, RULE_gopParamsItemList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1168; gopParamsItem();
			State = 1173;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1169; Match(COMMA);
				State = 1170; gopParamsItem();
				}
				}
				State = 1175;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsItemContext : ParserRuleContext {
		public ClassIdentifierContext n;
		public GopParamsItemManyContext gopParamsItemMany() {
			return GetRuleContext<GopParamsItemManyContext>(0);
		}
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public GopParamsItemAsContext gopParamsItemAs() {
			return GetRuleContext<GopParamsItemAsContext>(0);
		}
		public GopParamsItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParamsItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParamsItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParamsItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParamsItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsItemContext gopParamsItem() {
		GopParamsItemContext _localctx = new GopParamsItemContext(_ctx, State);
		EnterRule(_localctx, 120, RULE_gopParamsItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1178;
			switch (_input.La(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 1176; _localctx.n = classIdentifier();
				}
				break;
			case LPAREN:
				{
				State = 1177; gopParamsItemMany();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1181;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 1180; gopParamsItemAs();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsItemManyContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ClassIdentifierContext[] classIdentifier() {
			return GetRuleContexts<ClassIdentifierContext>();
		}
		public ClassIdentifierContext classIdentifier(int i) {
			return GetRuleContext<ClassIdentifierContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public GopParamsItemManyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParamsItemMany; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParamsItemMany(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParamsItemMany(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParamsItemMany(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsItemManyContext gopParamsItemMany() {
		GopParamsItemManyContext _localctx = new GopParamsItemManyContext(_ctx, State);
		EnterRule(_localctx, 122, RULE_gopParamsItemMany);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1183; Match(LPAREN);
			State = 1184; classIdentifier();
			{
			State = 1185; Match(COMMA);
			State = 1186; classIdentifier();
			}
			State = 1188; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopParamsItemAsContext : ParserRuleContext {
		public IToken a;
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public GopParamsItemAsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopParamsItemAs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopParamsItemAs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopParamsItemAs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopParamsItemAs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopParamsItemAsContext gopParamsItemAs() {
		GopParamsItemAsContext _localctx = new GopParamsItemAsContext(_ctx, State);
		EnterRule(_localctx, 124, RULE_gopParamsItemAs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1190; Match(AS);
			State = 1191; _localctx.a = Match(IDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutContext : ParserRuleContext {
		public ITerminalNode FOLLOWED_BY() { return GetToken(EsperEPL2GrammarParser.FOLLOWED_BY, 0); }
		public GopOutItemContext[] gopOutItem() {
			return GetRuleContexts<GopOutItemContext>();
		}
		public GopOutItemContext gopOutItem(int i) {
			return GetRuleContext<GopOutItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GopOutContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOut; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOut(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOut(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOut(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutContext gopOut() {
		GopOutContext _localctx = new GopOutContext(_ctx, State);
		EnterRule(_localctx, 126, RULE_gopOut);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1193; Match(FOLLOWED_BY);
			State = 1194; gopOutItem();
			State = 1199;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1195; Match(COMMA);
				State = 1196; gopOutItem();
				}
				}
				State = 1201;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutItemContext : ParserRuleContext {
		public ClassIdentifierContext n;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public GopOutTypeListContext gopOutTypeList() {
			return GetRuleContext<GopOutTypeListContext>(0);
		}
		public GopOutItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOutItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOutItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOutItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOutItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutItemContext gopOutItem() {
		GopOutItemContext _localctx = new GopOutItemContext(_ctx, State);
		EnterRule(_localctx, 128, RULE_gopOutItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1202; _localctx.n = classIdentifier();
			State = 1204;
			_la = _input.La(1);
			if (_la==LT) {
				{
				State = 1203; gopOutTypeList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutTypeListContext : ParserRuleContext {
		public ITerminalNode LT() { return GetToken(EsperEPL2GrammarParser.LT, 0); }
		public GopOutTypeParamContext[] gopOutTypeParam() {
			return GetRuleContexts<GopOutTypeParamContext>();
		}
		public GopOutTypeParamContext gopOutTypeParam(int i) {
			return GetRuleContext<GopOutTypeParamContext>(i);
		}
		public ITerminalNode GT() { return GetToken(EsperEPL2GrammarParser.GT, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GopOutTypeListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOutTypeList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOutTypeList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOutTypeList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOutTypeList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutTypeListContext gopOutTypeList() {
		GopOutTypeListContext _localctx = new GopOutTypeListContext(_ctx, State);
		EnterRule(_localctx, 130, RULE_gopOutTypeList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1206; Match(LT);
			State = 1207; gopOutTypeParam();
			State = 1212;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1208; Match(COMMA);
				State = 1209; gopOutTypeParam();
				}
				}
				State = 1214;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1215; Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutTypeParamContext : ParserRuleContext {
		public IToken q;
		public GopOutTypeItemContext gopOutTypeItem() {
			return GetRuleContext<GopOutTypeItemContext>(0);
		}
		public ITerminalNode QUESTION() { return GetToken(EsperEPL2GrammarParser.QUESTION, 0); }
		public GopOutTypeParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOutTypeParam; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOutTypeParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOutTypeParam(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOutTypeParam(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutTypeParamContext gopOutTypeParam() {
		GopOutTypeParamContext _localctx = new GopOutTypeParamContext(_ctx, State);
		EnterRule(_localctx, 132, RULE_gopOutTypeParam);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1219;
			switch (_input.La(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 1217; gopOutTypeItem();
				}
				break;
			case QUESTION:
				{
				State = 1218; _localctx.q = Match(QUESTION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopOutTypeItemContext : ParserRuleContext {
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public GopOutTypeListContext gopOutTypeList() {
			return GetRuleContext<GopOutTypeListContext>(0);
		}
		public GopOutTypeItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopOutTypeItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopOutTypeItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopOutTypeItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopOutTypeItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopOutTypeItemContext gopOutTypeItem() {
		GopOutTypeItemContext _localctx = new GopOutTypeItemContext(_ctx, State);
		EnterRule(_localctx, 134, RULE_gopOutTypeItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1221; classIdentifier();
			State = 1223;
			_la = _input.La(1);
			if (_la==LT) {
				{
				State = 1222; gopOutTypeList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopDetailContext : ParserRuleContext {
		public GopConfigContext[] gopConfig() {
			return GetRuleContexts<GopConfigContext>();
		}
		public GopConfigContext gopConfig(int i) {
			return GetRuleContext<GopConfigContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GopDetailContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopDetail; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopDetail(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopDetail(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopDetail(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopDetailContext gopDetail() {
		GopDetailContext _localctx = new GopDetailContext(_ctx, State);
		EnterRule(_localctx, 136, RULE_gopDetail);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1225; gopConfig();
			State = 1230;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,129,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1226; Match(COMMA);
					State = 1227; gopConfig();
					}
					} 
				}
				State = 1232;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,129,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GopConfigContext : ParserRuleContext {
		public IToken n;
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public SelectExprContext selectExpr() {
			return GetRuleContext<SelectExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public JsonobjectContext jsonobject() {
			return GetRuleContext<JsonobjectContext>(0);
		}
		public JsonarrayContext jsonarray() {
			return GetRuleContext<JsonarrayContext>(0);
		}
		public GopConfigContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gopConfig; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGopConfig(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGopConfig(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGopConfig(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GopConfigContext gopConfig() {
		GopConfigContext _localctx = new GopConfigContext(_ctx, State);
		EnterRule(_localctx, 138, RULE_gopConfig);
		int _la;
		try {
			State = 1246;
			switch (_input.La(1)) {
			case SELECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1233; Match(SELECT);
				State = 1234;
				_la = _input.La(1);
				if ( !(_la==EQUALS || _la==COLON) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 1235; Match(LPAREN);
				State = 1236; selectExpr();
				State = 1237; Match(RPAREN);
				}
				break;
			case IDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1239; _localctx.n = Match(IDENT);
				State = 1240;
				_la = _input.La(1);
				if ( !(_la==EQUALS || _la==COLON) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 1244;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,130,_ctx) ) {
				case 1:
					{
					State = 1241; expression();
					}
					break;

				case 2:
					{
					State = 1242; jsonobject();
					}
					break;

				case 3:
					{
					State = 1243; jsonarray();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextExprContext : ParserRuleContext {
		public IToken name;
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ITerminalNode CONTEXT() { return GetToken(EsperEPL2GrammarParser.CONTEXT, 0); }
		public CreateContextDetailContext createContextDetail() {
			return GetRuleContext<CreateContextDetailContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateContextExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextExprContext createContextExpr() {
		CreateContextExprContext _localctx = new CreateContextExprContext(_ctx, State);
		EnterRule(_localctx, 140, RULE_createContextExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1248; Match(CREATE);
			State = 1249; Match(CONTEXT);
			State = 1250; _localctx.name = Match(IDENT);
			State = 1252;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 1251; Match(AS);
				}
			}

			State = 1254; createContextDetail();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateExpressionExprContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(EsperEPL2GrammarParser.CREATE, 0); }
		public ExpressionDeclContext expressionDecl() {
			return GetRuleContext<ExpressionDeclContext>(0);
		}
		public CreateExpressionExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createExpressionExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateExpressionExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateExpressionExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateExpressionExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateExpressionExprContext createExpressionExpr() {
		CreateExpressionExprContext _localctx = new CreateExpressionExprContext(_ctx, State);
		EnterRule(_localctx, 142, RULE_createExpressionExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1256; Match(CREATE);
			State = 1257; expressionDecl();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextDetailContext : ParserRuleContext {
		public CreateContextChoiceContext createContextChoice() {
			return GetRuleContext<CreateContextChoiceContext>(0);
		}
		public ContextContextNestedContext[] contextContextNested() {
			return GetRuleContexts<ContextContextNestedContext>();
		}
		public ContextContextNestedContext contextContextNested(int i) {
			return GetRuleContext<ContextContextNestedContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateContextDetailContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextDetail; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextDetail(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextDetail(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextDetail(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextDetailContext createContextDetail() {
		CreateContextDetailContext _localctx = new CreateContextDetailContext(_ctx, State);
		EnterRule(_localctx, 144, RULE_createContextDetail);
		int _la;
		try {
			State = 1270;
			switch (_input.La(1)) {
			case COALESCE:
			case GROUP:
			case PARTITION:
			case START:
			case INITIATED:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1259; createContextChoice();
				}
				break;
			case CONTEXT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1260; contextContextNested();
				State = 1261; Match(COMMA);
				State = 1262; contextContextNested();
				State = 1267;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1263; Match(COMMA);
					State = 1264; contextContextNested();
					}
					}
					State = 1269;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ContextContextNestedContext : ParserRuleContext {
		public IToken name;
		public ITerminalNode CONTEXT() { return GetToken(EsperEPL2GrammarParser.CONTEXT, 0); }
		public CreateContextChoiceContext createContextChoice() {
			return GetRuleContext<CreateContextChoiceContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ContextContextNestedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_contextContextNested; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterContextContextNested(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitContextContextNested(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContextContextNested(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ContextContextNestedContext contextContextNested() {
		ContextContextNestedContext _localctx = new ContextContextNestedContext(_ctx, State);
		EnterRule(_localctx, 146, RULE_contextContextNested);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1272; Match(CONTEXT);
			State = 1273; _localctx.name = Match(IDENT);
			State = 1275;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 1274; Match(AS);
				}
			}

			State = 1277; createContextChoice();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextChoiceContext : ParserRuleContext {
		public IToken i;
		public CreateContextRangePointContext r1;
		public CreateContextRangePointContext r2;
		public IToken g;
		public IToken p;
		public ITerminalNode START() { return GetToken(EsperEPL2GrammarParser.START, 0); }
		public ITerminalNode END() { return GetToken(EsperEPL2GrammarParser.END, 0); }
		public CreateContextRangePointContext[] createContextRangePoint() {
			return GetRuleContexts<CreateContextRangePointContext>();
		}
		public CreateContextRangePointContext createContextRangePoint(int i) {
			return GetRuleContext<CreateContextRangePointContext>(i);
		}
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode INITIATED() { return GetToken(EsperEPL2GrammarParser.INITIATED, 0); }
		public ITerminalNode TERMINATED() { return GetToken(EsperEPL2GrammarParser.TERMINATED, 0); }
		public ITerminalNode[] BY() { return GetTokens(EsperEPL2GrammarParser.BY); }
		public ITerminalNode BY(int i) {
			return GetToken(EsperEPL2GrammarParser.BY, i);
		}
		public CreateContextDistinctContext createContextDistinct() {
			return GetRuleContext<CreateContextDistinctContext>(0);
		}
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public ITerminalNode PARTITION() { return GetToken(EsperEPL2GrammarParser.PARTITION, 0); }
		public CreateContextPartitionItemContext[] createContextPartitionItem() {
			return GetRuleContexts<CreateContextPartitionItemContext>();
		}
		public CreateContextPartitionItemContext createContextPartitionItem(int i) {
			return GetRuleContext<CreateContextPartitionItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateContextGroupItemContext[] createContextGroupItem() {
			return GetRuleContexts<CreateContextGroupItemContext>();
		}
		public CreateContextGroupItemContext createContextGroupItem(int i) {
			return GetRuleContext<CreateContextGroupItemContext>(i);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public ITerminalNode COALESCE() { return GetToken(EsperEPL2GrammarParser.COALESCE, 0); }
		public CreateContextCoalesceItemContext[] createContextCoalesceItem() {
			return GetRuleContexts<CreateContextCoalesceItemContext>();
		}
		public CreateContextCoalesceItemContext createContextCoalesceItem(int i) {
			return GetRuleContext<CreateContextCoalesceItemContext>(i);
		}
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public CreateContextChoiceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextChoice; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextChoice(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextChoice(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextChoice(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextChoiceContext createContextChoice() {
		CreateContextChoiceContext _localctx = new CreateContextChoiceContext(_ctx, State);
		EnterRule(_localctx, 148, RULE_createContextChoice);
		int _la;
		try {
			int _alt;
			State = 1346;
			switch (_input.La(1)) {
			case START:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1279; Match(START);
				State = 1283;
				switch (_input.La(1)) {
				case ATCHAR:
					{
					State = 1280; Match(ATCHAR);
					State = 1281; _localctx.i = Match(IDENT);
					}
					break;
				case EVENTS:
				case PATTERN:
				case AFTER:
				case LPAREN:
				case TICKED_STRING_LITERAL:
				case IDENT:
					{
					State = 1282; _localctx.r1 = createContextRangePoint();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1285; Match(END);
				State = 1286; _localctx.r2 = createContextRangePoint();
				}
				break;
			case INITIATED:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1287; Match(INITIATED);
				State = 1289;
				_la = _input.La(1);
				if (_la==BY) {
					{
					State = 1288; Match(BY);
					}
				}

				State = 1292;
				_la = _input.La(1);
				if (_la==DISTINCT) {
					{
					State = 1291; createContextDistinct();
					}
				}

				State = 1297;
				_la = _input.La(1);
				if (_la==ATCHAR) {
					{
					State = 1294; Match(ATCHAR);
					State = 1295; _localctx.i = Match(IDENT);
					State = 1296; Match(AND_EXPR);
					}
				}

				State = 1299; _localctx.r1 = createContextRangePoint();
				State = 1300; Match(TERMINATED);
				State = 1302;
				_la = _input.La(1);
				if (_la==BY) {
					{
					State = 1301; Match(BY);
					}
				}

				State = 1304; _localctx.r2 = createContextRangePoint();
				}
				break;
			case PARTITION:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1306; Match(PARTITION);
				State = 1308;
				_la = _input.La(1);
				if (_la==BY) {
					{
					State = 1307; Match(BY);
					}
				}

				State = 1310; createContextPartitionItem();
				State = 1315;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,142,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 1311; Match(COMMA);
						State = 1312; createContextPartitionItem();
						}
						} 
					}
					State = 1317;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,142,_ctx);
				}
				}
				break;
			case GROUP:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1318; createContextGroupItem();
				State = 1323;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1319; Match(COMMA);
					State = 1320; createContextGroupItem();
					}
					}
					State = 1325;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1326; Match(FROM);
				State = 1327; eventFilterExpression();
				}
				break;
			case COALESCE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1329; Match(COALESCE);
				State = 1331;
				_la = _input.La(1);
				if (_la==BY) {
					{
					State = 1330; Match(BY);
					}
				}

				State = 1333; createContextCoalesceItem();
				State = 1338;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1334; Match(COMMA);
					State = 1335; createContextCoalesceItem();
					}
					}
					State = 1340;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1341; _localctx.g = Match(IDENT);
				State = 1342; number();
				State = 1344;
				_la = _input.La(1);
				if (_la==IDENT) {
					{
					State = 1343; _localctx.p = Match(IDENT);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextDistinctContext : ParserRuleContext {
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public CreateContextDistinctContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextDistinct; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextDistinct(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextDistinct(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextDistinct(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextDistinctContext createContextDistinct() {
		CreateContextDistinctContext _localctx = new CreateContextDistinctContext(_ctx, State);
		EnterRule(_localctx, 150, RULE_createContextDistinct);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1348; Match(DISTINCT);
			State = 1349; Match(LPAREN);
			State = 1351;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
				{
				State = 1350; expressionList();
				}
			}

			State = 1353; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextRangePointContext : ParserRuleContext {
		public IToken i;
		public CreateContextFilterContext createContextFilter() {
			return GetRuleContext<CreateContextFilterContext>(0);
		}
		public PatternInclusionExpressionContext patternInclusionExpression() {
			return GetRuleContext<PatternInclusionExpressionContext>(0);
		}
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CrontabLimitParameterSetContext crontabLimitParameterSet() {
			return GetRuleContext<CrontabLimitParameterSetContext>(0);
		}
		public ITerminalNode AFTER() { return GetToken(EsperEPL2GrammarParser.AFTER, 0); }
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public CreateContextRangePointContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextRangePoint; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextRangePoint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextRangePoint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextRangePoint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextRangePointContext createContextRangePoint() {
		CreateContextRangePointContext _localctx = new CreateContextRangePointContext(_ctx, State);
		EnterRule(_localctx, 152, RULE_createContextRangePoint);
		int _la;
		try {
			State = 1364;
			switch (_input.La(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1355; createContextFilter();
				}
				break;
			case PATTERN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1356; patternInclusionExpression();
				State = 1359;
				_la = _input.La(1);
				if (_la==ATCHAR) {
					{
					State = 1357; Match(ATCHAR);
					State = 1358; _localctx.i = Match(IDENT);
					}
				}

				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1361; crontabLimitParameterSet();
				}
				break;
			case AFTER:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1362; Match(AFTER);
				State = 1363; timePeriod();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextFilterContext : ParserRuleContext {
		public IToken i;
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public CreateContextFilterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextFilter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextFilter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextFilter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextFilter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextFilterContext createContextFilter() {
		CreateContextFilterContext _localctx = new CreateContextFilterContext(_ctx, State);
		EnterRule(_localctx, 154, RULE_createContextFilter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1366; eventFilterExpression();
			State = 1371;
			_la = _input.La(1);
			if (_la==AS || _la==IDENT) {
				{
				State = 1368;
				_la = _input.La(1);
				if (_la==AS) {
					{
					State = 1367; Match(AS);
					}
				}

				State = 1370; _localctx.i = Match(IDENT);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextPartitionItemContext : ParserRuleContext {
		public EventPropertyContext[] eventProperty() {
			return GetRuleContexts<EventPropertyContext>();
		}
		public EventPropertyContext eventProperty(int i) {
			return GetRuleContext<EventPropertyContext>(i);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public CreateContextPartitionItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextPartitionItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextPartitionItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextPartitionItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextPartitionItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextPartitionItemContext createContextPartitionItem() {
		CreateContextPartitionItemContext _localctx = new CreateContextPartitionItemContext(_ctx, State);
		EnterRule(_localctx, 156, RULE_createContextPartitionItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1373; eventProperty();
			State = 1378;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==AND_EXPR || _la==COMMA) {
				{
				{
				State = 1374;
				_la = _input.La(1);
				if ( !(_la==AND_EXPR || _la==COMMA) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 1375; eventProperty();
				}
				}
				State = 1380;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1381; Match(FROM);
			State = 1382; eventFilterExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextCoalesceItemContext : ParserRuleContext {
		public LibFunctionNoClassContext libFunctionNoClass() {
			return GetRuleContext<LibFunctionNoClassContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public CreateContextCoalesceItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextCoalesceItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextCoalesceItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextCoalesceItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextCoalesceItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextCoalesceItemContext createContextCoalesceItem() {
		CreateContextCoalesceItemContext _localctx = new CreateContextCoalesceItemContext(_ctx, State);
		EnterRule(_localctx, 158, RULE_createContextCoalesceItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1384; libFunctionNoClass();
			State = 1385; Match(FROM);
			State = 1386; eventFilterExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateContextGroupItemContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode GROUP() { return GetToken(EsperEPL2GrammarParser.GROUP, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode BY() { return GetToken(EsperEPL2GrammarParser.BY, 0); }
		public CreateContextGroupItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createContextGroupItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateContextGroupItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateContextGroupItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateContextGroupItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateContextGroupItemContext createContextGroupItem() {
		CreateContextGroupItemContext _localctx = new CreateContextGroupItemContext(_ctx, State);
		EnterRule(_localctx, 160, RULE_createContextGroupItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1388; Match(GROUP);
			State = 1390;
			_la = _input.La(1);
			if (_la==BY) {
				{
				State = 1389; Match(BY);
				}
			}

			State = 1392; expression();
			State = 1393; Match(AS);
			State = 1394; _localctx.i = Match(IDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateSchemaQualContext : ParserRuleContext {
		public IToken i;
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public CreateSchemaQualContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createSchemaQual; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCreateSchemaQual(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCreateSchemaQual(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSchemaQual(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateSchemaQualContext createSchemaQual() {
		CreateSchemaQualContext _localctx = new CreateSchemaQualContext(_ctx, State);
		EnterRule(_localctx, 162, RULE_createSchemaQual);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1396; _localctx.i = Match(IDENT);
			State = 1397; columnList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariantListContext : ParserRuleContext {
		public VariantListElementContext[] variantListElement() {
			return GetRuleContexts<VariantListElementContext>();
		}
		public VariantListElementContext variantListElement(int i) {
			return GetRuleContext<VariantListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public VariantListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variantList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterVariantList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitVariantList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariantList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariantListContext variantList() {
		VariantListContext _localctx = new VariantListContext(_ctx, State);
		EnterRule(_localctx, 164, RULE_variantList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1399; variantListElement();
			State = 1404;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,155,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1400; Match(COMMA);
					State = 1401; variantListElement();
					}
					} 
				}
				State = 1406;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,155,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariantListElementContext : ParserRuleContext {
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public VariantListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variantListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterVariantListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitVariantListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariantListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariantListElementContext variantListElement() {
		VariantListElementContext _localctx = new VariantListElementContext(_ctx, State);
		EnterRule(_localctx, 166, RULE_variantListElement);
		try {
			State = 1409;
			switch (_input.La(1)) {
			case STAR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1407; Match(STAR);
				}
				break;
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1408; classIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntoTableExprContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TABLE() { return GetToken(EsperEPL2GrammarParser.TABLE, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public IntoTableExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intoTableExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterIntoTableExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitIntoTableExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntoTableExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntoTableExprContext intoTableExpr() {
		IntoTableExprContext _localctx = new IntoTableExprContext(_ctx, State);
		EnterRule(_localctx, 168, RULE_intoTableExpr);
		 paraphrases.Push("into-table clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1411; Match(TABLE);
			State = 1412; _localctx.i = Match(IDENT);
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertIntoExprContext : ParserRuleContext {
		public IToken i;
		public IToken r;
		public IToken ir;
		public ITerminalNode INTO() { return GetToken(EsperEPL2GrammarParser.INTO, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ISTREAM() { return GetToken(EsperEPL2GrammarParser.ISTREAM, 0); }
		public ITerminalNode RSTREAM() { return GetToken(EsperEPL2GrammarParser.RSTREAM, 0); }
		public ITerminalNode IRSTREAM() { return GetToken(EsperEPL2GrammarParser.IRSTREAM, 0); }
		public ColumnListContext columnList() {
			return GetRuleContext<ColumnListContext>(0);
		}
		public InsertIntoExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertIntoExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterInsertIntoExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitInsertIntoExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertIntoExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertIntoExprContext insertIntoExpr() {
		InsertIntoExprContext _localctx = new InsertIntoExprContext(_ctx, State);
		EnterRule(_localctx, 170, RULE_insertIntoExpr);
		 paraphrases.Push("insert-into clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1417;
			switch (_input.La(1)) {
			case ISTREAM:
				{
				State = 1414; _localctx.i = Match(ISTREAM);
				}
				break;
			case RSTREAM:
				{
				State = 1415; _localctx.r = Match(RSTREAM);
				}
				break;
			case IRSTREAM:
				{
				State = 1416; _localctx.ir = Match(IRSTREAM);
				}
				break;
			case INTO:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1419; Match(INTO);
			State = 1420; classIdentifier();
			State = 1426;
			_la = _input.La(1);
			if (_la==LPAREN) {
				{
				State = 1421; Match(LPAREN);
				State = 1423;
				_la = _input.La(1);
				if (_la==IDENT) {
					{
					State = 1422; columnList();
					}
				}

				State = 1425; Match(RPAREN);
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnListContext : ParserRuleContext {
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ColumnListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterColumnList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitColumnList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumnList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ColumnListContext columnList() {
		ColumnListContext _localctx = new ColumnListContext(_ctx, State);
		EnterRule(_localctx, 172, RULE_columnList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1428; Match(IDENT);
			State = 1433;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,160,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1429; Match(COMMA);
					State = 1430; Match(IDENT);
					}
					} 
				}
				State = 1435;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,160,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FromClauseContext : ParserRuleContext {
		public StreamExpressionContext streamExpression() {
			return GetRuleContext<StreamExpressionContext>(0);
		}
		public RegularJoinContext regularJoin() {
			return GetRuleContext<RegularJoinContext>(0);
		}
		public OuterJoinListContext outerJoinList() {
			return GetRuleContext<OuterJoinListContext>(0);
		}
		public FromClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fromClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFromClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFromClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFromClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FromClauseContext fromClause() {
		FromClauseContext _localctx = new FromClauseContext(_ctx, State);
		EnterRule(_localctx, 174, RULE_fromClause);
		 paraphrases.Push("from clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1436; streamExpression();
			State = 1439;
			switch (_input.La(1)) {
			case Eof:
			case WHERE:
			case GROUP:
			case HAVING:
			case OUTPUT:
			case ORDER:
			case ROW_LIMIT_EXPR:
			case MATCH_RECOGNIZE:
			case FOR:
			case RPAREN:
			case COMMA:
				{
				State = 1437; regularJoin();
				}
				break;
			case INNER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
				{
				State = 1438; outerJoinList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegularJoinContext : ParserRuleContext {
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public StreamExpressionContext[] streamExpression() {
			return GetRuleContexts<StreamExpressionContext>();
		}
		public StreamExpressionContext streamExpression(int i) {
			return GetRuleContext<StreamExpressionContext>(i);
		}
		public RegularJoinContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regularJoin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterRegularJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitRegularJoin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegularJoin(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RegularJoinContext regularJoin() {
		RegularJoinContext _localctx = new RegularJoinContext(_ctx, State);
		EnterRule(_localctx, 176, RULE_regularJoin);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1445;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1441; Match(COMMA);
				State = 1442; streamExpression();
				}
				}
				State = 1447;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinListContext : ParserRuleContext {
		public OuterJoinContext[] outerJoin() {
			return GetRuleContexts<OuterJoinContext>();
		}
		public OuterJoinContext outerJoin(int i) {
			return GetRuleContext<OuterJoinContext>(i);
		}
		public OuterJoinListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoinList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOuterJoinList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOuterJoinList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuterJoinList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinListContext outerJoinList() {
		OuterJoinListContext _localctx = new OuterJoinListContext(_ctx, State);
		EnterRule(_localctx, 178, RULE_outerJoinList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1448; outerJoin();
			State = 1452;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INNER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL))) != 0)) {
				{
				{
				State = 1449; outerJoin();
				}
				}
				State = 1454;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinContext : ParserRuleContext {
		public IToken tl;
		public IToken tr;
		public IToken tf;
		public IToken i;
		public ITerminalNode JOIN() { return GetToken(EsperEPL2GrammarParser.JOIN, 0); }
		public StreamExpressionContext streamExpression() {
			return GetRuleContext<StreamExpressionContext>(0);
		}
		public OuterJoinIdentContext outerJoinIdent() {
			return GetRuleContext<OuterJoinIdentContext>(0);
		}
		public ITerminalNode OUTER() { return GetToken(EsperEPL2GrammarParser.OUTER, 0); }
		public ITerminalNode INNER() { return GetToken(EsperEPL2GrammarParser.INNER, 0); }
		public ITerminalNode LEFT() { return GetToken(EsperEPL2GrammarParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(EsperEPL2GrammarParser.RIGHT, 0); }
		public ITerminalNode FULL() { return GetToken(EsperEPL2GrammarParser.FULL, 0); }
		public OuterJoinContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoin; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOuterJoin(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOuterJoin(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuterJoin(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinContext outerJoin() {
		OuterJoinContext _localctx = new OuterJoinContext(_ctx, State);
		EnterRule(_localctx, 180, RULE_outerJoin);
		 paraphrases.Push("outer join"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1464;
			switch (_input.La(1)) {
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
				{
				State = 1461;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LEFT) | (1L << RIGHT) | (1L << FULL))) != 0)) {
					{
					State = 1458;
					switch (_input.La(1)) {
					case LEFT:
						{
						State = 1455; _localctx.tl = Match(LEFT);
						}
						break;
					case RIGHT:
						{
						State = 1456; _localctx.tr = Match(RIGHT);
						}
						break;
					case FULL:
						{
						State = 1457; _localctx.tf = Match(FULL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 1460; Match(OUTER);
					}
				}

				}
				break;
			case INNER:
				{
				{
				State = 1463; _localctx.i = Match(INNER);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1466; Match(JOIN);
			State = 1467; streamExpression();
			State = 1469;
			_la = _input.La(1);
			if (_la==ON) {
				{
				State = 1468; outerJoinIdent();
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinIdentContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(EsperEPL2GrammarParser.ON, 0); }
		public OuterJoinIdentPairContext[] outerJoinIdentPair() {
			return GetRuleContexts<OuterJoinIdentPairContext>();
		}
		public OuterJoinIdentPairContext outerJoinIdentPair(int i) {
			return GetRuleContext<OuterJoinIdentPairContext>(i);
		}
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public OuterJoinIdentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoinIdent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOuterJoinIdent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOuterJoinIdent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuterJoinIdent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinIdentContext outerJoinIdent() {
		OuterJoinIdentContext _localctx = new OuterJoinIdentContext(_ctx, State);
		EnterRule(_localctx, 182, RULE_outerJoinIdent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1471; Match(ON);
			State = 1472; outerJoinIdentPair();
			State = 1477;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==AND_EXPR) {
				{
				{
				State = 1473; Match(AND_EXPR);
				State = 1474; outerJoinIdentPair();
				}
				}
				State = 1479;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OuterJoinIdentPairContext : ParserRuleContext {
		public EventPropertyContext[] eventProperty() {
			return GetRuleContexts<EventPropertyContext>();
		}
		public EventPropertyContext eventProperty(int i) {
			return GetRuleContext<EventPropertyContext>(i);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public OuterJoinIdentPairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outerJoinIdentPair; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOuterJoinIdentPair(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOuterJoinIdentPair(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuterJoinIdentPair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OuterJoinIdentPairContext outerJoinIdentPair() {
		OuterJoinIdentPairContext _localctx = new OuterJoinIdentPairContext(_ctx, State);
		EnterRule(_localctx, 184, RULE_outerJoinIdentPair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1480; eventProperty();
			State = 1481; Match(EQUALS);
			State = 1482; eventProperty();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhereClauseContext : ParserRuleContext {
		public EvalOrExpressionContext evalOrExpression() {
			return GetRuleContext<EvalOrExpressionContext>(0);
		}
		public WhereClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whereClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterWhereClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitWhereClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhereClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhereClauseContext whereClause() {
		WhereClauseContext _localctx = new WhereClauseContext(_ctx, State);
		EnterRule(_localctx, 186, RULE_whereClause);
		 paraphrases.Push("where clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1484; evalOrExpression();
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectClauseContext : ParserRuleContext {
		public IToken s;
		public IToken d;
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public ITerminalNode RSTREAM() { return GetToken(EsperEPL2GrammarParser.RSTREAM, 0); }
		public ITerminalNode ISTREAM() { return GetToken(EsperEPL2GrammarParser.ISTREAM, 0); }
		public ITerminalNode IRSTREAM() { return GetToken(EsperEPL2GrammarParser.IRSTREAM, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public SelectClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectClauseContext selectClause() {
		SelectClauseContext _localctx = new SelectClauseContext(_ctx, State);
		EnterRule(_localctx, 188, RULE_selectClause);
		 paraphrases.Push("select clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1489;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,169,_ctx) ) {
			case 1:
				{
				State = 1486; _localctx.s = Match(RSTREAM);
				}
				break;

			case 2:
				{
				State = 1487; _localctx.s = Match(ISTREAM);
				}
				break;

			case 3:
				{
				State = 1488; _localctx.s = Match(IRSTREAM);
				}
				break;
			}
			State = 1492;
			_la = _input.La(1);
			if (_la==DISTINCT) {
				{
				State = 1491; _localctx.d = Match(DISTINCT);
				}
			}

			State = 1494; selectionList();
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionListContext : ParserRuleContext {
		public SelectionListElementContext[] selectionListElement() {
			return GetRuleContexts<SelectionListElementContext>();
		}
		public SelectionListElementContext selectionListElement(int i) {
			return GetRuleContext<SelectionListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public SelectionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionListContext selectionList() {
		SelectionListContext _localctx = new SelectionListContext(_ctx, State);
		EnterRule(_localctx, 190, RULE_selectionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1496; selectionListElement();
			State = 1501;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1497; Match(COMMA);
				State = 1498; selectionListElement();
				}
				}
				State = 1503;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionListElementContext : ParserRuleContext {
		public IToken s;
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public StreamSelectorContext streamSelector() {
			return GetRuleContext<StreamSelectorContext>(0);
		}
		public SelectionListElementExprContext selectionListElementExpr() {
			return GetRuleContext<SelectionListElementExprContext>(0);
		}
		public SelectionListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionListElementContext selectionListElement() {
		SelectionListElementContext _localctx = new SelectionListElementContext(_ctx, State);
		EnterRule(_localctx, 192, RULE_selectionListElement);
		try {
			State = 1507;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,172,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1504; _localctx.s = Match(STAR);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1505; streamSelector();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1506; selectionListElementExpr();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionListElementExprContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SelectionListElementAnnoContext selectionListElementAnno() {
			return GetRuleContext<SelectionListElementAnnoContext>(0);
		}
		public KeywordAllowedIdentContext keywordAllowedIdent() {
			return GetRuleContext<KeywordAllowedIdentContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public SelectionListElementExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionListElementExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionListElementExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionListElementExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionListElementExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionListElementExprContext selectionListElementExpr() {
		SelectionListElementExprContext _localctx = new SelectionListElementExprContext(_ctx, State);
		EnterRule(_localctx, 194, RULE_selectionListElementExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1509; expression();
			State = 1511;
			_la = _input.La(1);
			if (_la==ATCHAR) {
				{
				State = 1510; selectionListElementAnno();
				}
			}

			State = 1517;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,175,_ctx) ) {
			case 1:
				{
				State = 1514;
				_la = _input.La(1);
				if (_la==AS) {
					{
					State = 1513; Match(AS);
					}
				}

				State = 1516; keywordAllowedIdent();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectionListElementAnnoContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public SelectionListElementAnnoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectionListElementAnno; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSelectionListElementAnno(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSelectionListElementAnno(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectionListElementAnno(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectionListElementAnnoContext selectionListElementAnno() {
		SelectionListElementAnnoContext _localctx = new SelectionListElementAnnoContext(_ctx, State);
		EnterRule(_localctx, 196, RULE_selectionListElementAnno);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1519; Match(ATCHAR);
			State = 1520; _localctx.i = Match(IDENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StreamSelectorContext : ParserRuleContext {
		public IToken s;
		public IToken i;
		public ITerminalNode DOT() { return GetToken(EsperEPL2GrammarParser.DOT, 0); }
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public StreamSelectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_streamSelector; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStreamSelector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStreamSelector(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStreamSelector(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StreamSelectorContext streamSelector() {
		StreamSelectorContext _localctx = new StreamSelectorContext(_ctx, State);
		EnterRule(_localctx, 198, RULE_streamSelector);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1522; _localctx.s = Match(IDENT);
			State = 1523; Match(DOT);
			State = 1524; Match(STAR);
			State = 1527;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 1525; Match(AS);
				State = 1526; _localctx.i = Match(IDENT);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StreamExpressionContext : ParserRuleContext {
		public IToken i;
		public IToken u;
		public IToken ru;
		public IToken ri;
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public PatternInclusionExpressionContext patternInclusionExpression() {
			return GetRuleContext<PatternInclusionExpressionContext>(0);
		}
		public DatabaseJoinExpressionContext databaseJoinExpression() {
			return GetRuleContext<DatabaseJoinExpressionContext>(0);
		}
		public MethodJoinExpressionContext methodJoinExpression() {
			return GetRuleContext<MethodJoinExpressionContext>(0);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public ViewExpressionContext[] viewExpression() {
			return GetRuleContexts<ViewExpressionContext>();
		}
		public ViewExpressionContext viewExpression(int i) {
			return GetRuleContext<ViewExpressionContext>(i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode UNIDIRECTIONAL() { return GetToken(EsperEPL2GrammarParser.UNIDIRECTIONAL, 0); }
		public ITerminalNode RETAINUNION() { return GetToken(EsperEPL2GrammarParser.RETAINUNION, 0); }
		public ITerminalNode RETAININTERSECTION() { return GetToken(EsperEPL2GrammarParser.RETAININTERSECTION, 0); }
		public StreamExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_streamExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStreamExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStreamExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStreamExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StreamExpressionContext streamExpression() {
		StreamExpressionContext _localctx = new StreamExpressionContext(_ctx, State);
		EnterRule(_localctx, 200, RULE_streamExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1533;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,177,_ctx) ) {
			case 1:
				{
				State = 1529; eventFilterExpression();
				}
				break;

			case 2:
				{
				State = 1530; patternInclusionExpression();
				}
				break;

			case 3:
				{
				State = 1531; databaseJoinExpression();
				}
				break;

			case 4:
				{
				State = 1532; methodJoinExpression();
				}
				break;
			}
			State = 1544;
			_la = _input.La(1);
			if (_la==DOT) {
				{
				State = 1535; Match(DOT);
				State = 1536; viewExpression();
				State = 1541;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==DOT) {
					{
					{
					State = 1537; Match(DOT);
					State = 1538; viewExpression();
					}
					}
					State = 1543;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 1549;
			switch (_input.La(1)) {
			case AS:
				{
				State = 1546; Match(AS);
				State = 1547; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 1548; _localctx.i = Match(IDENT);
				}
				break;
			case Eof:
			case WHERE:
			case INNER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case ON:
			case GROUP:
			case HAVING:
			case OUTPUT:
			case ORDER:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case ROW_LIMIT_EXPR:
			case MATCH_RECOGNIZE:
			case FOR:
			case RPAREN:
			case COMMA:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1552;
			_la = _input.La(1);
			if (_la==UNIDIRECTIONAL) {
				{
				State = 1551; _localctx.u = Match(UNIDIRECTIONAL);
				}
			}

			State = 1556;
			switch (_input.La(1)) {
			case RETAINUNION:
				{
				State = 1554; _localctx.ru = Match(RETAINUNION);
				}
				break;
			case RETAININTERSECTION:
				{
				State = 1555; _localctx.ri = Match(RETAININTERSECTION);
				}
				break;
			case Eof:
			case WHERE:
			case INNER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case ON:
			case GROUP:
			case HAVING:
			case OUTPUT:
			case ORDER:
			case ROW_LIMIT_EXPR:
			case MATCH_RECOGNIZE:
			case FOR:
			case RPAREN:
			case COMMA:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForExprContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode FOR() { return GetToken(EsperEPL2GrammarParser.FOR, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ForExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterForExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitForExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForExprContext forExpr() {
		ForExprContext _localctx = new ForExprContext(_ctx, State);
		EnterRule(_localctx, 202, RULE_forExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1558; Match(FOR);
			State = 1559; _localctx.i = Match(IDENT);
			State = 1565;
			_la = _input.La(1);
			if (_la==LPAREN) {
				{
				State = 1560; Match(LPAREN);
				State = 1562;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 1561; expressionList();
					}
				}

				State = 1564; Match(RPAREN);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternInclusionExpressionContext : ParserRuleContext {
		public ITerminalNode PATTERN() { return GetToken(EsperEPL2GrammarParser.PATTERN, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public PatternExpressionContext patternExpression() {
			return GetRuleContext<PatternExpressionContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public AnnotationEnumContext[] annotationEnum() {
			return GetRuleContexts<AnnotationEnumContext>();
		}
		public AnnotationEnumContext annotationEnum(int i) {
			return GetRuleContext<AnnotationEnumContext>(i);
		}
		public PatternInclusionExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternInclusionExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPatternInclusionExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPatternInclusionExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternInclusionExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternInclusionExpressionContext patternInclusionExpression() {
		PatternInclusionExpressionContext _localctx = new PatternInclusionExpressionContext(_ctx, State);
		EnterRule(_localctx, 204, RULE_patternInclusionExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1567; Match(PATTERN);
			State = 1571;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ATCHAR) {
				{
				{
				State = 1568; annotationEnum();
				}
				}
				State = 1573;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1574; Match(LBRACK);
			State = 1575; patternExpression();
			State = 1576; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatabaseJoinExpressionContext : ParserRuleContext {
		public IToken i;
		public IToken s;
		public IToken s2;
		public ITerminalNode SQL() { return GetToken(EsperEPL2GrammarParser.SQL, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode[] STRING_LITERAL() { return GetTokens(EsperEPL2GrammarParser.STRING_LITERAL); }
		public ITerminalNode STRING_LITERAL(int i) {
			return GetToken(EsperEPL2GrammarParser.STRING_LITERAL, i);
		}
		public ITerminalNode[] QUOTED_STRING_LITERAL() { return GetTokens(EsperEPL2GrammarParser.QUOTED_STRING_LITERAL); }
		public ITerminalNode QUOTED_STRING_LITERAL(int i) {
			return GetToken(EsperEPL2GrammarParser.QUOTED_STRING_LITERAL, i);
		}
		public ITerminalNode METADATASQL() { return GetToken(EsperEPL2GrammarParser.METADATASQL, 0); }
		public DatabaseJoinExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_databaseJoinExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterDatabaseJoinExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitDatabaseJoinExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatabaseJoinExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DatabaseJoinExpressionContext databaseJoinExpression() {
		DatabaseJoinExpressionContext _localctx = new DatabaseJoinExpressionContext(_ctx, State);
		EnterRule(_localctx, 206, RULE_databaseJoinExpression);
		 paraphrases.Push("relational data join"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1578; Match(SQL);
			State = 1579; Match(COLON);
			State = 1580; _localctx.i = Match(IDENT);
			State = 1581; Match(LBRACK);
			State = 1584;
			switch (_input.La(1)) {
			case STRING_LITERAL:
				{
				State = 1582; _localctx.s = Match(STRING_LITERAL);
				}
				break;
			case QUOTED_STRING_LITERAL:
				{
				State = 1583; _localctx.s = Match(QUOTED_STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1591;
			_la = _input.La(1);
			if (_la==METADATASQL) {
				{
				State = 1586; Match(METADATASQL);
				State = 1589;
				switch (_input.La(1)) {
				case STRING_LITERAL:
					{
					State = 1587; _localctx.s2 = Match(STRING_LITERAL);
					}
					break;
				case QUOTED_STRING_LITERAL:
					{
					State = 1588; _localctx.s2 = Match(QUOTED_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			State = 1593; Match(RBRACK);
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MethodJoinExpressionContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public MethodJoinExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_methodJoinExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMethodJoinExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMethodJoinExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethodJoinExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MethodJoinExpressionContext methodJoinExpression() {
		MethodJoinExpressionContext _localctx = new MethodJoinExpressionContext(_ctx, State);
		EnterRule(_localctx, 208, RULE_methodJoinExpression);
		 paraphrases.Push("method invocation join"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1595; _localctx.i = Match(IDENT);
			State = 1596; Match(COLON);
			State = 1597; classIdentifier();
			State = 1603;
			_la = _input.La(1);
			if (_la==LPAREN) {
				{
				State = 1598; Match(LPAREN);
				State = 1600;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 1599; expressionList();
					}
				}

				State = 1602; Match(RPAREN);
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ViewExpressionContext : ParserRuleContext {
		public IToken ns;
		public IToken i;
		public IToken m;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode MERGE() { return GetToken(EsperEPL2GrammarParser.MERGE, 0); }
		public ExpressionWithTimeListContext expressionWithTimeList() {
			return GetRuleContext<ExpressionWithTimeListContext>(0);
		}
		public ViewExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_viewExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterViewExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitViewExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitViewExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ViewExpressionContext viewExpression() {
		ViewExpressionContext _localctx = new ViewExpressionContext(_ctx, State);
		EnterRule(_localctx, 210, RULE_viewExpression);
		 paraphrases.Push("view specifications"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1605; _localctx.ns = Match(IDENT);
			State = 1606; Match(COLON);
			State = 1609;
			switch (_input.La(1)) {
			case IDENT:
				{
				State = 1607; _localctx.i = Match(IDENT);
				}
				break;
			case MERGE:
				{
				State = 1608; _localctx.m = Match(MERGE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1611; Match(LPAREN);
			State = 1613;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LBRACK - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (STAR - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
				{
				State = 1612; expressionWithTimeList();
				}
			}

			State = 1615; Match(RPAREN);
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByListExprContext : ParserRuleContext {
		public GroupByListChoiceContext[] groupByListChoice() {
			return GetRuleContexts<GroupByListChoiceContext>();
		}
		public GroupByListChoiceContext groupByListChoice(int i) {
			return GetRuleContext<GroupByListChoiceContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GroupByListExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByListExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByListExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByListExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByListExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByListExprContext groupByListExpr() {
		GroupByListExprContext _localctx = new GroupByListExprContext(_ctx, State);
		EnterRule(_localctx, 212, RULE_groupByListExpr);
		 paraphrases.Push("group-by clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1617; groupByListChoice();
			State = 1622;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1618; Match(COMMA);
				State = 1619; groupByListChoice();
				}
				}
				State = 1624;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByListChoiceContext : ParserRuleContext {
		public ExpressionContext e1;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public GroupByCubeOrRollupContext groupByCubeOrRollup() {
			return GetRuleContext<GroupByCubeOrRollupContext>(0);
		}
		public GroupByGroupingSetsContext groupByGroupingSets() {
			return GetRuleContext<GroupByGroupingSetsContext>(0);
		}
		public GroupByListChoiceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByListChoice; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByListChoice(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByListChoice(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByListChoice(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByListChoiceContext groupByListChoice() {
		GroupByListChoiceContext _localctx = new GroupByListChoiceContext(_ctx, State);
		EnterRule(_localctx, 214, RULE_groupByListChoice);
		try {
			State = 1628;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,194,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1625; _localctx.e1 = expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1626; groupByCubeOrRollup();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1627; groupByGroupingSets();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByCubeOrRollupContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public GroupByCombinableExprContext[] groupByCombinableExpr() {
			return GetRuleContexts<GroupByCombinableExprContext>();
		}
		public GroupByCombinableExprContext groupByCombinableExpr(int i) {
			return GetRuleContext<GroupByCombinableExprContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode CUBE() { return GetToken(EsperEPL2GrammarParser.CUBE, 0); }
		public ITerminalNode ROLLUP() { return GetToken(EsperEPL2GrammarParser.ROLLUP, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GroupByCubeOrRollupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByCubeOrRollup; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByCubeOrRollup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByCubeOrRollup(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByCubeOrRollup(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByCubeOrRollupContext groupByCubeOrRollup() {
		GroupByCubeOrRollupContext _localctx = new GroupByCubeOrRollupContext(_ctx, State);
		EnterRule(_localctx, 216, RULE_groupByCubeOrRollup);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1630;
			_la = _input.La(1);
			if ( !(_la==CUBE || _la==ROLLUP) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1631; Match(LPAREN);
			State = 1632; groupByCombinableExpr();
			State = 1637;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1633; Match(COMMA);
				State = 1634; groupByCombinableExpr();
				}
				}
				State = 1639;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1640; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByGroupingSetsContext : ParserRuleContext {
		public ITerminalNode GROUPING() { return GetToken(EsperEPL2GrammarParser.GROUPING, 0); }
		public ITerminalNode SETS() { return GetToken(EsperEPL2GrammarParser.SETS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public GroupBySetsChoiceContext[] groupBySetsChoice() {
			return GetRuleContexts<GroupBySetsChoiceContext>();
		}
		public GroupBySetsChoiceContext groupBySetsChoice(int i) {
			return GetRuleContext<GroupBySetsChoiceContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GroupByGroupingSetsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByGroupingSets; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByGroupingSets(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByGroupingSets(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByGroupingSets(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByGroupingSetsContext groupByGroupingSets() {
		GroupByGroupingSetsContext _localctx = new GroupByGroupingSetsContext(_ctx, State);
		EnterRule(_localctx, 218, RULE_groupByGroupingSets);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1642; Match(GROUPING);
			State = 1643; Match(SETS);
			State = 1644; Match(LPAREN);
			State = 1645; groupBySetsChoice();
			State = 1650;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1646; Match(COMMA);
				State = 1647; groupBySetsChoice();
				}
				}
				State = 1652;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1653; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupBySetsChoiceContext : ParserRuleContext {
		public GroupByCubeOrRollupContext groupByCubeOrRollup() {
			return GetRuleContext<GroupByCubeOrRollupContext>(0);
		}
		public GroupByCombinableExprContext groupByCombinableExpr() {
			return GetRuleContext<GroupByCombinableExprContext>(0);
		}
		public GroupBySetsChoiceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupBySetsChoice; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupBySetsChoice(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupBySetsChoice(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupBySetsChoice(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupBySetsChoiceContext groupBySetsChoice() {
		GroupBySetsChoiceContext _localctx = new GroupBySetsChoiceContext(_ctx, State);
		EnterRule(_localctx, 220, RULE_groupBySetsChoice);
		try {
			State = 1657;
			switch (_input.La(1)) {
			case CUBE:
			case ROLLUP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1655; groupByCubeOrRollup();
				}
				break;
			case WINDOW:
			case ESCAPE:
			case NOT_EXPR:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case CASE:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case ISTREAM:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PREVIOUSCOUNT:
			case PREVIOUSWINDOW:
			case PRIOR:
			case EXISTS:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case CURRENT_TIMESTAMP:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case NEWKW:
			case CONTEXT:
			case GROUPING:
			case GROUPING_ID:
			case QUESTION:
			case LPAREN:
			case LCURLY:
			case PLUS:
			case MINUS:
			case TICKED_STRING_LITERAL:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IDENT:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1656; groupByCombinableExpr();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupByCombinableExprContext : ParserRuleContext {
		public ExpressionContext e1;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public GroupByCombinableExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupByCombinableExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGroupByCombinableExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGroupByCombinableExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupByCombinableExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupByCombinableExprContext groupByCombinableExpr() {
		GroupByCombinableExprContext _localctx = new GroupByCombinableExprContext(_ctx, State);
		EnterRule(_localctx, 222, RULE_groupByCombinableExpr);
		int _la;
		try {
			State = 1672;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,200,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1659; _localctx.e1 = expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1660; Match(LPAREN);
				State = 1669;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 1661; expression();
					State = 1666;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==COMMA) {
						{
						{
						State = 1662; Match(COMMA);
						State = 1663; expression();
						}
						}
						State = 1668;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					}
				}

				State = 1671; Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByListExprContext : ParserRuleContext {
		public OrderByListElementContext[] orderByListElement() {
			return GetRuleContexts<OrderByListElementContext>();
		}
		public OrderByListElementContext orderByListElement(int i) {
			return GetRuleContext<OrderByListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public OrderByListExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByListExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOrderByListExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOrderByListExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderByListExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrderByListExprContext orderByListExpr() {
		OrderByListExprContext _localctx = new OrderByListExprContext(_ctx, State);
		EnterRule(_localctx, 224, RULE_orderByListExpr);
		 paraphrases.Push("order by clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1674; orderByListElement();
			State = 1679;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1675; Match(COMMA);
				State = 1676; orderByListElement();
				}
				}
				State = 1681;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByListElementContext : ParserRuleContext {
		public IToken a;
		public IToken d;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(EsperEPL2GrammarParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(EsperEPL2GrammarParser.DESC, 0); }
		public OrderByListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderByListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOrderByListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOrderByListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderByListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrderByListElementContext orderByListElement() {
		OrderByListElementContext _localctx = new OrderByListElementContext(_ctx, State);
		EnterRule(_localctx, 226, RULE_orderByListElement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1682; expression();
			State = 1685;
			switch (_input.La(1)) {
			case ASC:
				{
				State = 1683; _localctx.a = Match(ASC);
				}
				break;
			case DESC:
				{
				State = 1684; _localctx.d = Match(DESC);
				}
				break;
			case Eof:
			case INSERT:
			case ROW_LIMIT_EXPR:
			case FOR:
			case RPAREN:
			case COMMA:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HavingClauseContext : ParserRuleContext {
		public EvalOrExpressionContext evalOrExpression() {
			return GetRuleContext<EvalOrExpressionContext>(0);
		}
		public HavingClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_havingClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterHavingClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitHavingClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHavingClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HavingClauseContext havingClause() {
		HavingClauseContext _localctx = new HavingClauseContext(_ctx, State);
		EnterRule(_localctx, 228, RULE_havingClause);
		 paraphrases.Push("having clause"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1687; evalOrExpression();
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OutputLimitContext : ParserRuleContext {
		public IToken k;
		public IToken ev;
		public IToken i;
		public IToken e;
		public IToken at;
		public IToken wh;
		public IToken t;
		public OutputLimitAfterContext outputLimitAfter() {
			return GetRuleContext<OutputLimitAfterContext>(0);
		}
		public OutputLimitAndTermContext outputLimitAndTerm() {
			return GetRuleContext<OutputLimitAndTermContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(EsperEPL2GrammarParser.SNAPSHOT, 0); }
		public CrontabLimitParameterSetContext crontabLimitParameterSet() {
			return GetRuleContext<CrontabLimitParameterSetContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TERMINATED() { return GetToken(EsperEPL2GrammarParser.TERMINATED, 0); }
		public ITerminalNode EVERY_EXPR() { return GetToken(EsperEPL2GrammarParser.EVERY_EXPR, 0); }
		public ITerminalNode AT() { return GetToken(EsperEPL2GrammarParser.AT, 0); }
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public OnSetExprContext onSetExpr() {
			return GetRuleContext<OnSetExprContext>(0);
		}
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode EVENTS() { return GetToken(EsperEPL2GrammarParser.EVENTS, 0); }
		public OutputLimitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outputLimit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOutputLimit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOutputLimit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOutputLimit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OutputLimitContext outputLimit() {
		OutputLimitContext _localctx = new OutputLimitContext(_ctx, State);
		EnterRule(_localctx, 230, RULE_outputLimit);
		 paraphrases.Push("output rate clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1690;
			_la = _input.La(1);
			if (_la==AFTER) {
				{
				State = 1689; outputLimitAfter();
				}
			}

			State = 1696;
			switch (_input.La(1)) {
			case ALL:
				{
				State = 1692; _localctx.k = Match(ALL);
				}
				break;
			case FIRST:
				{
				State = 1693; _localctx.k = Match(FIRST);
				}
				break;
			case LAST:
				{
				State = 1694; _localctx.k = Match(LAST);
				}
				break;
			case SNAPSHOT:
				{
				State = 1695; _localctx.k = Match(SNAPSHOT);
				}
				break;
			case Eof:
			case AND_EXPR:
			case EVERY_EXPR:
			case WHEN:
			case ORDER:
			case AT:
			case ROW_LIMIT_EXPR:
			case FOR:
			case RPAREN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1726;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,210,_ctx) ) {
			case 1:
				{
				{
				State = 1698; _localctx.ev = Match(EVERY_EXPR);
				State = 1705;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,206,_ctx) ) {
				case 1:
					{
					State = 1699; timePeriod();
					}
					break;

				case 2:
					{
					State = 1702;
					switch (_input.La(1)) {
					case IntegerLiteral:
					case FloatingPointLiteral:
						{
						State = 1700; number();
						}
						break;
					case IDENT:
						{
						State = 1701; _localctx.i = Match(IDENT);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					{
					State = 1704; _localctx.e = Match(EVENTS);
					}
					}
					break;
				}
				}
				}
				break;

			case 2:
				{
				{
				State = 1707; _localctx.at = Match(AT);
				State = 1708; crontabLimitParameterSet();
				}
				}
				break;

			case 3:
				{
				{
				State = 1709; _localctx.wh = Match(WHEN);
				State = 1710; expression();
				State = 1713;
				_la = _input.La(1);
				if (_la==THEN) {
					{
					State = 1711; Match(THEN);
					State = 1712; onSetExpr();
					}
				}

				}
				}
				break;

			case 4:
				{
				{
				State = 1715; _localctx.t = Match(WHEN);
				State = 1716; Match(TERMINATED);
				State = 1719;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,208,_ctx) ) {
				case 1:
					{
					State = 1717; Match(AND_EXPR);
					State = 1718; expression();
					}
					break;
				}
				State = 1723;
				_la = _input.La(1);
				if (_la==THEN) {
					{
					State = 1721; Match(THEN);
					State = 1722; onSetExpr();
					}
				}

				}
				}
				break;

			case 5:
				{
				}
				break;
			}
			State = 1729;
			_la = _input.La(1);
			if (_la==AND_EXPR) {
				{
				State = 1728; outputLimitAndTerm();
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OutputLimitAndTermContext : ParserRuleContext {
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public ITerminalNode TERMINATED() { return GetToken(EsperEPL2GrammarParser.TERMINATED, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public OnSetExprContext onSetExpr() {
			return GetRuleContext<OnSetExprContext>(0);
		}
		public OutputLimitAndTermContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outputLimitAndTerm; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOutputLimitAndTerm(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOutputLimitAndTerm(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOutputLimitAndTerm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OutputLimitAndTermContext outputLimitAndTerm() {
		OutputLimitAndTermContext _localctx = new OutputLimitAndTermContext(_ctx, State);
		EnterRule(_localctx, 232, RULE_outputLimitAndTerm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1731; Match(AND_EXPR);
			State = 1732; Match(WHEN);
			State = 1733; Match(TERMINATED);
			State = 1736;
			_la = _input.La(1);
			if (_la==AND_EXPR) {
				{
				State = 1734; Match(AND_EXPR);
				State = 1735; expression();
				}
			}

			State = 1740;
			_la = _input.La(1);
			if (_la==THEN) {
				{
				State = 1738; Match(THEN);
				State = 1739; onSetExpr();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OutputLimitAfterContext : ParserRuleContext {
		public IToken a;
		public ITerminalNode AFTER() { return GetToken(EsperEPL2GrammarParser.AFTER, 0); }
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode EVENTS() { return GetToken(EsperEPL2GrammarParser.EVENTS, 0); }
		public OutputLimitAfterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outputLimitAfter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOutputLimitAfter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOutputLimitAfter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOutputLimitAfter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OutputLimitAfterContext outputLimitAfter() {
		OutputLimitAfterContext _localctx = new OutputLimitAfterContext(_ctx, State);
		EnterRule(_localctx, 234, RULE_outputLimitAfter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1742; _localctx.a = Match(AFTER);
			State = 1747;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,214,_ctx) ) {
			case 1:
				{
				State = 1743; timePeriod();
				}
				break;

			case 2:
				{
				State = 1744; number();
				State = 1745; Match(EVENTS);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RowLimitContext : ParserRuleContext {
		public NumberconstantContext n1;
		public IToken i1;
		public IToken c;
		public IToken o;
		public NumberconstantContext n2;
		public IToken i2;
		public NumberconstantContext[] numberconstant() {
			return GetRuleContexts<NumberconstantContext>();
		}
		public NumberconstantContext numberconstant(int i) {
			return GetRuleContext<NumberconstantContext>(i);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public ITerminalNode OFFSET() { return GetToken(EsperEPL2GrammarParser.OFFSET, 0); }
		public RowLimitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rowLimit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterRowLimit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitRowLimit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRowLimit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RowLimitContext rowLimit() {
		RowLimitContext _localctx = new RowLimitContext(_ctx, State);
		EnterRule(_localctx, 236, RULE_rowLimit);
		 paraphrases.Push("row limit clause"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1751;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 1749; _localctx.n1 = numberconstant();
				}
				break;
			case IDENT:
				{
				State = 1750; _localctx.i1 = Match(IDENT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1761;
			_la = _input.La(1);
			if (_la==OFFSET || _la==COMMA) {
				{
				State = 1755;
				switch (_input.La(1)) {
				case COMMA:
					{
					State = 1753; _localctx.c = Match(COMMA);
					}
					break;
				case OFFSET:
					{
					State = 1754; _localctx.o = Match(OFFSET);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1759;
				switch (_input.La(1)) {
				case PLUS:
				case MINUS:
				case IntegerLiteral:
				case FloatingPointLiteral:
					{
					State = 1757; _localctx.n2 = numberconstant();
					}
					break;
				case IDENT:
					{
					State = 1758; _localctx.i2 = Match(IDENT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CrontabLimitParameterSetContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionWithTimeListContext expressionWithTimeList() {
			return GetRuleContext<ExpressionWithTimeListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public CrontabLimitParameterSetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_crontabLimitParameterSet; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCrontabLimitParameterSet(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCrontabLimitParameterSet(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCrontabLimitParameterSet(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CrontabLimitParameterSetContext crontabLimitParameterSet() {
		CrontabLimitParameterSetContext _localctx = new CrontabLimitParameterSetContext(_ctx, State);
		EnterRule(_localctx, 238, RULE_crontabLimitParameterSet);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1763; Match(LPAREN);
			State = 1764; expressionWithTimeList();
			State = 1765; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhenClauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(EsperEPL2GrammarParser.WHEN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(EsperEPL2GrammarParser.THEN, 0); }
		public WhenClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whenClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterWhenClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitWhenClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhenClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhenClauseContext whenClause() {
		WhenClauseContext _localctx = new WhenClauseContext(_ctx, State);
		EnterRule(_localctx, 240, RULE_whenClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 1767; Match(WHEN);
			State = 1768; expression();
			State = 1769; Match(THEN);
			State = 1770; expression();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseClauseContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(EsperEPL2GrammarParser.ELSE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ElseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseClause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterElseClause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitElseClause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseClauseContext elseClause() {
		ElseClauseContext _localctx = new ElseClauseContext(_ctx, State);
		EnterRule(_localctx, 242, RULE_elseClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 1772; Match(ELSE);
			State = 1773; expression();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogContext : ParserRuleContext {
		public ITerminalNode MATCH_RECOGNIZE() { return GetToken(EsperEPL2GrammarParser.MATCH_RECOGNIZE, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public MatchRecogMeasuresContext matchRecogMeasures() {
			return GetRuleContext<MatchRecogMeasuresContext>(0);
		}
		public MatchRecogPatternContext matchRecogPattern() {
			return GetRuleContext<MatchRecogPatternContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public MatchRecogPartitionByContext matchRecogPartitionBy() {
			return GetRuleContext<MatchRecogPartitionByContext>(0);
		}
		public MatchRecogMatchesSelectionContext matchRecogMatchesSelection() {
			return GetRuleContext<MatchRecogMatchesSelectionContext>(0);
		}
		public MatchRecogMatchesAfterSkipContext matchRecogMatchesAfterSkip() {
			return GetRuleContext<MatchRecogMatchesAfterSkipContext>(0);
		}
		public MatchRecogMatchesIntervalContext matchRecogMatchesInterval() {
			return GetRuleContext<MatchRecogMatchesIntervalContext>(0);
		}
		public MatchRecogDefineContext matchRecogDefine() {
			return GetRuleContext<MatchRecogDefineContext>(0);
		}
		public MatchRecogContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecog; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecog(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecog(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecog(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogContext matchRecog() {
		MatchRecogContext _localctx = new MatchRecogContext(_ctx, State);
		EnterRule(_localctx, 244, RULE_matchRecog);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1775; Match(MATCH_RECOGNIZE);
			State = 1776; Match(LPAREN);
			State = 1778;
			_la = _input.La(1);
			if (_la==PARTITION) {
				{
				State = 1777; matchRecogPartitionBy();
				}
			}

			State = 1780; matchRecogMeasures();
			State = 1782;
			_la = _input.La(1);
			if (_la==ALL) {
				{
				State = 1781; matchRecogMatchesSelection();
				}
			}

			State = 1785;
			_la = _input.La(1);
			if (_la==AFTER) {
				{
				State = 1784; matchRecogMatchesAfterSkip();
				}
			}

			State = 1787; matchRecogPattern();
			State = 1789;
			_la = _input.La(1);
			if (_la==IDENT) {
				{
				State = 1788; matchRecogMatchesInterval();
				}
			}

			State = 1792;
			_la = _input.La(1);
			if (_la==DEFINE) {
				{
				State = 1791; matchRecogDefine();
				}
			}

			State = 1794; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPartitionByContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(EsperEPL2GrammarParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(EsperEPL2GrammarParser.BY, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public MatchRecogPartitionByContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPartitionBy; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPartitionBy(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPartitionBy(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPartitionBy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPartitionByContext matchRecogPartitionBy() {
		MatchRecogPartitionByContext _localctx = new MatchRecogPartitionByContext(_ctx, State);
		EnterRule(_localctx, 246, RULE_matchRecogPartitionBy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1796; Match(PARTITION);
			State = 1797; Match(BY);
			State = 1798; expression();
			State = 1803;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1799; Match(COMMA);
				State = 1800; expression();
				}
				}
				State = 1805;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMeasuresContext : ParserRuleContext {
		public ITerminalNode MEASURES() { return GetToken(EsperEPL2GrammarParser.MEASURES, 0); }
		public MatchRecogMeasureItemContext[] matchRecogMeasureItem() {
			return GetRuleContexts<MatchRecogMeasureItemContext>();
		}
		public MatchRecogMeasureItemContext matchRecogMeasureItem(int i) {
			return GetRuleContext<MatchRecogMeasureItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public MatchRecogMeasuresContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMeasures; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMeasures(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMeasures(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMeasures(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMeasuresContext matchRecogMeasures() {
		MatchRecogMeasuresContext _localctx = new MatchRecogMeasuresContext(_ctx, State);
		EnterRule(_localctx, 248, RULE_matchRecogMeasures);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1806; Match(MEASURES);
			State = 1807; matchRecogMeasureItem();
			State = 1812;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1808; Match(COMMA);
				State = 1809; matchRecogMeasureItem();
				}
				}
				State = 1814;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMeasureItemContext : ParserRuleContext {
		public IToken i;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MatchRecogMeasureItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMeasureItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMeasureItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMeasureItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMeasureItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMeasureItemContext matchRecogMeasureItem() {
		MatchRecogMeasureItemContext _localctx = new MatchRecogMeasureItemContext(_ctx, State);
		EnterRule(_localctx, 250, RULE_matchRecogMeasureItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1815; expression();
			State = 1820;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 1816; Match(AS);
				State = 1818;
				_la = _input.La(1);
				if (_la==IDENT) {
					{
					State = 1817; _localctx.i = Match(IDENT);
					}
				}

				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMatchesSelectionContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode MATCHES() { return GetToken(EsperEPL2GrammarParser.MATCHES, 0); }
		public MatchRecogMatchesSelectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMatchesSelection; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMatchesSelection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMatchesSelection(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMatchesSelection(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMatchesSelectionContext matchRecogMatchesSelection() {
		MatchRecogMatchesSelectionContext _localctx = new MatchRecogMatchesSelectionContext(_ctx, State);
		EnterRule(_localctx, 252, RULE_matchRecogMatchesSelection);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1822; Match(ALL);
			State = 1823; Match(MATCHES);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternContext : ParserRuleContext {
		public ITerminalNode PATTERN() { return GetToken(EsperEPL2GrammarParser.PATTERN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public MatchRecogPatternAlterationContext matchRecogPatternAlteration() {
			return GetRuleContext<MatchRecogPatternAlterationContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public MatchRecogPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPattern; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPattern(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPattern(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternContext matchRecogPattern() {
		MatchRecogPatternContext _localctx = new MatchRecogPatternContext(_ctx, State);
		EnterRule(_localctx, 254, RULE_matchRecogPattern);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1825; Match(PATTERN);
			State = 1826; Match(LPAREN);
			State = 1827; matchRecogPatternAlteration();
			State = 1828; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMatchesAfterSkipContext : ParserRuleContext {
		public KeywordAllowedIdentContext i1;
		public KeywordAllowedIdentContext i2;
		public KeywordAllowedIdentContext i3;
		public KeywordAllowedIdentContext i4;
		public KeywordAllowedIdentContext i5;
		public ITerminalNode AFTER() { return GetToken(EsperEPL2GrammarParser.AFTER, 0); }
		public KeywordAllowedIdentContext[] keywordAllowedIdent() {
			return GetRuleContexts<KeywordAllowedIdentContext>();
		}
		public KeywordAllowedIdentContext keywordAllowedIdent(int i) {
			return GetRuleContext<KeywordAllowedIdentContext>(i);
		}
		public MatchRecogMatchesAfterSkipContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMatchesAfterSkip; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMatchesAfterSkip(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMatchesAfterSkip(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMatchesAfterSkip(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMatchesAfterSkipContext matchRecogMatchesAfterSkip() {
		MatchRecogMatchesAfterSkipContext _localctx = new MatchRecogMatchesAfterSkipContext(_ctx, State);
		EnterRule(_localctx, 256, RULE_matchRecogMatchesAfterSkip);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1830; Match(AFTER);
			State = 1831; _localctx.i1 = keywordAllowedIdent();
			State = 1832; _localctx.i2 = keywordAllowedIdent();
			State = 1833; _localctx.i3 = keywordAllowedIdent();
			State = 1834; _localctx.i4 = keywordAllowedIdent();
			State = 1835; _localctx.i5 = keywordAllowedIdent();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogMatchesIntervalContext : ParserRuleContext {
		public IToken i;
		public IToken t;
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode OR_EXPR() { return GetToken(EsperEPL2GrammarParser.OR_EXPR, 0); }
		public ITerminalNode TERMINATED() { return GetToken(EsperEPL2GrammarParser.TERMINATED, 0); }
		public MatchRecogMatchesIntervalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogMatchesInterval; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogMatchesInterval(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogMatchesInterval(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogMatchesInterval(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogMatchesIntervalContext matchRecogMatchesInterval() {
		MatchRecogMatchesIntervalContext _localctx = new MatchRecogMatchesIntervalContext(_ctx, State);
		EnterRule(_localctx, 258, RULE_matchRecogMatchesInterval);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1837; _localctx.i = Match(IDENT);
			State = 1838; timePeriod();
			State = 1841;
			_la = _input.La(1);
			if (_la==OR_EXPR) {
				{
				State = 1839; Match(OR_EXPR);
				State = 1840; _localctx.t = Match(TERMINATED);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternAlterationContext : ParserRuleContext {
		public IToken o;
		public MatchRecogPatternConcatContext[] matchRecogPatternConcat() {
			return GetRuleContexts<MatchRecogPatternConcatContext>();
		}
		public MatchRecogPatternConcatContext matchRecogPatternConcat(int i) {
			return GetRuleContext<MatchRecogPatternConcatContext>(i);
		}
		public ITerminalNode[] BOR() { return GetTokens(EsperEPL2GrammarParser.BOR); }
		public ITerminalNode BOR(int i) {
			return GetToken(EsperEPL2GrammarParser.BOR, i);
		}
		public MatchRecogPatternAlterationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternAlteration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternAlteration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternAlteration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternAlteration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternAlterationContext matchRecogPatternAlteration() {
		MatchRecogPatternAlterationContext _localctx = new MatchRecogPatternAlterationContext(_ctx, State);
		EnterRule(_localctx, 260, RULE_matchRecogPatternAlteration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1843; matchRecogPatternConcat();
			State = 1848;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==BOR) {
				{
				{
				State = 1844; _localctx.o = Match(BOR);
				State = 1845; matchRecogPatternConcat();
				}
				}
				State = 1850;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternConcatContext : ParserRuleContext {
		public MatchRecogPatternUnaryContext[] matchRecogPatternUnary() {
			return GetRuleContexts<MatchRecogPatternUnaryContext>();
		}
		public MatchRecogPatternUnaryContext matchRecogPatternUnary(int i) {
			return GetRuleContext<MatchRecogPatternUnaryContext>(i);
		}
		public MatchRecogPatternConcatContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternConcat; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternConcat(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternConcat(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternConcat(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternConcatContext matchRecogPatternConcat() {
		MatchRecogPatternConcatContext _localctx = new MatchRecogPatternConcatContext(_ctx, State);
		EnterRule(_localctx, 262, RULE_matchRecogPatternConcat);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1852;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1851; matchRecogPatternUnary();
				}
				}
				State = 1854;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==MATCH_RECOGNIZE_PERMUTE || _la==LPAREN || _la==IDENT );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternUnaryContext : ParserRuleContext {
		public MatchRecogPatternPermuteContext matchRecogPatternPermute() {
			return GetRuleContext<MatchRecogPatternPermuteContext>(0);
		}
		public MatchRecogPatternNestedContext matchRecogPatternNested() {
			return GetRuleContext<MatchRecogPatternNestedContext>(0);
		}
		public MatchRecogPatternAtomContext matchRecogPatternAtom() {
			return GetRuleContext<MatchRecogPatternAtomContext>(0);
		}
		public MatchRecogPatternUnaryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternUnary; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternUnary(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternUnary(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternUnary(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternUnaryContext matchRecogPatternUnary() {
		MatchRecogPatternUnaryContext _localctx = new MatchRecogPatternUnaryContext(_ctx, State);
		EnterRule(_localctx, 264, RULE_matchRecogPatternUnary);
		try {
			State = 1859;
			switch (_input.La(1)) {
			case MATCH_RECOGNIZE_PERMUTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1856; matchRecogPatternPermute();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1857; matchRecogPatternNested();
				}
				break;
			case IDENT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1858; matchRecogPatternAtom();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternNestedContext : ParserRuleContext {
		public IToken s;
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public MatchRecogPatternAlterationContext matchRecogPatternAlteration() {
			return GetRuleContext<MatchRecogPatternAlterationContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public MatchRecogPatternRepeatContext matchRecogPatternRepeat() {
			return GetRuleContext<MatchRecogPatternRepeatContext>(0);
		}
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode PLUS() { return GetToken(EsperEPL2GrammarParser.PLUS, 0); }
		public ITerminalNode QUESTION() { return GetToken(EsperEPL2GrammarParser.QUESTION, 0); }
		public MatchRecogPatternNestedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternNested; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternNested(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternNested(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternNested(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternNestedContext matchRecogPatternNested() {
		MatchRecogPatternNestedContext _localctx = new MatchRecogPatternNestedContext(_ctx, State);
		EnterRule(_localctx, 266, RULE_matchRecogPatternNested);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1861; Match(LPAREN);
			State = 1862; matchRecogPatternAlteration();
			State = 1863; Match(RPAREN);
			State = 1867;
			switch (_input.La(1)) {
			case STAR:
				{
				State = 1864; _localctx.s = Match(STAR);
				}
				break;
			case PLUS:
				{
				State = 1865; _localctx.s = Match(PLUS);
				}
				break;
			case QUESTION:
				{
				State = 1866; _localctx.s = Match(QUESTION);
				}
				break;
			case MATCH_RECOGNIZE_PERMUTE:
			case LPAREN:
			case RPAREN:
			case LCURLY:
			case COMMA:
			case BOR:
			case IDENT:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1870;
			_la = _input.La(1);
			if (_la==LCURLY) {
				{
				State = 1869; matchRecogPatternRepeat();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternPermuteContext : ParserRuleContext {
		public ITerminalNode MATCH_RECOGNIZE_PERMUTE() { return GetToken(EsperEPL2GrammarParser.MATCH_RECOGNIZE_PERMUTE, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public MatchRecogPatternAlterationContext[] matchRecogPatternAlteration() {
			return GetRuleContexts<MatchRecogPatternAlterationContext>();
		}
		public MatchRecogPatternAlterationContext matchRecogPatternAlteration(int i) {
			return GetRuleContext<MatchRecogPatternAlterationContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public MatchRecogPatternPermuteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternPermute; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternPermute(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternPermute(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternPermute(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternPermuteContext matchRecogPatternPermute() {
		MatchRecogPatternPermuteContext _localctx = new MatchRecogPatternPermuteContext(_ctx, State);
		EnterRule(_localctx, 268, RULE_matchRecogPatternPermute);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1872; Match(MATCH_RECOGNIZE_PERMUTE);
			State = 1873; Match(LPAREN);
			State = 1874; matchRecogPatternAlteration();
			State = 1879;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1875; Match(COMMA);
				State = 1876; matchRecogPatternAlteration();
				}
				}
				State = 1881;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1882; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternAtomContext : ParserRuleContext {
		public IToken i;
		public IToken s;
		public IToken reluctant;
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MatchRecogPatternRepeatContext matchRecogPatternRepeat() {
			return GetRuleContext<MatchRecogPatternRepeatContext>(0);
		}
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode PLUS() { return GetToken(EsperEPL2GrammarParser.PLUS, 0); }
		public ITerminalNode[] QUESTION() { return GetTokens(EsperEPL2GrammarParser.QUESTION); }
		public ITerminalNode QUESTION(int i) {
			return GetToken(EsperEPL2GrammarParser.QUESTION, i);
		}
		public MatchRecogPatternAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternAtom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternAtomContext matchRecogPatternAtom() {
		MatchRecogPatternAtomContext _localctx = new MatchRecogPatternAtomContext(_ctx, State);
		EnterRule(_localctx, 270, RULE_matchRecogPatternAtom);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1884; _localctx.i = Match(IDENT);
			State = 1893;
			_la = _input.La(1);
			if (((((_la - 140)) & ~0x3f) == 0 && ((1L << (_la - 140)) & ((1L << (QUESTION - 140)) | (1L << (PLUS - 140)) | (1L << (STAR - 140)))) != 0)) {
				{
				State = 1888;
				switch (_input.La(1)) {
				case STAR:
					{
					State = 1885; _localctx.s = Match(STAR);
					}
					break;
				case PLUS:
					{
					State = 1886; _localctx.s = Match(PLUS);
					}
					break;
				case QUESTION:
					{
					State = 1887; _localctx.s = Match(QUESTION);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1891;
				_la = _input.La(1);
				if (_la==QUESTION) {
					{
					State = 1890; _localctx.reluctant = Match(QUESTION);
					}
				}

				}
			}

			State = 1896;
			_la = _input.La(1);
			if (_la==LCURLY) {
				{
				State = 1895; matchRecogPatternRepeat();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogPatternRepeatContext : ParserRuleContext {
		public ExpressionContext e1;
		public IToken comma;
		public ExpressionContext e2;
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public MatchRecogPatternRepeatContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogPatternRepeat; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogPatternRepeat(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogPatternRepeat(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogPatternRepeat(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogPatternRepeatContext matchRecogPatternRepeat() {
		MatchRecogPatternRepeatContext _localctx = new MatchRecogPatternRepeatContext(_ctx, State);
		EnterRule(_localctx, 272, RULE_matchRecogPatternRepeat);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1898; Match(LCURLY);
			State = 1900;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,239,_ctx) ) {
			case 1:
				{
				State = 1899; _localctx.e1 = expression();
				}
				break;
			}
			State = 1903;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 1902; _localctx.comma = Match(COMMA);
				}
			}

			State = 1906;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
				{
				State = 1905; _localctx.e2 = expression();
				}
			}

			State = 1908; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogDefineContext : ParserRuleContext {
		public ITerminalNode DEFINE() { return GetToken(EsperEPL2GrammarParser.DEFINE, 0); }
		public MatchRecogDefineItemContext[] matchRecogDefineItem() {
			return GetRuleContexts<MatchRecogDefineItemContext>();
		}
		public MatchRecogDefineItemContext matchRecogDefineItem(int i) {
			return GetRuleContext<MatchRecogDefineItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public MatchRecogDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogDefine; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogDefine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogDefine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogDefineContext matchRecogDefine() {
		MatchRecogDefineContext _localctx = new MatchRecogDefineContext(_ctx, State);
		EnterRule(_localctx, 274, RULE_matchRecogDefine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1910; Match(DEFINE);
			State = 1911; matchRecogDefineItem();
			State = 1916;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1912; Match(COMMA);
				State = 1913; matchRecogDefineItem();
				}
				}
				State = 1918;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchRecogDefineItemContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MatchRecogDefineItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchRecogDefineItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchRecogDefineItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchRecogDefineItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchRecogDefineItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchRecogDefineItemContext matchRecogDefineItem() {
		MatchRecogDefineItemContext _localctx = new MatchRecogDefineItemContext(_ctx, State);
		EnterRule(_localctx, 276, RULE_matchRecogDefineItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1919; _localctx.i = Match(IDENT);
			State = 1920; Match(AS);
			State = 1921; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public CaseExpressionContext caseExpression() {
			return GetRuleContext<CaseExpressionContext>(0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(_ctx, State);
		EnterRule(_localctx, 278, RULE_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1923; caseExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseExpressionContext : ParserRuleContext {
		public ITerminalNode CASE() { return GetToken(EsperEPL2GrammarParser.CASE, 0); }
		public ITerminalNode END() { return GetToken(EsperEPL2GrammarParser.END, 0); }
		public WhenClauseContext[] whenClause() {
			return GetRuleContexts<WhenClauseContext>();
		}
		public WhenClauseContext whenClause(int i) {
			return GetRuleContext<WhenClauseContext>(i);
		}
		public ElseClauseContext elseClause() {
			return GetRuleContext<ElseClauseContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public EvalOrExpressionContext evalOrExpression() {
			return GetRuleContext<EvalOrExpressionContext>(0);
		}
		public CaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterCaseExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitCaseExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseExpressionContext caseExpression() {
		CaseExpressionContext _localctx = new CaseExpressionContext(_ctx, State);
		EnterRule(_localctx, 280, RULE_caseExpression);
		int _la;
		try {
			State = 1953;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,247,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				 paraphrases.Push("case expression"); 
				State = 1926; Match(CASE);
				State = 1928;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 1927; whenClause();
					}
					}
					State = 1930;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( _la==WHEN );
				State = 1933;
				_la = _input.La(1);
				if (_la==ELSE) {
					{
					State = 1932; elseClause();
					}
				}

				State = 1935; Match(END);
				 paraphrases.Pop(); 
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				 paraphrases.Push("case expression"); 
				State = 1939; Match(CASE);
				State = 1940; expression();
				State = 1942;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 1941; whenClause();
					}
					}
					State = 1944;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( _la==WHEN );
				State = 1947;
				_la = _input.La(1);
				if (_la==ELSE) {
					{
					State = 1946; elseClause();
					}
				}

				State = 1949; Match(END);
				 paraphrases.Pop(); 
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1952; evalOrExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvalOrExpressionContext : ParserRuleContext {
		public IToken op;
		public EvalAndExpressionContext[] evalAndExpression() {
			return GetRuleContexts<EvalAndExpressionContext>();
		}
		public EvalAndExpressionContext evalAndExpression(int i) {
			return GetRuleContext<EvalAndExpressionContext>(i);
		}
		public ITerminalNode[] OR_EXPR() { return GetTokens(EsperEPL2GrammarParser.OR_EXPR); }
		public ITerminalNode OR_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.OR_EXPR, i);
		}
		public EvalOrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evalOrExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEvalOrExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEvalOrExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvalOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EvalOrExpressionContext evalOrExpression() {
		EvalOrExpressionContext _localctx = new EvalOrExpressionContext(_ctx, State);
		EnterRule(_localctx, 282, RULE_evalOrExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1955; evalAndExpression();
			State = 1960;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==OR_EXPR) {
				{
				{
				State = 1956; _localctx.op = Match(OR_EXPR);
				State = 1957; evalAndExpression();
				}
				}
				State = 1962;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvalAndExpressionContext : ParserRuleContext {
		public IToken op;
		public BitWiseExpressionContext[] bitWiseExpression() {
			return GetRuleContexts<BitWiseExpressionContext>();
		}
		public BitWiseExpressionContext bitWiseExpression(int i) {
			return GetRuleContext<BitWiseExpressionContext>(i);
		}
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public EvalAndExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evalAndExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEvalAndExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEvalAndExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvalAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EvalAndExpressionContext evalAndExpression() {
		EvalAndExpressionContext _localctx = new EvalAndExpressionContext(_ctx, State);
		EnterRule(_localctx, 284, RULE_evalAndExpression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1963; bitWiseExpression();
			State = 1968;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,249,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1964; _localctx.op = Match(AND_EXPR);
					State = 1965; bitWiseExpression();
					}
					} 
				}
				State = 1970;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,249,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitWiseExpressionContext : ParserRuleContext {
		public NegatedExpressionContext[] negatedExpression() {
			return GetRuleContexts<NegatedExpressionContext>();
		}
		public NegatedExpressionContext negatedExpression(int i) {
			return GetRuleContext<NegatedExpressionContext>(i);
		}
		public ITerminalNode[] BAND() { return GetTokens(EsperEPL2GrammarParser.BAND); }
		public ITerminalNode BAND(int i) {
			return GetToken(EsperEPL2GrammarParser.BAND, i);
		}
		public ITerminalNode[] BOR() { return GetTokens(EsperEPL2GrammarParser.BOR); }
		public ITerminalNode BOR(int i) {
			return GetToken(EsperEPL2GrammarParser.BOR, i);
		}
		public ITerminalNode[] BXOR() { return GetTokens(EsperEPL2GrammarParser.BXOR); }
		public ITerminalNode BXOR(int i) {
			return GetToken(EsperEPL2GrammarParser.BXOR, i);
		}
		public BitWiseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitWiseExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBitWiseExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBitWiseExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitWiseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BitWiseExpressionContext bitWiseExpression() {
		BitWiseExpressionContext _localctx = new BitWiseExpressionContext(_ctx, State);
		EnterRule(_localctx, 286, RULE_bitWiseExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1971; negatedExpression();
			State = 1976;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (((((_la - 169)) & ~0x3f) == 0 && ((1L << (_la - 169)) & ((1L << (BXOR - 169)) | (1L << (BOR - 169)) | (1L << (BAND - 169)))) != 0)) {
				{
				{
				State = 1972;
				_la = _input.La(1);
				if ( !(((((_la - 169)) & ~0x3f) == 0 && ((1L << (_la - 169)) & ((1L << (BXOR - 169)) | (1L << (BOR - 169)) | (1L << (BAND - 169)))) != 0)) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 1973; negatedExpression();
				}
				}
				State = 1978;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NegatedExpressionContext : ParserRuleContext {
		public EvalEqualsExpressionContext evalEqualsExpression() {
			return GetRuleContext<EvalEqualsExpressionContext>(0);
		}
		public ITerminalNode NOT_EXPR() { return GetToken(EsperEPL2GrammarParser.NOT_EXPR, 0); }
		public NegatedExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_negatedExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNegatedExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNegatedExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNegatedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NegatedExpressionContext negatedExpression() {
		NegatedExpressionContext _localctx = new NegatedExpressionContext(_ctx, State);
		EnterRule(_localctx, 288, RULE_negatedExpression);
		try {
			State = 1982;
			switch (_input.La(1)) {
			case WINDOW:
			case ESCAPE:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case ISTREAM:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PREVIOUSCOUNT:
			case PREVIOUSWINDOW:
			case PRIOR:
			case EXISTS:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case CURRENT_TIMESTAMP:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case NEWKW:
			case CONTEXT:
			case GROUPING:
			case GROUPING_ID:
			case QUESTION:
			case LPAREN:
			case LCURLY:
			case PLUS:
			case MINUS:
			case TICKED_STRING_LITERAL:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IDENT:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1979; evalEqualsExpression();
				}
				break;
			case NOT_EXPR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1980; Match(NOT_EXPR);
				State = 1981; evalEqualsExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvalEqualsExpressionContext : ParserRuleContext {
		public IToken eq;
		public IToken @is;
		public IToken isnot;
		public IToken sqlne;
		public IToken ne;
		public IToken a;
		public EvalRelationalExpressionContext[] evalRelationalExpression() {
			return GetRuleContexts<EvalRelationalExpressionContext>();
		}
		public EvalRelationalExpressionContext evalRelationalExpression(int i) {
			return GetRuleContext<EvalRelationalExpressionContext>(i);
		}
		public ITerminalNode[] NOT_EXPR() { return GetTokens(EsperEPL2GrammarParser.NOT_EXPR); }
		public ITerminalNode NOT_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.NOT_EXPR, i);
		}
		public ITerminalNode[] EQUALS() { return GetTokens(EsperEPL2GrammarParser.EQUALS); }
		public ITerminalNode EQUALS(int i) {
			return GetToken(EsperEPL2GrammarParser.EQUALS, i);
		}
		public ITerminalNode[] IS() { return GetTokens(EsperEPL2GrammarParser.IS); }
		public ITerminalNode IS(int i) {
			return GetToken(EsperEPL2GrammarParser.IS, i);
		}
		public ITerminalNode[] SQL_NE() { return GetTokens(EsperEPL2GrammarParser.SQL_NE); }
		public ITerminalNode SQL_NE(int i) {
			return GetToken(EsperEPL2GrammarParser.SQL_NE, i);
		}
		public ITerminalNode[] NOT_EQUAL() { return GetTokens(EsperEPL2GrammarParser.NOT_EQUAL); }
		public ITerminalNode NOT_EQUAL(int i) {
			return GetToken(EsperEPL2GrammarParser.NOT_EQUAL, i);
		}
		public SubSelectGroupExpressionContext[] subSelectGroupExpression() {
			return GetRuleContexts<SubSelectGroupExpressionContext>();
		}
		public SubSelectGroupExpressionContext subSelectGroupExpression(int i) {
			return GetRuleContext<SubSelectGroupExpressionContext>(i);
		}
		public ITerminalNode[] ANY() { return GetTokens(EsperEPL2GrammarParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(EsperEPL2GrammarParser.ANY, i);
		}
		public ITerminalNode[] SOME() { return GetTokens(EsperEPL2GrammarParser.SOME); }
		public ITerminalNode SOME(int i) {
			return GetToken(EsperEPL2GrammarParser.SOME, i);
		}
		public ITerminalNode[] ALL() { return GetTokens(EsperEPL2GrammarParser.ALL); }
		public ITerminalNode ALL(int i) {
			return GetToken(EsperEPL2GrammarParser.ALL, i);
		}
		public ITerminalNode[] LPAREN() { return GetTokens(EsperEPL2GrammarParser.LPAREN); }
		public ITerminalNode LPAREN(int i) {
			return GetToken(EsperEPL2GrammarParser.LPAREN, i);
		}
		public ITerminalNode[] RPAREN() { return GetTokens(EsperEPL2GrammarParser.RPAREN); }
		public ITerminalNode RPAREN(int i) {
			return GetToken(EsperEPL2GrammarParser.RPAREN, i);
		}
		public ExpressionListContext[] expressionList() {
			return GetRuleContexts<ExpressionListContext>();
		}
		public ExpressionListContext expressionList(int i) {
			return GetRuleContext<ExpressionListContext>(i);
		}
		public EvalEqualsExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evalEqualsExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEvalEqualsExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEvalEqualsExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvalEqualsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EvalEqualsExpressionContext evalEqualsExpression() {
		EvalEqualsExpressionContext _localctx = new EvalEqualsExpressionContext(_ctx, State);
		EnterRule(_localctx, 290, RULE_evalEqualsExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1984; evalRelationalExpression();
			State = 2011;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==IS || ((((_la - 138)) & ~0x3f) == 0 && ((1L << (_la - 138)) & ((1L << (EQUALS - 138)) | (1L << (SQL_NE - 138)) | (1L << (NOT_EQUAL - 138)))) != 0)) {
				{
				{
				State = 1991;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,252,_ctx) ) {
				case 1:
					{
					State = 1985; _localctx.eq = Match(EQUALS);
					}
					break;

				case 2:
					{
					State = 1986; _localctx.@is = Match(IS);
					}
					break;

				case 3:
					{
					State = 1987; _localctx.isnot = Match(IS);
					State = 1988; Match(NOT_EXPR);
					}
					break;

				case 4:
					{
					State = 1989; _localctx.sqlne = Match(SQL_NE);
					}
					break;

				case 5:
					{
					State = 1990; _localctx.ne = Match(NOT_EQUAL);
					}
					break;
				}
				State = 2007;
				switch (_input.La(1)) {
				case WINDOW:
				case ESCAPE:
				case EVERY_EXPR:
				case SUM:
				case AVG:
				case MAX:
				case MIN:
				case COALESCE:
				case MEDIAN:
				case STDDEV:
				case AVEDEV:
				case COUNT:
				case OUTER:
				case JOIN:
				case LEFT:
				case RIGHT:
				case FULL:
				case EVENTS:
				case FIRST:
				case LAST:
				case ISTREAM:
				case UNIDIRECTIONAL:
				case RETAINUNION:
				case RETAININTERSECTION:
				case PATTERN:
				case SQL:
				case METADATASQL:
				case PREVIOUS:
				case PREVIOUSTAIL:
				case PREVIOUSCOUNT:
				case PREVIOUSWINDOW:
				case PRIOR:
				case EXISTS:
				case WEEKDAY:
				case LW:
				case INSTANCEOF:
				case TYPEOF:
				case CAST:
				case CURRENT_TIMESTAMP:
				case SNAPSHOT:
				case VARIABLE:
				case TABLE:
				case UNTIL:
				case AT:
				case INDEX:
				case BOOLEAN_TRUE:
				case BOOLEAN_FALSE:
				case VALUE_NULL:
				case DEFINE:
				case PARTITION:
				case MATCHES:
				case FOR:
				case WHILE:
				case USING:
				case MERGE:
				case MATCHED:
				case NEWKW:
				case CONTEXT:
				case GROUPING:
				case GROUPING_ID:
				case QUESTION:
				case LPAREN:
				case LCURLY:
				case PLUS:
				case MINUS:
				case TICKED_STRING_LITERAL:
				case QUOTED_STRING_LITERAL:
				case STRING_LITERAL:
				case IDENT:
				case IntegerLiteral:
				case FloatingPointLiteral:
					{
					State = 1993; evalRelationalExpression();
					}
					break;
				case ALL:
				case ANY:
				case SOME:
					{
					State = 1997;
					switch (_input.La(1)) {
					case ANY:
						{
						State = 1994; _localctx.a = Match(ANY);
						}
						break;
					case SOME:
						{
						State = 1995; _localctx.a = Match(SOME);
						}
						break;
					case ALL:
						{
						State = 1996; _localctx.a = Match(ALL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2005;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,255,_ctx) ) {
					case 1:
						{
						{
						State = 1999; Match(LPAREN);
						State = 2001;
						_la = _input.La(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
							{
							State = 2000; expressionList();
							}
						}

						State = 2003; Match(RPAREN);
						}
						}
						break;

					case 2:
						{
						State = 2004; subSelectGroupExpression();
						}
						break;
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				}
				State = 2013;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EvalRelationalExpressionContext : ParserRuleContext {
		public IToken r;
		public IToken g;
		public IToken n;
		public IToken @in;
		public IToken l;
		public IToken col;
		public IToken inset;
		public IToken between;
		public IToken like;
		public IToken regex;
		public ConcatenationExprContext[] concatenationExpr() {
			return GetRuleContexts<ConcatenationExprContext>();
		}
		public ConcatenationExprContext concatenationExpr(int i) {
			return GetRuleContext<ConcatenationExprContext>(i);
		}
		public InSubSelectQueryContext inSubSelectQuery() {
			return GetRuleContext<InSubSelectQueryContext>(0);
		}
		public BetweenListContext betweenList() {
			return GetRuleContext<BetweenListContext>(0);
		}
		public ITerminalNode IN_SET() { return GetToken(EsperEPL2GrammarParser.IN_SET, 0); }
		public ITerminalNode BETWEEN() { return GetToken(EsperEPL2GrammarParser.BETWEEN, 0); }
		public ITerminalNode LIKE() { return GetToken(EsperEPL2GrammarParser.LIKE, 0); }
		public ITerminalNode REGEXP() { return GetToken(EsperEPL2GrammarParser.REGEXP, 0); }
		public ITerminalNode NOT_EXPR() { return GetToken(EsperEPL2GrammarParser.NOT_EXPR, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode ESCAPE() { return GetToken(EsperEPL2GrammarParser.ESCAPE, 0); }
		public StringconstantContext stringconstant() {
			return GetRuleContext<StringconstantContext>(0);
		}
		public ITerminalNode[] LPAREN() { return GetTokens(EsperEPL2GrammarParser.LPAREN); }
		public ITerminalNode LPAREN(int i) {
			return GetToken(EsperEPL2GrammarParser.LPAREN, i);
		}
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode[] RPAREN() { return GetTokens(EsperEPL2GrammarParser.RPAREN); }
		public ITerminalNode RPAREN(int i) {
			return GetToken(EsperEPL2GrammarParser.RPAREN, i);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode[] LT() { return GetTokens(EsperEPL2GrammarParser.LT); }
		public ITerminalNode LT(int i) {
			return GetToken(EsperEPL2GrammarParser.LT, i);
		}
		public ITerminalNode[] GT() { return GetTokens(EsperEPL2GrammarParser.GT); }
		public ITerminalNode GT(int i) {
			return GetToken(EsperEPL2GrammarParser.GT, i);
		}
		public ITerminalNode[] LE() { return GetTokens(EsperEPL2GrammarParser.LE); }
		public ITerminalNode LE(int i) {
			return GetToken(EsperEPL2GrammarParser.LE, i);
		}
		public ITerminalNode[] GE() { return GetTokens(EsperEPL2GrammarParser.GE); }
		public ITerminalNode GE(int i) {
			return GetToken(EsperEPL2GrammarParser.GE, i);
		}
		public SubSelectGroupExpressionContext[] subSelectGroupExpression() {
			return GetRuleContexts<SubSelectGroupExpressionContext>();
		}
		public SubSelectGroupExpressionContext subSelectGroupExpression(int i) {
			return GetRuleContext<SubSelectGroupExpressionContext>(i);
		}
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode[] ANY() { return GetTokens(EsperEPL2GrammarParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(EsperEPL2GrammarParser.ANY, i);
		}
		public ITerminalNode[] SOME() { return GetTokens(EsperEPL2GrammarParser.SOME); }
		public ITerminalNode SOME(int i) {
			return GetToken(EsperEPL2GrammarParser.SOME, i);
		}
		public ITerminalNode[] ALL() { return GetTokens(EsperEPL2GrammarParser.ALL); }
		public ITerminalNode ALL(int i) {
			return GetToken(EsperEPL2GrammarParser.ALL, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionListContext[] expressionList() {
			return GetRuleContexts<ExpressionListContext>();
		}
		public ExpressionListContext expressionList(int i) {
			return GetRuleContext<ExpressionListContext>(i);
		}
		public EvalRelationalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_evalRelationalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEvalRelationalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEvalRelationalExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEvalRelationalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EvalRelationalExpressionContext evalRelationalExpression() {
		EvalRelationalExpressionContext _localctx = new EvalRelationalExpressionContext(_ctx, State);
		EnterRule(_localctx, 292, RULE_evalRelationalExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2014; concatenationExpr();
			State = 2080;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,271,_ctx) ) {
			case 1:
				{
				{
				State = 2039;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (((((_la - 165)) & ~0x3f) == 0 && ((1L << (_la - 165)) & ((1L << (GE - 165)) | (1L << (GT - 165)) | (1L << (LE - 165)) | (1L << (LT - 165)))) != 0)) {
					{
					{
					State = 2019;
					switch (_input.La(1)) {
					case LT:
						{
						State = 2015; _localctx.r = Match(LT);
						}
						break;
					case GT:
						{
						State = 2016; _localctx.r = Match(GT);
						}
						break;
					case LE:
						{
						State = 2017; _localctx.r = Match(LE);
						}
						break;
					case GE:
						{
						State = 2018; _localctx.r = Match(GE);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2035;
					switch (_input.La(1)) {
					case WINDOW:
					case ESCAPE:
					case EVERY_EXPR:
					case SUM:
					case AVG:
					case MAX:
					case MIN:
					case COALESCE:
					case MEDIAN:
					case STDDEV:
					case AVEDEV:
					case COUNT:
					case OUTER:
					case JOIN:
					case LEFT:
					case RIGHT:
					case FULL:
					case EVENTS:
					case FIRST:
					case LAST:
					case ISTREAM:
					case UNIDIRECTIONAL:
					case RETAINUNION:
					case RETAININTERSECTION:
					case PATTERN:
					case SQL:
					case METADATASQL:
					case PREVIOUS:
					case PREVIOUSTAIL:
					case PREVIOUSCOUNT:
					case PREVIOUSWINDOW:
					case PRIOR:
					case EXISTS:
					case WEEKDAY:
					case LW:
					case INSTANCEOF:
					case TYPEOF:
					case CAST:
					case CURRENT_TIMESTAMP:
					case SNAPSHOT:
					case VARIABLE:
					case TABLE:
					case UNTIL:
					case AT:
					case INDEX:
					case BOOLEAN_TRUE:
					case BOOLEAN_FALSE:
					case VALUE_NULL:
					case DEFINE:
					case PARTITION:
					case MATCHES:
					case FOR:
					case WHILE:
					case USING:
					case MERGE:
					case MATCHED:
					case NEWKW:
					case CONTEXT:
					case GROUPING:
					case GROUPING_ID:
					case QUESTION:
					case LPAREN:
					case LCURLY:
					case PLUS:
					case MINUS:
					case TICKED_STRING_LITERAL:
					case QUOTED_STRING_LITERAL:
					case STRING_LITERAL:
					case IDENT:
					case IntegerLiteral:
					case FloatingPointLiteral:
						{
						State = 2021; concatenationExpr();
						}
						break;
					case ALL:
					case ANY:
					case SOME:
						{
						State = 2025;
						switch (_input.La(1)) {
						case ANY:
							{
							State = 2022; _localctx.g = Match(ANY);
							}
							break;
						case SOME:
							{
							State = 2023; _localctx.g = Match(SOME);
							}
							break;
						case ALL:
							{
							State = 2024; _localctx.g = Match(ALL);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 2033;
						_errHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(_input,261,_ctx) ) {
						case 1:
							{
							{
							State = 2027; Match(LPAREN);
							State = 2029;
							_la = _input.La(1);
							if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
								{
								State = 2028; expressionList();
								}
							}

							State = 2031; Match(RPAREN);
							}
							}
							break;

						case 2:
							{
							State = 2032; subSelectGroupExpression();
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					}
					State = 2041;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				}
				break;

			case 2:
				{
				State = 2043;
				_la = _input.La(1);
				if (_la==NOT_EXPR) {
					{
					State = 2042; _localctx.n = Match(NOT_EXPR);
					}
				}

				State = 2078;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,270,_ctx) ) {
				case 1:
					{
					{
					State = 2045; _localctx.@in = Match(IN_SET);
					State = 2048;
					switch (_input.La(1)) {
					case LPAREN:
						{
						State = 2046; _localctx.l = Match(LPAREN);
						}
						break;
					case LBRACK:
						{
						State = 2047; _localctx.l = Match(LBRACK);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2050; expression();
					State = 2060;
					switch (_input.La(1)) {
					case COLON:
						{
						{
						State = 2051; _localctx.col = Match(COLON);
						{
						State = 2052; expression();
						}
						}
						}
						break;
					case RPAREN:
					case RBRACK:
					case COMMA:
						{
						{
						State = 2057;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==COMMA) {
							{
							{
							State = 2053; Match(COMMA);
							State = 2054; expression();
							}
							}
							State = 2059;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 2064;
					switch (_input.La(1)) {
					case RPAREN:
						{
						State = 2062; _localctx.r = Match(RPAREN);
						}
						break;
					case RBRACK:
						{
						State = 2063; _localctx.r = Match(RBRACK);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					}
					break;

				case 2:
					{
					State = 2066; _localctx.inset = Match(IN_SET);
					State = 2067; inSubSelectQuery();
					}
					break;

				case 3:
					{
					State = 2068; _localctx.between = Match(BETWEEN);
					State = 2069; betweenList();
					}
					break;

				case 4:
					{
					State = 2070; _localctx.like = Match(LIKE);
					State = 2071; concatenationExpr();
					State = 2074;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,269,_ctx) ) {
					case 1:
						{
						State = 2072; Match(ESCAPE);
						State = 2073; stringconstant();
						}
						break;
					}
					}
					break;

				case 5:
					{
					State = 2076; _localctx.regex = Match(REGEXP);
					State = 2077; concatenationExpr();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InSubSelectQueryContext : ParserRuleContext {
		public SubQueryExprContext subQueryExpr() {
			return GetRuleContext<SubQueryExprContext>(0);
		}
		public InSubSelectQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inSubSelectQuery; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterInSubSelectQuery(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitInSubSelectQuery(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInSubSelectQuery(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InSubSelectQueryContext inSubSelectQuery() {
		InSubSelectQueryContext _localctx = new InSubSelectQueryContext(_ctx, State);
		EnterRule(_localctx, 294, RULE_inSubSelectQuery);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2082; subQueryExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConcatenationExprContext : ParserRuleContext {
		public IToken c;
		public AdditiveExpressionContext[] additiveExpression() {
			return GetRuleContexts<AdditiveExpressionContext>();
		}
		public AdditiveExpressionContext additiveExpression(int i) {
			return GetRuleContext<AdditiveExpressionContext>(i);
		}
		public ITerminalNode[] LOR() { return GetTokens(EsperEPL2GrammarParser.LOR); }
		public ITerminalNode LOR(int i) {
			return GetToken(EsperEPL2GrammarParser.LOR, i);
		}
		public ConcatenationExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenationExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterConcatenationExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitConcatenationExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatenationExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConcatenationExprContext concatenationExpr() {
		ConcatenationExprContext _localctx = new ConcatenationExprContext(_ctx, State);
		EnterRule(_localctx, 296, RULE_concatenationExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2084; additiveExpression();
			State = 2094;
			_la = _input.La(1);
			if (_la==LOR) {
				{
				State = 2085; _localctx.c = Match(LOR);
				State = 2086; additiveExpression();
				State = 2091;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==LOR) {
					{
					{
					State = 2087; Match(LOR);
					State = 2088; additiveExpression();
					}
					}
					State = 2093;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AdditiveExpressionContext : ParserRuleContext {
		public MultiplyExpressionContext[] multiplyExpression() {
			return GetRuleContexts<MultiplyExpressionContext>();
		}
		public MultiplyExpressionContext multiplyExpression(int i) {
			return GetRuleContext<MultiplyExpressionContext>(i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(EsperEPL2GrammarParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(EsperEPL2GrammarParser.PLUS, i);
		}
		public ITerminalNode[] MINUS() { return GetTokens(EsperEPL2GrammarParser.MINUS); }
		public ITerminalNode MINUS(int i) {
			return GetToken(EsperEPL2GrammarParser.MINUS, i);
		}
		public AdditiveExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additiveExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterAdditiveExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitAdditiveExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditiveExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdditiveExpressionContext additiveExpression() {
		AdditiveExpressionContext _localctx = new AdditiveExpressionContext(_ctx, State);
		EnterRule(_localctx, 298, RULE_additiveExpression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2096; multiplyExpression();
			State = 2101;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,274,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2097;
					_la = _input.La(1);
					if ( !(_la==PLUS || _la==MINUS) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					State = 2098; multiplyExpression();
					}
					} 
				}
				State = 2103;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,274,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplyExpressionContext : ParserRuleContext {
		public UnaryExpressionContext[] unaryExpression() {
			return GetRuleContexts<UnaryExpressionContext>();
		}
		public UnaryExpressionContext unaryExpression(int i) {
			return GetRuleContext<UnaryExpressionContext>(i);
		}
		public ITerminalNode[] STAR() { return GetTokens(EsperEPL2GrammarParser.STAR); }
		public ITerminalNode STAR(int i) {
			return GetToken(EsperEPL2GrammarParser.STAR, i);
		}
		public ITerminalNode[] DIV() { return GetTokens(EsperEPL2GrammarParser.DIV); }
		public ITerminalNode DIV(int i) {
			return GetToken(EsperEPL2GrammarParser.DIV, i);
		}
		public ITerminalNode[] MOD() { return GetTokens(EsperEPL2GrammarParser.MOD); }
		public ITerminalNode MOD(int i) {
			return GetToken(EsperEPL2GrammarParser.MOD, i);
		}
		public MultiplyExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplyExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMultiplyExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMultiplyExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplyExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplyExpressionContext multiplyExpression() {
		MultiplyExpressionContext _localctx = new MultiplyExpressionContext(_ctx, State);
		EnterRule(_localctx, 300, RULE_multiplyExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2104; unaryExpression();
			State = 2109;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (((((_la - 153)) & ~0x3f) == 0 && ((1L << (_la - 153)) & ((1L << (DIV - 153)) | (1L << (STAR - 153)) | (1L << (MOD - 153)))) != 0)) {
				{
				{
				State = 2105;
				_la = _input.La(1);
				if ( !(((((_la - 153)) & ~0x3f) == 0 && ((1L << (_la - 153)) & ((1L << (DIV - 153)) | (1L << (STAR - 153)) | (1L << (MOD - 153)))) != 0)) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 2106; unaryExpression();
				}
				}
				State = 2111;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryExpressionContext : ParserRuleContext {
		public IToken inner;
		public IToken b;
		public ITerminalNode MINUS() { return GetToken(EsperEPL2GrammarParser.MINUS, 0); }
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public SubstitutionCanChainContext substitutionCanChain() {
			return GetRuleContext<SubstitutionCanChainContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public BuiltinFuncContext builtinFunc() {
			return GetRuleContext<BuiltinFuncContext>(0);
		}
		public EventPropertyOrLibFunctionContext eventPropertyOrLibFunction() {
			return GetRuleContext<EventPropertyOrLibFunctionContext>(0);
		}
		public ArrayExpressionContext arrayExpression() {
			return GetRuleContext<ArrayExpressionContext>(0);
		}
		public RowSubSelectExpressionContext rowSubSelectExpression() {
			return GetRuleContext<RowSubSelectExpressionContext>(0);
		}
		public ExistsSubSelectExpressionContext existsSubSelectExpression() {
			return GetRuleContext<ExistsSubSelectExpressionContext>(0);
		}
		public ITerminalNode NEWKW() { return GetToken(EsperEPL2GrammarParser.NEWKW, 0); }
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public NewAssignContext[] newAssign() {
			return GetRuleContexts<NewAssignContext>();
		}
		public NewAssignContext newAssign(int i) {
			return GetRuleContext<NewAssignContext>(i);
		}
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public JsonobjectContext jsonobject() {
			return GetRuleContext<JsonobjectContext>(0);
		}
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryExpressionContext unaryExpression() {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(_ctx, State);
		EnterRule(_localctx, 302, RULE_unaryExpression);
		int _la;
		try {
			State = 2171;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,283,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2112; Match(MINUS);
				State = 2113; eventProperty();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2114; constant();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2115; substitutionCanChain();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2116; _localctx.inner = Match(LPAREN);
				State = 2117; expression();
				State = 2118; Match(RPAREN);
				State = 2120;
				_la = _input.La(1);
				if (_la==DOT) {
					{
					State = 2119; chainedFunction();
					}
				}

				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2122; builtinFunc();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2123; eventPropertyOrLibFunction();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2124; arrayExpression();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2125; rowSubSelectExpression();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2126; existsSubSelectExpression();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2127; Match(NEWKW);
				State = 2128; Match(LCURLY);
				State = 2129; newAssign();
				State = 2134;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2130; Match(COMMA);
					State = 2131; newAssign();
					}
					}
					State = 2136;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2137; Match(RCURLY);
				}
				break;

			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2139; Match(NEWKW);
				State = 2140; classIdentifier();
				State = 2141; Match(LPAREN);
				State = 2150;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 2142; expression();
					State = 2147;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==COMMA) {
						{
						{
						State = 2143; Match(COMMA);
						State = 2144; expression();
						}
						}
						State = 2149;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					}
				}

				State = 2152; Match(RPAREN);
				State = 2154;
				_la = _input.La(1);
				if (_la==DOT) {
					{
					State = 2153; chainedFunction();
					}
				}

				}
				break;

			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2156; _localctx.b = Match(IDENT);
				State = 2157; Match(LBRACK);
				State = 2158; expression();
				State = 2163;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2159; Match(COMMA);
					State = 2160; expression();
					}
					}
					State = 2165;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2166; Match(RBRACK);
				State = 2168;
				_la = _input.La(1);
				if (_la==DOT) {
					{
					State = 2167; chainedFunction();
					}
				}

				}
				break;

			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2170; jsonobject();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubstitutionCanChainContext : ParserRuleContext {
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public SubstitutionCanChainContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_substitutionCanChain; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubstitutionCanChain(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubstitutionCanChain(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubstitutionCanChain(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubstitutionCanChainContext substitutionCanChain() {
		SubstitutionCanChainContext _localctx = new SubstitutionCanChainContext(_ctx, State);
		EnterRule(_localctx, 304, RULE_substitutionCanChain);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2173; substitution();
			State = 2175;
			_la = _input.La(1);
			if (_la==DOT) {
				{
				State = 2174; chainedFunction();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChainedFunctionContext : ParserRuleContext {
		public IToken d;
		public LibFunctionNoClassContext[] libFunctionNoClass() {
			return GetRuleContexts<LibFunctionNoClassContext>();
		}
		public LibFunctionNoClassContext libFunctionNoClass(int i) {
			return GetRuleContext<LibFunctionNoClassContext>(i);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public ChainedFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_chainedFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterChainedFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitChainedFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChainedFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ChainedFunctionContext chainedFunction() {
		ChainedFunctionContext _localctx = new ChainedFunctionContext(_ctx, State);
		EnterRule(_localctx, 306, RULE_chainedFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2177; _localctx.d = Match(DOT);
			State = 2178; libFunctionNoClass();
			State = 2183;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==DOT) {
				{
				{
				State = 2179; _localctx.d = Match(DOT);
				State = 2180; libFunctionNoClass();
				}
				}
				State = 2185;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewAssignContext : ParserRuleContext {
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public NewAssignContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newAssign; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNewAssign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNewAssign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewAssignContext newAssign() {
		NewAssignContext _localctx = new NewAssignContext(_ctx, State);
		EnterRule(_localctx, 308, RULE_newAssign);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2186; eventProperty();
			State = 2189;
			_la = _input.La(1);
			if (_la==EQUALS) {
				{
				State = 2187; Match(EQUALS);
				State = 2188; expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RowSubSelectExpressionContext : ParserRuleContext {
		public SubQueryExprContext subQueryExpr() {
			return GetRuleContext<SubQueryExprContext>(0);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public RowSubSelectExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rowSubSelectExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterRowSubSelectExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitRowSubSelectExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRowSubSelectExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RowSubSelectExpressionContext rowSubSelectExpression() {
		RowSubSelectExpressionContext _localctx = new RowSubSelectExpressionContext(_ctx, State);
		EnterRule(_localctx, 310, RULE_rowSubSelectExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2191; subQueryExpr();
			State = 2193;
			_la = _input.La(1);
			if (_la==DOT) {
				{
				State = 2192; chainedFunction();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubSelectGroupExpressionContext : ParserRuleContext {
		public SubQueryExprContext subQueryExpr() {
			return GetRuleContext<SubQueryExprContext>(0);
		}
		public SubSelectGroupExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subSelectGroupExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubSelectGroupExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubSelectGroupExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubSelectGroupExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubSelectGroupExpressionContext subSelectGroupExpression() {
		SubSelectGroupExpressionContext _localctx = new SubSelectGroupExpressionContext(_ctx, State);
		EnterRule(_localctx, 312, RULE_subSelectGroupExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2195; subQueryExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExistsSubSelectExpressionContext : ParserRuleContext {
		public ITerminalNode EXISTS() { return GetToken(EsperEPL2GrammarParser.EXISTS, 0); }
		public SubQueryExprContext subQueryExpr() {
			return GetRuleContext<SubQueryExprContext>(0);
		}
		public ExistsSubSelectExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_existsSubSelectExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExistsSubSelectExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExistsSubSelectExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExistsSubSelectExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExistsSubSelectExpressionContext existsSubSelectExpression() {
		ExistsSubSelectExpressionContext _localctx = new ExistsSubSelectExpressionContext(_ctx, State);
		EnterRule(_localctx, 314, RULE_existsSubSelectExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2197; Match(EXISTS);
			State = 2198; subQueryExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubQueryExprContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public SelectionListContext selectionList() {
			return GetRuleContext<SelectionListContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public SubSelectFilterExprContext subSelectFilterExpr() {
			return GetRuleContext<SubSelectFilterExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ITerminalNode GROUP() { return GetToken(EsperEPL2GrammarParser.GROUP, 0); }
		public ITerminalNode BY() { return GetToken(EsperEPL2GrammarParser.BY, 0); }
		public GroupByListExprContext groupByListExpr() {
			return GetRuleContext<GroupByListExprContext>(0);
		}
		public SubQueryExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subQueryExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubQueryExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubQueryExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubQueryExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubQueryExprContext subQueryExpr() {
		SubQueryExprContext _localctx = new SubQueryExprContext(_ctx, State);
		EnterRule(_localctx, 316, RULE_subQueryExpr);
		 paraphrases.Push("subquery"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2200; Match(LPAREN);
			State = 2201; Match(SELECT);
			State = 2203;
			_la = _input.La(1);
			if (_la==DISTINCT) {
				{
				State = 2202; Match(DISTINCT);
				}
			}

			State = 2205; selectionList();
			State = 2206; Match(FROM);
			State = 2207; subSelectFilterExpr();
			State = 2210;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 2208; Match(WHERE);
				State = 2209; whereClause();
				}
			}

			State = 2215;
			_la = _input.La(1);
			if (_la==GROUP) {
				{
				State = 2212; Match(GROUP);
				State = 2213; Match(BY);
				State = 2214; groupByListExpr();
				}
			}

			State = 2217; Match(RPAREN);
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubSelectFilterExprContext : ParserRuleContext {
		public IToken i;
		public IToken ru;
		public IToken ri;
		public EventFilterExpressionContext eventFilterExpression() {
			return GetRuleContext<EventFilterExpressionContext>(0);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public ViewExpressionContext[] viewExpression() {
			return GetRuleContexts<ViewExpressionContext>();
		}
		public ViewExpressionContext viewExpression(int i) {
			return GetRuleContext<ViewExpressionContext>(i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode RETAINUNION() { return GetToken(EsperEPL2GrammarParser.RETAINUNION, 0); }
		public ITerminalNode RETAININTERSECTION() { return GetToken(EsperEPL2GrammarParser.RETAININTERSECTION, 0); }
		public SubSelectFilterExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subSelectFilterExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubSelectFilterExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubSelectFilterExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubSelectFilterExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubSelectFilterExprContext subSelectFilterExpr() {
		SubSelectFilterExprContext _localctx = new SubSelectFilterExprContext(_ctx, State);
		EnterRule(_localctx, 318, RULE_subSelectFilterExpr);
		 paraphrases.Push("subquery filter specification"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2219; eventFilterExpression();
			State = 2229;
			_la = _input.La(1);
			if (_la==DOT) {
				{
				State = 2220; Match(DOT);
				State = 2221; viewExpression();
				State = 2226;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==DOT) {
					{
					{
					State = 2222; Match(DOT);
					State = 2223; viewExpression();
					}
					}
					State = 2228;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 2234;
			switch (_input.La(1)) {
			case AS:
				{
				State = 2231; Match(AS);
				State = 2232; _localctx.i = Match(IDENT);
				}
				break;
			case IDENT:
				{
				State = 2233; _localctx.i = Match(IDENT);
				}
				break;
			case WHERE:
			case GROUP:
			case RETAINUNION:
			case RETAININTERSECTION:
			case RPAREN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2238;
			switch (_input.La(1)) {
			case RETAINUNION:
				{
				State = 2236; _localctx.ru = Match(RETAINUNION);
				}
				break;
			case RETAININTERSECTION:
				{
				State = 2237; _localctx.ri = Match(RETAININTERSECTION);
				}
				break;
			case WHERE:
			case GROUP:
			case RPAREN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayExpressionContext : ParserRuleContext {
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ArrayExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterArrayExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitArrayExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayExpressionContext arrayExpression() {
		ArrayExpressionContext _localctx = new ArrayExpressionContext(_ctx, State);
		EnterRule(_localctx, 320, RULE_arrayExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2240; Match(LCURLY);
			State = 2249;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
				{
				State = 2241; expression();
				State = 2246;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2242; Match(COMMA);
					State = 2243; expression();
					}
					}
					State = 2248;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 2251; Match(RCURLY);
			State = 2253;
			_la = _input.La(1);
			if (_la==DOT) {
				{
				State = 2252; chainedFunction();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltinFuncContext : ParserRuleContext {
		public BuiltinFuncContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtinFunc; } }
	 
		public BuiltinFuncContext() { }
		public virtual void CopyFrom(BuiltinFuncContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Builtin_castContext : BuiltinFuncContext {
		public ITerminalNode CAST() { return GetToken(EsperEPL2GrammarParser.CAST, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ExpressionNamedParameterContext expressionNamedParameter() {
			return GetRuleContext<ExpressionNamedParameterContext>(0);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_castContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_cast(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_cast(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_cast(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_cntContext : BuiltinFuncContext {
		public IToken a;
		public IToken d;
		public ITerminalNode COUNT() { return GetToken(EsperEPL2GrammarParser.COUNT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_cntContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_cnt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_cnt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_cnt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_sumContext : BuiltinFuncContext {
		public ITerminalNode SUM() { return GetToken(EsperEPL2GrammarParser.SUM, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_sumContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_sum(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_sum(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_sum(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_priorContext : BuiltinFuncContext {
		public ITerminalNode PRIOR() { return GetToken(EsperEPL2GrammarParser.PRIOR, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_priorContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prior(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prior(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prior(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_existsContext : BuiltinFuncContext {
		public ITerminalNode EXISTS() { return GetToken(EsperEPL2GrammarParser.EXISTS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_existsContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_exists(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_exists(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_exists(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_prevtailContext : BuiltinFuncContext {
		public ITerminalNode PREVIOUSTAIL() { return GetToken(EsperEPL2GrammarParser.PREVIOUSTAIL, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_prevtailContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prevtail(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prevtail(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prevtail(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_istreamContext : BuiltinFuncContext {
		public ITerminalNode ISTREAM() { return GetToken(EsperEPL2GrammarParser.ISTREAM, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_istreamContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_istream(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_istream(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_istream(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_medianContext : BuiltinFuncContext {
		public ITerminalNode MEDIAN() { return GetToken(EsperEPL2GrammarParser.MEDIAN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_medianContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_median(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_median(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_median(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_currtsContext : BuiltinFuncContext {
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(EsperEPL2GrammarParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_currtsContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_currts(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_currts(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_currts(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_coalesceContext : BuiltinFuncContext {
		public ITerminalNode COALESCE() { return GetToken(EsperEPL2GrammarParser.COALESCE, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_coalesceContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_coalesce(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_coalesce(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_coalesce(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_prevContext : BuiltinFuncContext {
		public ITerminalNode PREVIOUS() { return GetToken(EsperEPL2GrammarParser.PREVIOUS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode COMMA() { return GetToken(EsperEPL2GrammarParser.COMMA, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_prevContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prev(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prev(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prev(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_prevcountContext : BuiltinFuncContext {
		public ITerminalNode PREVIOUSCOUNT() { return GetToken(EsperEPL2GrammarParser.PREVIOUSCOUNT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_prevcountContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prevcount(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prevcount(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prevcount(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_groupingidContext : BuiltinFuncContext {
		public ITerminalNode GROUPING_ID() { return GetToken(EsperEPL2GrammarParser.GROUPING_ID, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_groupingidContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_groupingid(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_groupingid(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_groupingid(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_prevwindowContext : BuiltinFuncContext {
		public ITerminalNode PREVIOUSWINDOW() { return GetToken(EsperEPL2GrammarParser.PREVIOUSWINDOW, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public Builtin_prevwindowContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_prevwindow(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_prevwindow(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_prevwindow(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_stddevContext : BuiltinFuncContext {
		public ITerminalNode STDDEV() { return GetToken(EsperEPL2GrammarParser.STDDEV, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_stddevContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_stddev(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_stddev(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_stddev(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_groupingContext : BuiltinFuncContext {
		public ITerminalNode GROUPING() { return GetToken(EsperEPL2GrammarParser.GROUPING, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_groupingContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_grouping(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_grouping(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_grouping(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_typeofContext : BuiltinFuncContext {
		public ITerminalNode TYPEOF() { return GetToken(EsperEPL2GrammarParser.TYPEOF, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_typeofContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_typeof(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_typeof(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_typeof(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_firstlastwindowContext : BuiltinFuncContext {
		public FirstLastWindowAggregationContext firstLastWindowAggregation() {
			return GetRuleContext<FirstLastWindowAggregationContext>(0);
		}
		public Builtin_firstlastwindowContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_firstlastwindow(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_firstlastwindow(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_firstlastwindow(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_instanceofContext : BuiltinFuncContext {
		public ITerminalNode INSTANCEOF() { return GetToken(EsperEPL2GrammarParser.INSTANCEOF, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ClassIdentifierContext[] classIdentifier() {
			return GetRuleContexts<ClassIdentifierContext>();
		}
		public ClassIdentifierContext classIdentifier(int i) {
			return GetRuleContext<ClassIdentifierContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public Builtin_instanceofContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_instanceof(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_instanceof(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_instanceof(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_avgContext : BuiltinFuncContext {
		public ITerminalNode AVG() { return GetToken(EsperEPL2GrammarParser.AVG, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_avgContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_avg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_avg(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_avg(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Builtin_avedevContext : BuiltinFuncContext {
		public ITerminalNode AVEDEV() { return GetToken(EsperEPL2GrammarParser.AVEDEV, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public Builtin_avedevContext(BuiltinFuncContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBuiltin_avedev(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBuiltin_avedev(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltin_avedev(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BuiltinFuncContext builtinFunc() {
		BuiltinFuncContext _localctx = new BuiltinFuncContext(_ctx, State);
		EnterRule(_localctx, 322, RULE_builtinFunc);
		int _la;
		try {
			State = 2418;
			switch (_input.La(1)) {
			case SUM:
				_localctx = new Builtin_sumContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2255; Match(SUM);
				State = 2256; Match(LPAREN);
				State = 2258;
				_la = _input.La(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2257;
					_la = _input.La(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
				}

				State = 2260; expressionListWithNamed();
				State = 2261; Match(RPAREN);
				}
				break;
			case AVG:
				_localctx = new Builtin_avgContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2263; Match(AVG);
				State = 2264; Match(LPAREN);
				State = 2266;
				_la = _input.La(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2265;
					_la = _input.La(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
				}

				State = 2268; expressionListWithNamed();
				State = 2269; Match(RPAREN);
				}
				break;
			case COUNT:
				_localctx = new Builtin_cntContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2271; Match(COUNT);
				State = 2272; Match(LPAREN);
				State = 2275;
				switch (_input.La(1)) {
				case ALL:
					{
					State = 2273; ((Builtin_cntContext)_localctx).a = Match(ALL);
					}
					break;
				case DISTINCT:
					{
					State = 2274; ((Builtin_cntContext)_localctx).d = Match(DISTINCT);
					}
					break;
				case WINDOW:
				case ESCAPE:
				case NOT_EXPR:
				case EVERY_EXPR:
				case SUM:
				case AVG:
				case MAX:
				case MIN:
				case COALESCE:
				case MEDIAN:
				case STDDEV:
				case AVEDEV:
				case COUNT:
				case CASE:
				case OUTER:
				case JOIN:
				case LEFT:
				case RIGHT:
				case FULL:
				case EVENTS:
				case FIRST:
				case LAST:
				case ISTREAM:
				case UNIDIRECTIONAL:
				case RETAINUNION:
				case RETAININTERSECTION:
				case PATTERN:
				case SQL:
				case METADATASQL:
				case PREVIOUS:
				case PREVIOUSTAIL:
				case PREVIOUSCOUNT:
				case PREVIOUSWINDOW:
				case PRIOR:
				case EXISTS:
				case WEEKDAY:
				case LW:
				case INSTANCEOF:
				case TYPEOF:
				case CAST:
				case CURRENT_TIMESTAMP:
				case SNAPSHOT:
				case VARIABLE:
				case TABLE:
				case UNTIL:
				case AT:
				case INDEX:
				case BOOLEAN_TRUE:
				case BOOLEAN_FALSE:
				case VALUE_NULL:
				case DEFINE:
				case PARTITION:
				case MATCHES:
				case FOR:
				case WHILE:
				case USING:
				case MERGE:
				case MATCHED:
				case NEWKW:
				case CONTEXT:
				case GROUPING:
				case GROUPING_ID:
				case QUESTION:
				case LPAREN:
				case LBRACK:
				case LCURLY:
				case PLUS:
				case MINUS:
				case STAR:
				case TICKED_STRING_LITERAL:
				case QUOTED_STRING_LITERAL:
				case STRING_LITERAL:
				case IDENT:
				case IntegerLiteral:
				case FloatingPointLiteral:
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2277; expressionListWithNamed();
				State = 2278; Match(RPAREN);
				}
				break;
			case MEDIAN:
				_localctx = new Builtin_medianContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2280; Match(MEDIAN);
				State = 2281; Match(LPAREN);
				State = 2283;
				_la = _input.La(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2282;
					_la = _input.La(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
				}

				State = 2285; expressionListWithNamed();
				State = 2286; Match(RPAREN);
				}
				break;
			case STDDEV:
				_localctx = new Builtin_stddevContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 2288; Match(STDDEV);
				State = 2289; Match(LPAREN);
				State = 2291;
				_la = _input.La(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2290;
					_la = _input.La(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
				}

				State = 2293; expressionListWithNamed();
				State = 2294; Match(RPAREN);
				}
				break;
			case AVEDEV:
				_localctx = new Builtin_avedevContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 2296; Match(AVEDEV);
				State = 2297; Match(LPAREN);
				State = 2299;
				_la = _input.La(1);
				if (_la==DISTINCT || _la==ALL) {
					{
					State = 2298;
					_la = _input.La(1);
					if ( !(_la==DISTINCT || _la==ALL) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
				}

				State = 2301; expressionListWithNamed();
				State = 2302; Match(RPAREN);
				}
				break;
			case WINDOW:
			case FIRST:
			case LAST:
				_localctx = new Builtin_firstlastwindowContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 2304; firstLastWindowAggregation();
				}
				break;
			case COALESCE:
				_localctx = new Builtin_coalesceContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 2305; Match(COALESCE);
				State = 2306; Match(LPAREN);
				State = 2307; expression();
				State = 2308; Match(COMMA);
				State = 2309; expression();
				State = 2314;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2310; Match(COMMA);
					State = 2311; expression();
					}
					}
					State = 2316;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2317; Match(RPAREN);
				}
				break;
			case PREVIOUS:
				_localctx = new Builtin_prevContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 2319; Match(PREVIOUS);
				State = 2320; Match(LPAREN);
				State = 2321; expression();
				State = 2324;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 2322; Match(COMMA);
					State = 2323; expression();
					}
				}

				State = 2326; Match(RPAREN);
				State = 2328;
				_la = _input.La(1);
				if (_la==DOT) {
					{
					State = 2327; chainedFunction();
					}
				}

				}
				break;
			case PREVIOUSTAIL:
				_localctx = new Builtin_prevtailContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 2330; Match(PREVIOUSTAIL);
				State = 2331; Match(LPAREN);
				State = 2332; expression();
				State = 2335;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 2333; Match(COMMA);
					State = 2334; expression();
					}
				}

				State = 2337; Match(RPAREN);
				State = 2339;
				_la = _input.La(1);
				if (_la==DOT) {
					{
					State = 2338; chainedFunction();
					}
				}

				}
				break;
			case PREVIOUSCOUNT:
				_localctx = new Builtin_prevcountContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 2341; Match(PREVIOUSCOUNT);
				State = 2342; Match(LPAREN);
				State = 2343; expression();
				State = 2344; Match(RPAREN);
				}
				break;
			case PREVIOUSWINDOW:
				_localctx = new Builtin_prevwindowContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 2346; Match(PREVIOUSWINDOW);
				State = 2347; Match(LPAREN);
				State = 2348; expression();
				State = 2349; Match(RPAREN);
				State = 2351;
				_la = _input.La(1);
				if (_la==DOT) {
					{
					State = 2350; chainedFunction();
					}
				}

				}
				break;
			case PRIOR:
				_localctx = new Builtin_priorContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 2353; Match(PRIOR);
				State = 2354; Match(LPAREN);
				State = 2355; expression();
				State = 2356; Match(COMMA);
				State = 2357; eventProperty();
				State = 2358; Match(RPAREN);
				}
				break;
			case GROUPING:
				_localctx = new Builtin_groupingContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 2360; Match(GROUPING);
				State = 2361; Match(LPAREN);
				State = 2362; expression();
				State = 2363; Match(RPAREN);
				}
				break;
			case GROUPING_ID:
				_localctx = new Builtin_groupingidContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 2365; Match(GROUPING_ID);
				State = 2366; Match(LPAREN);
				State = 2367; expressionList();
				State = 2368; Match(RPAREN);
				}
				break;
			case INSTANCEOF:
				_localctx = new Builtin_instanceofContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 2370; Match(INSTANCEOF);
				State = 2371; Match(LPAREN);
				State = 2372; expression();
				State = 2373; Match(COMMA);
				State = 2374; classIdentifier();
				State = 2379;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2375; Match(COMMA);
					State = 2376; classIdentifier();
					}
					}
					State = 2381;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2382; Match(RPAREN);
				}
				break;
			case TYPEOF:
				_localctx = new Builtin_typeofContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 2384; Match(TYPEOF);
				State = 2385; Match(LPAREN);
				State = 2386; expression();
				State = 2387; Match(RPAREN);
				}
				break;
			case CAST:
				_localctx = new Builtin_castContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 2389; Match(CAST);
				State = 2390; Match(LPAREN);
				State = 2391; expression();
				State = 2392;
				_la = _input.La(1);
				if ( !(_la==AS || _la==COMMA) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 2393; classIdentifier();
				State = 2396;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 2394; Match(COMMA);
					State = 2395; expressionNamedParameter();
					}
				}

				State = 2398; Match(RPAREN);
				State = 2400;
				_la = _input.La(1);
				if (_la==DOT) {
					{
					State = 2399; chainedFunction();
					}
				}

				}
				break;
			case EXISTS:
				_localctx = new Builtin_existsContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 2402; Match(EXISTS);
				State = 2403; Match(LPAREN);
				State = 2404; eventProperty();
				State = 2405; Match(RPAREN);
				}
				break;
			case CURRENT_TIMESTAMP:
				_localctx = new Builtin_currtsContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 2407; Match(CURRENT_TIMESTAMP);
				State = 2410;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,313,_ctx) ) {
				case 1:
					{
					State = 2408; Match(LPAREN);
					State = 2409; Match(RPAREN);
					}
					break;
				}
				State = 2413;
				_la = _input.La(1);
				if (_la==DOT) {
					{
					State = 2412; chainedFunction();
					}
				}

				}
				break;
			case ISTREAM:
				_localctx = new Builtin_istreamContext(_localctx);
				EnterOuterAlt(_localctx, 21);
				{
				State = 2415; Match(ISTREAM);
				State = 2416; Match(LPAREN);
				State = 2417; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FirstLastWindowAggregationContext : ParserRuleContext {
		public IToken q;
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public ExpressionListWithNamedContext expressionListWithNamed() {
			return GetRuleContext<ExpressionListWithNamedContext>(0);
		}
		public ChainedFunctionContext chainedFunction() {
			return GetRuleContext<ChainedFunctionContext>(0);
		}
		public FirstLastWindowAggregationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_firstLastWindowAggregation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFirstLastWindowAggregation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFirstLastWindowAggregation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFirstLastWindowAggregation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FirstLastWindowAggregationContext firstLastWindowAggregation() {
		FirstLastWindowAggregationContext _localctx = new FirstLastWindowAggregationContext(_ctx, State);
		EnterRule(_localctx, 324, RULE_firstLastWindowAggregation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2423;
			switch (_input.La(1)) {
			case FIRST:
				{
				State = 2420; _localctx.q = Match(FIRST);
				}
				break;
			case LAST:
				{
				State = 2421; _localctx.q = Match(LAST);
				}
				break;
			case WINDOW:
				{
				State = 2422; _localctx.q = Match(WINDOW);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2425; Match(LPAREN);
			State = 2427;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LBRACK - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (STAR - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
				{
				State = 2426; expressionListWithNamed();
				}
			}

			State = 2429; Match(RPAREN);
			State = 2431;
			_la = _input.La(1);
			if (_la==DOT) {
				{
				State = 2430; chainedFunction();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventPropertyOrLibFunctionContext : ParserRuleContext {
		public EventPropertyContext eventProperty() {
			return GetRuleContext<EventPropertyContext>(0);
		}
		public LibFunctionContext libFunction() {
			return GetRuleContext<LibFunctionContext>(0);
		}
		public EventPropertyOrLibFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventPropertyOrLibFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventPropertyOrLibFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventPropertyOrLibFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventPropertyOrLibFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventPropertyOrLibFunctionContext eventPropertyOrLibFunction() {
		EventPropertyOrLibFunctionContext _localctx = new EventPropertyOrLibFunctionContext(_ctx, State);
		EnterRule(_localctx, 326, RULE_eventPropertyOrLibFunction);
		try {
			State = 2435;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,319,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2433; eventProperty();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2434; libFunction();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionContext : ParserRuleContext {
		public LibFunctionWithClassContext libFunctionWithClass() {
			return GetRuleContext<LibFunctionWithClassContext>(0);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public LibFunctionNoClassContext[] libFunctionNoClass() {
			return GetRuleContexts<LibFunctionNoClassContext>();
		}
		public LibFunctionNoClassContext libFunctionNoClass(int i) {
			return GetRuleContext<LibFunctionNoClassContext>(i);
		}
		public LibFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionContext libFunction() {
		LibFunctionContext _localctx = new LibFunctionContext(_ctx, State);
		EnterRule(_localctx, 328, RULE_libFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2437; libFunctionWithClass();
			State = 2442;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==DOT) {
				{
				{
				State = 2438; Match(DOT);
				State = 2439; libFunctionNoClass();
				}
				}
				State = 2444;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionWithClassContext : ParserRuleContext {
		public IToken l;
		public FuncIdentTopContext funcIdentTop() {
			return GetRuleContext<FuncIdentTopContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(EsperEPL2GrammarParser.DOT, 0); }
		public FuncIdentInnerContext funcIdentInner() {
			return GetRuleContext<FuncIdentInnerContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public LibFunctionArgsContext libFunctionArgs() {
			return GetRuleContext<LibFunctionArgsContext>(0);
		}
		public LibFunctionWithClassContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunctionWithClass; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunctionWithClass(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunctionWithClass(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunctionWithClass(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionWithClassContext libFunctionWithClass() {
		LibFunctionWithClassContext _localctx = new LibFunctionWithClassContext(_ctx, State);
		EnterRule(_localctx, 330, RULE_libFunctionWithClass);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2450;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,321,_ctx) ) {
			case 1:
				{
				{
				State = 2445; classIdentifier();
				State = 2446; Match(DOT);
				State = 2447; funcIdentInner();
				}
				}
				break;

			case 2:
				{
				State = 2449; funcIdentTop();
				}
				break;
			}
			State = 2457;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,323,_ctx) ) {
			case 1:
				{
				State = 2452; _localctx.l = Match(LPAREN);
				State = 2454;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << DISTINCT) | (1L << ALL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LBRACK - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (STAR - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 2453; libFunctionArgs();
					}
				}

				State = 2456; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionNoClassContext : ParserRuleContext {
		public IToken l;
		public FuncIdentChainedContext funcIdentChained() {
			return GetRuleContext<FuncIdentChainedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public LibFunctionArgsContext libFunctionArgs() {
			return GetRuleContext<LibFunctionArgsContext>(0);
		}
		public LibFunctionNoClassContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunctionNoClass; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunctionNoClass(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunctionNoClass(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunctionNoClass(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionNoClassContext libFunctionNoClass() {
		LibFunctionNoClassContext _localctx = new LibFunctionNoClassContext(_ctx, State);
		EnterRule(_localctx, 332, RULE_libFunctionNoClass);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2459; funcIdentChained();
			State = 2465;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,325,_ctx) ) {
			case 1:
				{
				State = 2460; _localctx.l = Match(LPAREN);
				State = 2462;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << DISTINCT) | (1L << ALL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LBRACK - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (STAR - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 2461; libFunctionArgs();
					}
				}

				State = 2464; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncIdentTopContext : ParserRuleContext {
		public EscapableIdentContext escapableIdent() {
			return GetRuleContext<EscapableIdentContext>(0);
		}
		public ITerminalNode MAX() { return GetToken(EsperEPL2GrammarParser.MAX, 0); }
		public ITerminalNode MIN() { return GetToken(EsperEPL2GrammarParser.MIN, 0); }
		public FuncIdentTopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcIdentTop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFuncIdentTop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFuncIdentTop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncIdentTop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncIdentTopContext funcIdentTop() {
		FuncIdentTopContext _localctx = new FuncIdentTopContext(_ctx, State);
		EnterRule(_localctx, 334, RULE_funcIdentTop);
		try {
			State = 2470;
			switch (_input.La(1)) {
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2467; escapableIdent();
				}
				break;
			case MAX:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2468; Match(MAX);
				}
				break;
			case MIN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2469; Match(MIN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncIdentInnerContext : ParserRuleContext {
		public EscapableIdentContext escapableIdent() {
			return GetRuleContext<EscapableIdentContext>(0);
		}
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public FuncIdentInnerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcIdentInner; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFuncIdentInner(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFuncIdentInner(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncIdentInner(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncIdentInnerContext funcIdentInner() {
		FuncIdentInnerContext _localctx = new FuncIdentInnerContext(_ctx, State);
		EnterRule(_localctx, 336, RULE_funcIdentInner);
		try {
			State = 2476;
			switch (_input.La(1)) {
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2472; escapableIdent();
				}
				break;
			case LAST:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2473; Match(LAST);
				}
				break;
			case FIRST:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2474; Match(FIRST);
				}
				break;
			case WINDOW:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2475; Match(WINDOW);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncIdentChainedContext : ParserRuleContext {
		public EscapableIdentContext escapableIdent() {
			return GetRuleContext<EscapableIdentContext>(0);
		}
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public ITerminalNode MAX() { return GetToken(EsperEPL2GrammarParser.MAX, 0); }
		public ITerminalNode MIN() { return GetToken(EsperEPL2GrammarParser.MIN, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public ITerminalNode SET() { return GetToken(EsperEPL2GrammarParser.SET, 0); }
		public ITerminalNode AFTER() { return GetToken(EsperEPL2GrammarParser.AFTER, 0); }
		public ITerminalNode BETWEEN() { return GetToken(EsperEPL2GrammarParser.BETWEEN, 0); }
		public FuncIdentChainedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcIdentChained; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFuncIdentChained(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFuncIdentChained(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncIdentChained(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncIdentChainedContext funcIdentChained() {
		FuncIdentChainedContext _localctx = new FuncIdentChainedContext(_ctx, State);
		EnterRule(_localctx, 338, RULE_funcIdentChained);
		try {
			State = 2488;
			switch (_input.La(1)) {
			case TICKED_STRING_LITERAL:
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2478; escapableIdent();
				}
				break;
			case LAST:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2479; Match(LAST);
				}
				break;
			case FIRST:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2480; Match(FIRST);
				}
				break;
			case WINDOW:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2481; Match(WINDOW);
				}
				break;
			case MAX:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2482; Match(MAX);
				}
				break;
			case MIN:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2483; Match(MIN);
				}
				break;
			case WHERE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2484; Match(WHERE);
				}
				break;
			case SET:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2485; Match(SET);
				}
				break;
			case AFTER:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2486; Match(AFTER);
				}
				break;
			case BETWEEN:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2487; Match(BETWEEN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionArgsContext : ParserRuleContext {
		public LibFunctionArgItemContext[] libFunctionArgItem() {
			return GetRuleContexts<LibFunctionArgItemContext>();
		}
		public LibFunctionArgItemContext libFunctionArgItem(int i) {
			return GetRuleContext<LibFunctionArgItemContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ITerminalNode ALL() { return GetToken(EsperEPL2GrammarParser.ALL, 0); }
		public ITerminalNode DISTINCT() { return GetToken(EsperEPL2GrammarParser.DISTINCT, 0); }
		public LibFunctionArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunctionArgs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunctionArgs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunctionArgs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunctionArgs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionArgsContext libFunctionArgs() {
		LibFunctionArgsContext _localctx = new LibFunctionArgsContext(_ctx, State);
		EnterRule(_localctx, 340, RULE_libFunctionArgs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2491;
			_la = _input.La(1);
			if (_la==DISTINCT || _la==ALL) {
				{
				State = 2490;
				_la = _input.La(1);
				if ( !(_la==DISTINCT || _la==ALL) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
			}

			State = 2493; libFunctionArgItem();
			State = 2498;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2494; Match(COMMA);
				State = 2495; libFunctionArgItem();
				}
				}
				State = 2500;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LibFunctionArgItemContext : ParserRuleContext {
		public ExpressionWithNamedContext expressionWithNamed() {
			return GetRuleContext<ExpressionWithNamedContext>(0);
		}
		public ExpressionLambdaDeclContext expressionLambdaDecl() {
			return GetRuleContext<ExpressionLambdaDeclContext>(0);
		}
		public LibFunctionArgItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_libFunctionArgItem; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLibFunctionArgItem(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLibFunctionArgItem(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLibFunctionArgItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LibFunctionArgItemContext libFunctionArgItem() {
		LibFunctionArgItemContext _localctx = new LibFunctionArgItemContext(_ctx, State);
		EnterRule(_localctx, 342, RULE_libFunctionArgItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2502;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,331,_ctx) ) {
			case 1:
				{
				State = 2501; expressionLambdaDecl();
				}
				break;
			}
			State = 2504; expressionWithNamed();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BetweenListContext : ParserRuleContext {
		public ConcatenationExprContext[] concatenationExpr() {
			return GetRuleContexts<ConcatenationExprContext>();
		}
		public ConcatenationExprContext concatenationExpr(int i) {
			return GetRuleContext<ConcatenationExprContext>(i);
		}
		public ITerminalNode AND_EXPR() { return GetToken(EsperEPL2GrammarParser.AND_EXPR, 0); }
		public BetweenListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_betweenList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterBetweenList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitBetweenList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBetweenList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BetweenListContext betweenList() {
		BetweenListContext _localctx = new BetweenListContext(_ctx, State);
		EnterRule(_localctx, 344, RULE_betweenList);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2506; concatenationExpr();
			State = 2507; Match(AND_EXPR);
			State = 2508; concatenationExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternExpressionContext : ParserRuleContext {
		public FollowedByExpressionContext followedByExpression() {
			return GetRuleContext<FollowedByExpressionContext>(0);
		}
		public PatternExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPatternExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPatternExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternExpressionContext patternExpression() {
		PatternExpressionContext _localctx = new PatternExpressionContext(_ctx, State);
		EnterRule(_localctx, 346, RULE_patternExpression);
		 paraphrases.Push("pattern expression"); 
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2510; followedByExpression();
			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FollowedByExpressionContext : ParserRuleContext {
		public OrExpressionContext orExpression() {
			return GetRuleContext<OrExpressionContext>(0);
		}
		public FollowedByRepeatContext[] followedByRepeat() {
			return GetRuleContexts<FollowedByRepeatContext>();
		}
		public FollowedByRepeatContext followedByRepeat(int i) {
			return GetRuleContext<FollowedByRepeatContext>(i);
		}
		public FollowedByExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_followedByExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFollowedByExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFollowedByExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFollowedByExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FollowedByExpressionContext followedByExpression() {
		FollowedByExpressionContext _localctx = new FollowedByExpressionContext(_ctx, State);
		EnterRule(_localctx, 348, RULE_followedByExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2512; orExpression();
			State = 2516;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==FOLLOWMAX_BEGIN || _la==FOLLOWED_BY) {
				{
				{
				State = 2513; followedByRepeat();
				}
				}
				State = 2518;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FollowedByRepeatContext : ParserRuleContext {
		public IToken f;
		public IToken g;
		public OrExpressionContext orExpression() {
			return GetRuleContext<OrExpressionContext>(0);
		}
		public ITerminalNode FOLLOWED_BY() { return GetToken(EsperEPL2GrammarParser.FOLLOWED_BY, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode FOLLOWMAX_END() { return GetToken(EsperEPL2GrammarParser.FOLLOWMAX_END, 0); }
		public ITerminalNode FOLLOWMAX_BEGIN() { return GetToken(EsperEPL2GrammarParser.FOLLOWMAX_BEGIN, 0); }
		public FollowedByRepeatContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_followedByRepeat; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFollowedByRepeat(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFollowedByRepeat(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFollowedByRepeat(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FollowedByRepeatContext followedByRepeat() {
		FollowedByRepeatContext _localctx = new FollowedByRepeatContext(_ctx, State);
		EnterRule(_localctx, 350, RULE_followedByRepeat);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2524;
			switch (_input.La(1)) {
			case FOLLOWED_BY:
				{
				State = 2519; _localctx.f = Match(FOLLOWED_BY);
				}
				break;
			case FOLLOWMAX_BEGIN:
				{
				{
				State = 2520; _localctx.g = Match(FOLLOWMAX_BEGIN);
				State = 2521; expression();
				State = 2522; Match(FOLLOWMAX_END);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2526; orExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrExpressionContext : ParserRuleContext {
		public IToken o;
		public AndExpressionContext[] andExpression() {
			return GetRuleContexts<AndExpressionContext>();
		}
		public AndExpressionContext andExpression(int i) {
			return GetRuleContext<AndExpressionContext>(i);
		}
		public ITerminalNode[] OR_EXPR() { return GetTokens(EsperEPL2GrammarParser.OR_EXPR); }
		public ITerminalNode OR_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.OR_EXPR, i);
		}
		public OrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterOrExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitOrExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrExpressionContext orExpression() {
		OrExpressionContext _localctx = new OrExpressionContext(_ctx, State);
		EnterRule(_localctx, 352, RULE_orExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2528; andExpression();
			State = 2533;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==OR_EXPR) {
				{
				{
				State = 2529; _localctx.o = Match(OR_EXPR);
				State = 2530; andExpression();
				}
				}
				State = 2535;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AndExpressionContext : ParserRuleContext {
		public IToken a;
		public MatchUntilExpressionContext[] matchUntilExpression() {
			return GetRuleContexts<MatchUntilExpressionContext>();
		}
		public MatchUntilExpressionContext matchUntilExpression(int i) {
			return GetRuleContext<MatchUntilExpressionContext>(i);
		}
		public ITerminalNode[] AND_EXPR() { return GetTokens(EsperEPL2GrammarParser.AND_EXPR); }
		public ITerminalNode AND_EXPR(int i) {
			return GetToken(EsperEPL2GrammarParser.AND_EXPR, i);
		}
		public AndExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_andExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterAndExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitAndExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AndExpressionContext andExpression() {
		AndExpressionContext _localctx = new AndExpressionContext(_ctx, State);
		EnterRule(_localctx, 354, RULE_andExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2536; matchUntilExpression();
			State = 2541;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==AND_EXPR) {
				{
				{
				State = 2537; _localctx.a = Match(AND_EXPR);
				State = 2538; matchUntilExpression();
				}
				}
				State = 2543;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchUntilExpressionContext : ParserRuleContext {
		public MatchUntilRangeContext r;
		public QualifyExpressionContext until;
		public QualifyExpressionContext[] qualifyExpression() {
			return GetRuleContexts<QualifyExpressionContext>();
		}
		public QualifyExpressionContext qualifyExpression(int i) {
			return GetRuleContext<QualifyExpressionContext>(i);
		}
		public ITerminalNode UNTIL() { return GetToken(EsperEPL2GrammarParser.UNTIL, 0); }
		public MatchUntilRangeContext matchUntilRange() {
			return GetRuleContext<MatchUntilRangeContext>(0);
		}
		public MatchUntilExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchUntilExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchUntilExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchUntilExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchUntilExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchUntilExpressionContext matchUntilExpression() {
		MatchUntilExpressionContext _localctx = new MatchUntilExpressionContext(_ctx, State);
		EnterRule(_localctx, 356, RULE_matchUntilExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2545;
			_la = _input.La(1);
			if (_la==LBRACK) {
				{
				State = 2544; _localctx.r = matchUntilRange();
				}
			}

			State = 2547; qualifyExpression();
			State = 2550;
			_la = _input.La(1);
			if (_la==UNTIL) {
				{
				State = 2548; Match(UNTIL);
				State = 2549; _localctx.until = qualifyExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifyExpressionContext : ParserRuleContext {
		public IToken e;
		public IToken n;
		public IToken d;
		public GuardPostFixContext guardPostFix() {
			return GetRuleContext<GuardPostFixContext>(0);
		}
		public DistinctExpressionListContext distinctExpressionList() {
			return GetRuleContext<DistinctExpressionListContext>(0);
		}
		public ITerminalNode EVERY_EXPR() { return GetToken(EsperEPL2GrammarParser.EVERY_EXPR, 0); }
		public ITerminalNode NOT_EXPR() { return GetToken(EsperEPL2GrammarParser.NOT_EXPR, 0); }
		public ITerminalNode EVERY_DISTINCT_EXPR() { return GetToken(EsperEPL2GrammarParser.EVERY_DISTINCT_EXPR, 0); }
		public MatchUntilRangeContext matchUntilRange() {
			return GetRuleContext<MatchUntilRangeContext>(0);
		}
		public QualifyExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifyExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterQualifyExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitQualifyExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQualifyExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QualifyExpressionContext qualifyExpression() {
		QualifyExpressionContext _localctx = new QualifyExpressionContext(_ctx, State);
		EnterRule(_localctx, 358, RULE_qualifyExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2561;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << EVERY_DISTINCT_EXPR))) != 0)) {
				{
				State = 2556;
				switch (_input.La(1)) {
				case EVERY_EXPR:
					{
					State = 2552; _localctx.e = Match(EVERY_EXPR);
					}
					break;
				case NOT_EXPR:
					{
					State = 2553; _localctx.n = Match(NOT_EXPR);
					}
					break;
				case EVERY_DISTINCT_EXPR:
					{
					State = 2554; _localctx.d = Match(EVERY_DISTINCT_EXPR);
					State = 2555; distinctExpressionList();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2559;
				_la = _input.La(1);
				if (_la==LBRACK) {
					{
					State = 2558; matchUntilRange();
					}
				}

				}
			}

			State = 2563; guardPostFix();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GuardPostFixContext : ParserRuleContext {
		public IToken l;
		public IToken wh;
		public IToken wi;
		public AtomicExpressionContext atomicExpression() {
			return GetRuleContext<AtomicExpressionContext>(0);
		}
		public PatternExpressionContext patternExpression() {
			return GetRuleContext<PatternExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public GuardWhereExpressionContext guardWhereExpression() {
			return GetRuleContext<GuardWhereExpressionContext>(0);
		}
		public GuardWhileExpressionContext guardWhileExpression() {
			return GetRuleContext<GuardWhileExpressionContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public ITerminalNode WHILE() { return GetToken(EsperEPL2GrammarParser.WHILE, 0); }
		public GuardPostFixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_guardPostFix; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGuardPostFix(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGuardPostFix(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGuardPostFix(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GuardPostFixContext guardPostFix() {
		GuardPostFixContext _localctx = new GuardPostFixContext(_ctx, State);
		EnterRule(_localctx, 360, RULE_guardPostFix);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2570;
			switch (_input.La(1)) {
			case EVENTS:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 2565; atomicExpression();
				}
				break;
			case LPAREN:
				{
				State = 2566; _localctx.l = Match(LPAREN);
				State = 2567; patternExpression();
				State = 2568; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2576;
			switch (_input.La(1)) {
			case WHERE:
				{
				{
				State = 2572; _localctx.wh = Match(WHERE);
				State = 2573; guardWhereExpression();
				}
				}
				break;
			case WHILE:
				{
				{
				State = 2574; _localctx.wi = Match(WHILE);
				State = 2575; guardWhileExpression();
				}
				}
				break;
			case Eof:
			case OR_EXPR:
			case AND_EXPR:
			case UNTIL:
			case FOLLOWMAX_BEGIN:
			case FOLLOWED_BY:
			case RPAREN:
			case RBRACK:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DistinctExpressionListContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public DistinctExpressionAtomContext[] distinctExpressionAtom() {
			return GetRuleContexts<DistinctExpressionAtomContext>();
		}
		public DistinctExpressionAtomContext distinctExpressionAtom(int i) {
			return GetRuleContext<DistinctExpressionAtomContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public DistinctExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_distinctExpressionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterDistinctExpressionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitDistinctExpressionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDistinctExpressionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DistinctExpressionListContext distinctExpressionList() {
		DistinctExpressionListContext _localctx = new DistinctExpressionListContext(_ctx, State);
		EnterRule(_localctx, 362, RULE_distinctExpressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2578; Match(LPAREN);
			State = 2579; distinctExpressionAtom();
			State = 2584;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2580; Match(COMMA);
				State = 2581; distinctExpressionAtom();
				}
				}
				State = 2586;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2587; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DistinctExpressionAtomContext : ParserRuleContext {
		public ExpressionWithTimeContext expressionWithTime() {
			return GetRuleContext<ExpressionWithTimeContext>(0);
		}
		public DistinctExpressionAtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_distinctExpressionAtom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterDistinctExpressionAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitDistinctExpressionAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDistinctExpressionAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DistinctExpressionAtomContext distinctExpressionAtom() {
		DistinctExpressionAtomContext _localctx = new DistinctExpressionAtomContext(_ctx, State);
		EnterRule(_localctx, 364, RULE_distinctExpressionAtom);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2589; expressionWithTime();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomicExpressionContext : ParserRuleContext {
		public ObserverExpressionContext observerExpression() {
			return GetRuleContext<ObserverExpressionContext>(0);
		}
		public PatternFilterExpressionContext patternFilterExpression() {
			return GetRuleContext<PatternFilterExpressionContext>(0);
		}
		public AtomicExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atomicExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterAtomicExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitAtomicExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtomicExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomicExpressionContext atomicExpression() {
		AtomicExpressionContext _localctx = new AtomicExpressionContext(_ctx, State);
		EnterRule(_localctx, 366, RULE_atomicExpression);
		try {
			State = 2593;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,344,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2591; observerExpression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2592; patternFilterExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObserverExpressionContext : ParserRuleContext {
		public IToken ns;
		public IToken nm;
		public IToken a;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AT() { return GetToken(EsperEPL2GrammarParser.AT, 0); }
		public ExpressionListWithNamedWithTimeContext expressionListWithNamedWithTime() {
			return GetRuleContext<ExpressionListWithNamedWithTimeContext>(0);
		}
		public ObserverExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_observerExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterObserverExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitObserverExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObserverExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObserverExpressionContext observerExpression() {
		ObserverExpressionContext _localctx = new ObserverExpressionContext(_ctx, State);
		EnterRule(_localctx, 368, RULE_observerExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2595; _localctx.ns = Match(IDENT);
			State = 2596; Match(COLON);
			State = 2599;
			switch (_input.La(1)) {
			case IDENT:
				{
				State = 2597; _localctx.nm = Match(IDENT);
				}
				break;
			case AT:
				{
				State = 2598; _localctx.a = Match(AT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2601; Match(LPAREN);
			State = 2603;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LBRACK - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (STAR - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
				{
				State = 2602; expressionListWithNamedWithTime();
				}
			}

			State = 2605; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GuardWhereExpressionContext : ParserRuleContext {
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionWithTimeListContext expressionWithTimeList() {
			return GetRuleContext<ExpressionWithTimeListContext>(0);
		}
		public GuardWhereExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_guardWhereExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGuardWhereExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGuardWhereExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGuardWhereExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GuardWhereExpressionContext guardWhereExpression() {
		GuardWhereExpressionContext _localctx = new GuardWhereExpressionContext(_ctx, State);
		EnterRule(_localctx, 370, RULE_guardWhereExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2607; Match(IDENT);
			State = 2608; Match(COLON);
			State = 2609; Match(IDENT);
			State = 2610; Match(LPAREN);
			State = 2612;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LBRACK - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (STAR - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
				{
				State = 2611; expressionWithTimeList();
				}
			}

			State = 2614; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GuardWhileExpressionContext : ParserRuleContext {
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public GuardWhileExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_guardWhileExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterGuardWhileExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitGuardWhileExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGuardWhileExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GuardWhileExpressionContext guardWhileExpression() {
		GuardWhileExpressionContext _localctx = new GuardWhileExpressionContext(_ctx, State);
		EnterRule(_localctx, 372, RULE_guardWhileExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2616; Match(LPAREN);
			State = 2617; expression();
			State = 2618; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchUntilRangeContext : ParserRuleContext {
		public ExpressionContext low;
		public IToken c1;
		public ExpressionContext high;
		public IToken c2;
		public ExpressionContext upper;
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public MatchUntilRangeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchUntilRange; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMatchUntilRange(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMatchUntilRange(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchUntilRange(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchUntilRangeContext matchUntilRange() {
		MatchUntilRangeContext _localctx = new MatchUntilRangeContext(_ctx, State);
		EnterRule(_localctx, 374, RULE_matchUntilRange);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2620; Match(LBRACK);
			State = 2630;
			switch (_input.La(1)) {
			case WINDOW:
			case ESCAPE:
			case NOT_EXPR:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case CASE:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case ISTREAM:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PREVIOUSCOUNT:
			case PREVIOUSWINDOW:
			case PRIOR:
			case EXISTS:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case CURRENT_TIMESTAMP:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case NEWKW:
			case CONTEXT:
			case GROUPING:
			case GROUPING_ID:
			case QUESTION:
			case LPAREN:
			case LCURLY:
			case PLUS:
			case MINUS:
			case TICKED_STRING_LITERAL:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IDENT:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2621; _localctx.low = expression();
				State = 2626;
				_la = _input.La(1);
				if (_la==COLON) {
					{
					State = 2622; _localctx.c1 = Match(COLON);
					State = 2624;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
						{
						State = 2623; _localctx.high = expression();
						}
					}

					}
				}

				}
				break;
			case COLON:
				{
				State = 2628; _localctx.c2 = Match(COLON);
				State = 2629; _localctx.upper = expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2632; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventFilterExpressionContext : ParserRuleContext {
		public IToken i;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public PropertyExpressionContext propertyExpression() {
			return GetRuleContext<PropertyExpressionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public EventFilterExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventFilterExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventFilterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventFilterExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventFilterExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventFilterExpressionContext eventFilterExpression() {
		EventFilterExpressionContext _localctx = new EventFilterExpressionContext(_ctx, State);
		EnterRule(_localctx, 376, RULE_eventFilterExpression);
		 paraphrases.Push("filter specification"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2636;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,351,_ctx) ) {
			case 1:
				{
				State = 2634; _localctx.i = Match(IDENT);
				State = 2635; Match(EQUALS);
				}
				break;
			}
			State = 2638; classIdentifier();
			State = 2644;
			_la = _input.La(1);
			if (_la==LPAREN) {
				{
				State = 2639; Match(LPAREN);
				State = 2641;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 2640; expressionList();
					}
				}

				State = 2643; Match(RPAREN);
				}
			}

			State = 2647;
			_la = _input.La(1);
			if (_la==LBRACK) {
				{
				State = 2646; propertyExpression();
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyExpressionContext : ParserRuleContext {
		public PropertyExpressionAtomicContext[] propertyExpressionAtomic() {
			return GetRuleContexts<PropertyExpressionAtomicContext>();
		}
		public PropertyExpressionAtomicContext propertyExpressionAtomic(int i) {
			return GetRuleContext<PropertyExpressionAtomicContext>(i);
		}
		public PropertyExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertyExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertyExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyExpressionContext propertyExpression() {
		PropertyExpressionContext _localctx = new PropertyExpressionContext(_ctx, State);
		EnterRule(_localctx, 378, RULE_propertyExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2649; propertyExpressionAtomic();
			State = 2653;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==LBRACK) {
				{
				{
				State = 2650; propertyExpressionAtomic();
				}
				}
				State = 2655;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyExpressionAtomicContext : ParserRuleContext {
		public IToken n;
		public ExpressionContext where;
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public PropertyExpressionSelectContext propertyExpressionSelect() {
			return GetRuleContext<PropertyExpressionSelectContext>(0);
		}
		public PropertyExpressionAnnotationContext propertyExpressionAnnotation() {
			return GetRuleContext<PropertyExpressionAnnotationContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public ITerminalNode WHERE() { return GetToken(EsperEPL2GrammarParser.WHERE, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public PropertyExpressionAtomicContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyExpressionAtomic; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertyExpressionAtomic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertyExpressionAtomic(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyExpressionAtomic(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyExpressionAtomicContext propertyExpressionAtomic() {
		PropertyExpressionAtomicContext _localctx = new PropertyExpressionAtomicContext(_ctx, State);
		EnterRule(_localctx, 380, RULE_propertyExpressionAtomic);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2656; Match(LBRACK);
			State = 2658;
			_la = _input.La(1);
			if (_la==SELECT) {
				{
				State = 2657; propertyExpressionSelect();
				}
			}

			State = 2660; expression();
			State = 2662;
			_la = _input.La(1);
			if (_la==ATCHAR) {
				{
				State = 2661; propertyExpressionAnnotation();
				}
			}

			State = 2666;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 2664; Match(AS);
				State = 2665; _localctx.n = Match(IDENT);
				}
			}

			State = 2670;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 2668; Match(WHERE);
				State = 2669; _localctx.where = expression();
				}
			}

			State = 2672; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyExpressionSelectContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(EsperEPL2GrammarParser.SELECT, 0); }
		public PropertySelectionListContext propertySelectionList() {
			return GetRuleContext<PropertySelectionListContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(EsperEPL2GrammarParser.FROM, 0); }
		public PropertyExpressionSelectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyExpressionSelect; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertyExpressionSelect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertyExpressionSelect(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyExpressionSelect(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyExpressionSelectContext propertyExpressionSelect() {
		PropertyExpressionSelectContext _localctx = new PropertyExpressionSelectContext(_ctx, State);
		EnterRule(_localctx, 382, RULE_propertyExpressionSelect);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2674; Match(SELECT);
			State = 2675; propertySelectionList();
			State = 2676; Match(FROM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyExpressionAnnotationContext : ParserRuleContext {
		public IToken n;
		public IToken v;
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public PropertyExpressionAnnotationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyExpressionAnnotation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertyExpressionAnnotation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertyExpressionAnnotation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyExpressionAnnotation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyExpressionAnnotationContext propertyExpressionAnnotation() {
		PropertyExpressionAnnotationContext _localctx = new PropertyExpressionAnnotationContext(_ctx, State);
		EnterRule(_localctx, 384, RULE_propertyExpressionAnnotation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2678; Match(ATCHAR);
			State = 2679; _localctx.n = Match(IDENT);
			{
			State = 2680; Match(LPAREN);
			State = 2681; _localctx.v = Match(IDENT);
			State = 2682; Match(RPAREN);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertySelectionListContext : ParserRuleContext {
		public PropertySelectionListElementContext[] propertySelectionListElement() {
			return GetRuleContexts<PropertySelectionListElementContext>();
		}
		public PropertySelectionListElementContext propertySelectionListElement(int i) {
			return GetRuleContext<PropertySelectionListElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public PropertySelectionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertySelectionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertySelectionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertySelectionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertySelectionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertySelectionListContext propertySelectionList() {
		PropertySelectionListContext _localctx = new PropertySelectionListContext(_ctx, State);
		EnterRule(_localctx, 386, RULE_propertySelectionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2684; propertySelectionListElement();
			State = 2689;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2685; Match(COMMA);
				State = 2686; propertySelectionListElement();
				}
				}
				State = 2691;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertySelectionListElementContext : ParserRuleContext {
		public IToken s;
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public PropertyStreamSelectorContext propertyStreamSelector() {
			return GetRuleContext<PropertyStreamSelectorContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public KeywordAllowedIdentContext keywordAllowedIdent() {
			return GetRuleContext<KeywordAllowedIdentContext>(0);
		}
		public PropertySelectionListElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertySelectionListElement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertySelectionListElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertySelectionListElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertySelectionListElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertySelectionListElementContext propertySelectionListElement() {
		PropertySelectionListElementContext _localctx = new PropertySelectionListElementContext(_ctx, State);
		EnterRule(_localctx, 388, RULE_propertySelectionListElement);
		int _la;
		try {
			State = 2699;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,362,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2692; _localctx.s = Match(STAR);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2693; propertyStreamSelector();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2694; expression();
				State = 2697;
				_la = _input.La(1);
				if (_la==AS) {
					{
					State = 2695; Match(AS);
					State = 2696; keywordAllowedIdent();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyStreamSelectorContext : ParserRuleContext {
		public IToken s;
		public IToken i;
		public ITerminalNode DOT() { return GetToken(EsperEPL2GrammarParser.DOT, 0); }
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public ITerminalNode AS() { return GetToken(EsperEPL2GrammarParser.AS, 0); }
		public PropertyStreamSelectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyStreamSelector; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPropertyStreamSelector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPropertyStreamSelector(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyStreamSelector(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyStreamSelectorContext propertyStreamSelector() {
		PropertyStreamSelectorContext _localctx = new PropertyStreamSelectorContext(_ctx, State);
		EnterRule(_localctx, 390, RULE_propertyStreamSelector);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2701; _localctx.s = Match(IDENT);
			State = 2702; Match(DOT);
			State = 2703; Match(STAR);
			State = 2706;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 2704; Match(AS);
				State = 2705; _localctx.i = Match(IDENT);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternFilterExpressionContext : ParserRuleContext {
		public IToken i;
		public ClassIdentifierContext classIdentifier() {
			return GetRuleContext<ClassIdentifierContext>(0);
		}
		public ITerminalNode EQUALS() { return GetToken(EsperEPL2GrammarParser.EQUALS, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public PropertyExpressionContext propertyExpression() {
			return GetRuleContext<PropertyExpressionContext>(0);
		}
		public PatternFilterAnnotationContext patternFilterAnnotation() {
			return GetRuleContext<PatternFilterAnnotationContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public PatternFilterExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternFilterExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPatternFilterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPatternFilterExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternFilterExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternFilterExpressionContext patternFilterExpression() {
		PatternFilterExpressionContext _localctx = new PatternFilterExpressionContext(_ctx, State);
		EnterRule(_localctx, 392, RULE_patternFilterExpression);
		 paraphrases.Push("filter specification"); 
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2710;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,364,_ctx) ) {
			case 1:
				{
				State = 2708; _localctx.i = Match(IDENT);
				State = 2709; Match(EQUALS);
				}
				break;
			}
			State = 2712; classIdentifier();
			State = 2718;
			_la = _input.La(1);
			if (_la==LPAREN) {
				{
				State = 2713; Match(LPAREN);
				State = 2715;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 2714; expressionList();
					}
				}

				State = 2717; Match(RPAREN);
				}
			}

			State = 2721;
			_la = _input.La(1);
			if (_la==LBRACK) {
				{
				State = 2720; propertyExpression();
				}
			}

			State = 2724;
			_la = _input.La(1);
			if (_la==ATCHAR) {
				{
				State = 2723; patternFilterAnnotation();
				}
			}

			}
			_ctx.stop = _input.Lt(-1);
			 paraphrases.Pop(); 
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternFilterAnnotationContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode ATCHAR() { return GetToken(EsperEPL2GrammarParser.ATCHAR, 0); }
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public PatternFilterAnnotationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternFilterAnnotation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterPatternFilterAnnotation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitPatternFilterAnnotation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternFilterAnnotation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternFilterAnnotationContext patternFilterAnnotation() {
		PatternFilterAnnotationContext _localctx = new PatternFilterAnnotationContext(_ctx, State);
		EnterRule(_localctx, 394, RULE_patternFilterAnnotation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2726; Match(ATCHAR);
			State = 2727; _localctx.i = Match(IDENT);
			State = 2732;
			_la = _input.La(1);
			if (_la==LPAREN) {
				{
				State = 2728; Match(LPAREN);
				State = 2729; number();
				State = 2730; Match(RPAREN);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClassIdentifierContext : ParserRuleContext {
		public EscapableStrContext i1;
		public EscapableStrContext i2;
		public EscapableStrContext[] escapableStr() {
			return GetRuleContexts<EscapableStrContext>();
		}
		public EscapableStrContext escapableStr(int i) {
			return GetRuleContext<EscapableStrContext>(i);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public ClassIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_classIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterClassIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitClassIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClassIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ClassIdentifierContext classIdentifier() {
		ClassIdentifierContext _localctx = new ClassIdentifierContext(_ctx, State);
		EnterRule(_localctx, 396, RULE_classIdentifier);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2734; _localctx.i1 = escapableStr();
			State = 2739;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,370,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2735; Match(DOT);
					State = 2736; _localctx.i2 = escapableStr();
					}
					} 
				}
				State = 2741;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,370,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SlashIdentifierContext : ParserRuleContext {
		public IToken d;
		public EscapableStrContext i1;
		public EscapableStrContext i2;
		public EscapableStrContext[] escapableStr() {
			return GetRuleContexts<EscapableStrContext>();
		}
		public EscapableStrContext escapableStr(int i) {
			return GetRuleContext<EscapableStrContext>(i);
		}
		public ITerminalNode[] DIV() { return GetTokens(EsperEPL2GrammarParser.DIV); }
		public ITerminalNode DIV(int i) {
			return GetToken(EsperEPL2GrammarParser.DIV, i);
		}
		public SlashIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_slashIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSlashIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSlashIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSlashIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SlashIdentifierContext slashIdentifier() {
		SlashIdentifierContext _localctx = new SlashIdentifierContext(_ctx, State);
		EnterRule(_localctx, 398, RULE_slashIdentifier);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2743;
			_la = _input.La(1);
			if (_la==DIV) {
				{
				State = 2742; _localctx.d = Match(DIV);
				}
			}

			State = 2745; _localctx.i1 = escapableStr();
			State = 2750;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,372,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2746; Match(DIV);
					State = 2747; _localctx.i2 = escapableStr();
					}
					} 
				}
				State = 2752;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,372,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListWithNamedContext : ParserRuleContext {
		public ExpressionWithNamedContext[] expressionWithNamed() {
			return GetRuleContexts<ExpressionWithNamedContext>();
		}
		public ExpressionWithNamedContext expressionWithNamed(int i) {
			return GetRuleContext<ExpressionWithNamedContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionListWithNamedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionListWithNamed; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionListWithNamed(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionListWithNamed(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionListWithNamed(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListWithNamedContext expressionListWithNamed() {
		ExpressionListWithNamedContext _localctx = new ExpressionListWithNamedContext(_ctx, State);
		EnterRule(_localctx, 400, RULE_expressionListWithNamed);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2753; expressionWithNamed();
			State = 2758;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2754; Match(COMMA);
				State = 2755; expressionWithNamed();
				}
				}
				State = 2760;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListWithNamedWithTimeContext : ParserRuleContext {
		public ExpressionWithNamedWithTimeContext[] expressionWithNamedWithTime() {
			return GetRuleContexts<ExpressionWithNamedWithTimeContext>();
		}
		public ExpressionWithNamedWithTimeContext expressionWithNamedWithTime(int i) {
			return GetRuleContext<ExpressionWithNamedWithTimeContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionListWithNamedWithTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionListWithNamedWithTime; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionListWithNamedWithTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionListWithNamedWithTime(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionListWithNamedWithTime(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListWithNamedWithTimeContext expressionListWithNamedWithTime() {
		ExpressionListWithNamedWithTimeContext _localctx = new ExpressionListWithNamedWithTimeContext(_ctx, State);
		EnterRule(_localctx, 402, RULE_expressionListWithNamedWithTime);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2761; expressionWithNamedWithTime();
			State = 2766;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2762; Match(COMMA);
				State = 2763; expressionWithNamedWithTime();
				}
				}
				State = 2768;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithNamedContext : ParserRuleContext {
		public ExpressionNamedParameterContext expressionNamedParameter() {
			return GetRuleContext<ExpressionNamedParameterContext>(0);
		}
		public ExpressionWithTimeContext expressionWithTime() {
			return GetRuleContext<ExpressionWithTimeContext>(0);
		}
		public ExpressionWithNamedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithNamed; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithNamed(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithNamed(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithNamed(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithNamedContext expressionWithNamed() {
		ExpressionWithNamedContext _localctx = new ExpressionWithNamedContext(_ctx, State);
		EnterRule(_localctx, 404, RULE_expressionWithNamed);
		try {
			State = 2771;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,375,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2769; expressionNamedParameter();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2770; expressionWithTime();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithNamedWithTimeContext : ParserRuleContext {
		public ExpressionNamedParameterWithTimeContext expressionNamedParameterWithTime() {
			return GetRuleContext<ExpressionNamedParameterWithTimeContext>(0);
		}
		public ExpressionWithTimeInclLastContext expressionWithTimeInclLast() {
			return GetRuleContext<ExpressionWithTimeInclLastContext>(0);
		}
		public ExpressionWithNamedWithTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithNamedWithTime; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithNamedWithTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithNamedWithTime(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithNamedWithTime(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithNamedWithTimeContext expressionWithNamedWithTime() {
		ExpressionWithNamedWithTimeContext _localctx = new ExpressionWithNamedWithTimeContext(_ctx, State);
		EnterRule(_localctx, 406, RULE_expressionWithNamedWithTime);
		try {
			State = 2775;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,376,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2773; expressionNamedParameterWithTime();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2774; expressionWithTimeInclLast();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionNamedParameterContext : ParserRuleContext {
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ExpressionNamedParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionNamedParameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionNamedParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionNamedParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionNamedParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionNamedParameterContext expressionNamedParameter() {
		ExpressionNamedParameterContext _localctx = new ExpressionNamedParameterContext(_ctx, State);
		EnterRule(_localctx, 408, RULE_expressionNamedParameter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2777; Match(IDENT);
			State = 2778; Match(COLON);
			State = 2785;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,378,_ctx) ) {
			case 1:
				{
				State = 2779; expression();
				}
				break;

			case 2:
				{
				State = 2780; Match(LPAREN);
				State = 2782;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 2781; expressionList();
					}
				}

				State = 2784; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionNamedParameterWithTimeContext : ParserRuleContext {
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public ExpressionWithTimeContext expressionWithTime() {
			return GetRuleContext<ExpressionWithTimeContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ExpressionWithTimeListContext expressionWithTimeList() {
			return GetRuleContext<ExpressionWithTimeListContext>(0);
		}
		public ExpressionNamedParameterWithTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionNamedParameterWithTime; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionNamedParameterWithTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionNamedParameterWithTime(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionNamedParameterWithTime(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionNamedParameterWithTimeContext expressionNamedParameterWithTime() {
		ExpressionNamedParameterWithTimeContext _localctx = new ExpressionNamedParameterWithTimeContext(_ctx, State);
		EnterRule(_localctx, 410, RULE_expressionNamedParameterWithTime);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2787; Match(IDENT);
			State = 2788; Match(COLON);
			State = 2795;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,380,_ctx) ) {
			case 1:
				{
				State = 2789; expressionWithTime();
				}
				break;

			case 2:
				{
				State = 2790; Match(LPAREN);
				State = 2792;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << WINDOW) | (1L << ESCAPE) | (1L << NOT_EXPR) | (1L << EVERY_EXPR) | (1L << SUM) | (1L << AVG) | (1L << MAX) | (1L << MIN) | (1L << COALESCE) | (1L << MEDIAN) | (1L << STDDEV) | (1L << AVEDEV) | (1L << COUNT) | (1L << CASE) | (1L << OUTER) | (1L << JOIN) | (1L << LEFT) | (1L << RIGHT) | (1L << FULL) | (1L << EVENTS) | (1L << FIRST) | (1L << LAST) | (1L << ISTREAM) | (1L << UNIDIRECTIONAL) | (1L << RETAINUNION) | (1L << RETAININTERSECTION) | (1L << PATTERN))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (SQL - 64)) | (1L << (METADATASQL - 64)) | (1L << (PREVIOUS - 64)) | (1L << (PREVIOUSTAIL - 64)) | (1L << (PREVIOUSCOUNT - 64)) | (1L << (PREVIOUSWINDOW - 64)) | (1L << (PRIOR - 64)) | (1L << (EXISTS - 64)) | (1L << (WEEKDAY - 64)) | (1L << (LW - 64)) | (1L << (INSTANCEOF - 64)) | (1L << (TYPEOF - 64)) | (1L << (CAST - 64)) | (1L << (CURRENT_TIMESTAMP - 64)) | (1L << (SNAPSHOT - 64)) | (1L << (VARIABLE - 64)) | (1L << (TABLE - 64)) | (1L << (UNTIL - 64)) | (1L << (AT - 64)) | (1L << (INDEX - 64)) | (1L << (BOOLEAN_TRUE - 64)) | (1L << (BOOLEAN_FALSE - 64)) | (1L << (VALUE_NULL - 64)) | (1L << (DEFINE - 64)) | (1L << (PARTITION - 64)) | (1L << (MATCHES - 64)) | (1L << (FOR - 64)) | (1L << (WHILE - 64)) | (1L << (USING - 64)) | (1L << (MERGE - 64)) | (1L << (MATCHED - 64)) | (1L << (NEWKW - 64)) | (1L << (CONTEXT - 64)))) != 0) || ((((_la - 131)) & ~0x3f) == 0 && ((1L << (_la - 131)) & ((1L << (GROUPING - 131)) | (1L << (GROUPING_ID - 131)) | (1L << (QUESTION - 131)) | (1L << (LPAREN - 131)) | (1L << (LBRACK - 131)) | (1L << (LCURLY - 131)) | (1L << (PLUS - 131)) | (1L << (MINUS - 131)) | (1L << (STAR - 131)) | (1L << (TICKED_STRING_LITERAL - 131)) | (1L << (QUOTED_STRING_LITERAL - 131)) | (1L << (STRING_LITERAL - 131)) | (1L << (IDENT - 131)) | (1L << (IntegerLiteral - 131)) | (1L << (FloatingPointLiteral - 131)))) != 0)) {
					{
					State = 2791; expressionWithTimeList();
					}
				}

				State = 2794; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListContext expressionList() {
		ExpressionListContext _localctx = new ExpressionListContext(_ctx, State);
		EnterRule(_localctx, 412, RULE_expressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2797; expression();
			State = 2802;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2798; Match(COMMA);
				State = 2799; expression();
				}
				}
				State = 2804;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithTimeListContext : ParserRuleContext {
		public ExpressionWithTimeInclLastContext[] expressionWithTimeInclLast() {
			return GetRuleContexts<ExpressionWithTimeInclLastContext>();
		}
		public ExpressionWithTimeInclLastContext expressionWithTimeInclLast(int i) {
			return GetRuleContext<ExpressionWithTimeInclLastContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public ExpressionWithTimeListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithTimeList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithTimeList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithTimeList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithTimeList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithTimeListContext expressionWithTimeList() {
		ExpressionWithTimeListContext _localctx = new ExpressionWithTimeListContext(_ctx, State);
		EnterRule(_localctx, 414, RULE_expressionWithTimeList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2805; expressionWithTimeInclLast();
			State = 2810;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2806; Match(COMMA);
				State = 2807; expressionWithTimeInclLast();
				}
				}
				State = 2812;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithTimeContext : ParserRuleContext {
		public LastWeekdayOperandContext lastWeekdayOperand() {
			return GetRuleContext<LastWeekdayOperandContext>(0);
		}
		public TimePeriodContext timePeriod() {
			return GetRuleContext<TimePeriodContext>(0);
		}
		public ExpressionQualifyableContext expressionQualifyable() {
			return GetRuleContext<ExpressionQualifyableContext>(0);
		}
		public RangeOperandContext rangeOperand() {
			return GetRuleContext<RangeOperandContext>(0);
		}
		public FrequencyOperandContext frequencyOperand() {
			return GetRuleContext<FrequencyOperandContext>(0);
		}
		public LastOperatorContext lastOperator() {
			return GetRuleContext<LastOperatorContext>(0);
		}
		public WeekDayOperatorContext weekDayOperator() {
			return GetRuleContext<WeekDayOperatorContext>(0);
		}
		public NumericParameterListContext numericParameterList() {
			return GetRuleContext<NumericParameterListContext>(0);
		}
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public PropertyStreamSelectorContext propertyStreamSelector() {
			return GetRuleContext<PropertyStreamSelectorContext>(0);
		}
		public ExpressionWithTimeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithTime; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithTime(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithTime(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithTimeContext expressionWithTime() {
		ExpressionWithTimeContext _localctx = new ExpressionWithTimeContext(_ctx, State);
		EnterRule(_localctx, 416, RULE_expressionWithTime);
		try {
			State = 2823;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,383,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2813; lastWeekdayOperand();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2814; timePeriod();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2815; expressionQualifyable();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2816; rangeOperand();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2817; frequencyOperand();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2818; lastOperator();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2819; weekDayOperator();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2820; numericParameterList();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2821; Match(STAR);
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2822; propertyStreamSelector();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionWithTimeInclLastContext : ParserRuleContext {
		public LastOperandContext lastOperand() {
			return GetRuleContext<LastOperandContext>(0);
		}
		public ExpressionWithTimeContext expressionWithTime() {
			return GetRuleContext<ExpressionWithTimeContext>(0);
		}
		public ExpressionWithTimeInclLastContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionWithTimeInclLast; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionWithTimeInclLast(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionWithTimeInclLast(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionWithTimeInclLast(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionWithTimeInclLastContext expressionWithTimeInclLast() {
		ExpressionWithTimeInclLastContext _localctx = new ExpressionWithTimeInclLastContext(_ctx, State);
		EnterRule(_localctx, 418, RULE_expressionWithTimeInclLast);
		try {
			State = 2827;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,384,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2825; lastOperand();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2826; expressionWithTime();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionQualifyableContext : ParserRuleContext {
		public IToken a;
		public IToken d;
		public IToken s;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASC() { return GetToken(EsperEPL2GrammarParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(EsperEPL2GrammarParser.DESC, 0); }
		public ITerminalNode TIMEPERIOD_SECONDS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SECONDS, 0); }
		public ITerminalNode TIMEPERIOD_SECOND() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SECOND, 0); }
		public ITerminalNode TIMEPERIOD_SEC() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SEC, 0); }
		public ExpressionQualifyableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionQualifyable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterExpressionQualifyable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitExpressionQualifyable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionQualifyable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionQualifyableContext expressionQualifyable() {
		ExpressionQualifyableContext _localctx = new ExpressionQualifyableContext(_ctx, State);
		EnterRule(_localctx, 420, RULE_expressionQualifyable);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2829; expression();
			State = 2835;
			switch (_input.La(1)) {
			case ASC:
				{
				State = 2830; _localctx.a = Match(ASC);
				}
				break;
			case DESC:
				{
				State = 2831; _localctx.d = Match(DESC);
				}
				break;
			case TIMEPERIOD_SECONDS:
				{
				State = 2832; _localctx.s = Match(TIMEPERIOD_SECONDS);
				}
				break;
			case TIMEPERIOD_SECOND:
				{
				State = 2833; _localctx.s = Match(TIMEPERIOD_SECOND);
				}
				break;
			case TIMEPERIOD_SEC:
				{
				State = 2834; _localctx.s = Match(TIMEPERIOD_SEC);
				}
				break;
			case RPAREN:
			case COMMA:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LastWeekdayOperandContext : ParserRuleContext {
		public ITerminalNode LW() { return GetToken(EsperEPL2GrammarParser.LW, 0); }
		public LastWeekdayOperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lastWeekdayOperand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLastWeekdayOperand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLastWeekdayOperand(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLastWeekdayOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LastWeekdayOperandContext lastWeekdayOperand() {
		LastWeekdayOperandContext _localctx = new LastWeekdayOperandContext(_ctx, State);
		EnterRule(_localctx, 422, RULE_lastWeekdayOperand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2837; Match(LW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LastOperandContext : ParserRuleContext {
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public LastOperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lastOperand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLastOperand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLastOperand(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLastOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LastOperandContext lastOperand() {
		LastOperandContext _localctx = new LastOperandContext(_ctx, State);
		EnterRule(_localctx, 424, RULE_lastOperand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2839; Match(LAST);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FrequencyOperandContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode STAR() { return GetToken(EsperEPL2GrammarParser.STAR, 0); }
		public ITerminalNode DIV() { return GetToken(EsperEPL2GrammarParser.DIV, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public FrequencyOperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_frequencyOperand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterFrequencyOperand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitFrequencyOperand(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrequencyOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FrequencyOperandContext frequencyOperand() {
		FrequencyOperandContext _localctx = new FrequencyOperandContext(_ctx, State);
		EnterRule(_localctx, 426, RULE_frequencyOperand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2841; Match(STAR);
			State = 2842; Match(DIV);
			State = 2846;
			switch (_input.La(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2843; number();
				}
				break;
			case IDENT:
				{
				State = 2844; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2845; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeOperandContext : ParserRuleContext {
		public NumberContext n1;
		public IToken i1;
		public SubstitutionContext s1;
		public NumberContext n2;
		public IToken i2;
		public SubstitutionContext s2;
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public NumberContext[] number() {
			return GetRuleContexts<NumberContext>();
		}
		public NumberContext number(int i) {
			return GetRuleContext<NumberContext>(i);
		}
		public ITerminalNode[] IDENT() { return GetTokens(EsperEPL2GrammarParser.IDENT); }
		public ITerminalNode IDENT(int i) {
			return GetToken(EsperEPL2GrammarParser.IDENT, i);
		}
		public SubstitutionContext[] substitution() {
			return GetRuleContexts<SubstitutionContext>();
		}
		public SubstitutionContext substitution(int i) {
			return GetRuleContext<SubstitutionContext>(i);
		}
		public RangeOperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rangeOperand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterRangeOperand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitRangeOperand(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRangeOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RangeOperandContext rangeOperand() {
		RangeOperandContext _localctx = new RangeOperandContext(_ctx, State);
		EnterRule(_localctx, 428, RULE_rangeOperand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2851;
			switch (_input.La(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2848; _localctx.n1 = number();
				}
				break;
			case IDENT:
				{
				State = 2849; _localctx.i1 = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2850; _localctx.s1 = substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2853; Match(COLON);
			State = 2857;
			switch (_input.La(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2854; _localctx.n2 = number();
				}
				break;
			case IDENT:
				{
				State = 2855; _localctx.i2 = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2856; _localctx.s2 = substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LastOperatorContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public LastOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lastOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterLastOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitLastOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLastOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LastOperatorContext lastOperator() {
		LastOperatorContext _localctx = new LastOperatorContext(_ctx, State);
		EnterRule(_localctx, 430, RULE_lastOperator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2862;
			switch (_input.La(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2859; number();
				}
				break;
			case IDENT:
				{
				State = 2860; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2861; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2864; Match(LAST);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WeekDayOperatorContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode WEEKDAY() { return GetToken(EsperEPL2GrammarParser.WEEKDAY, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public WeekDayOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_weekDayOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterWeekDayOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitWeekDayOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWeekDayOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WeekDayOperatorContext weekDayOperator() {
		WeekDayOperatorContext _localctx = new WeekDayOperatorContext(_ctx, State);
		EnterRule(_localctx, 432, RULE_weekDayOperator);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2869;
			switch (_input.La(1)) {
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 2866; number();
				}
				break;
			case IDENT:
				{
				State = 2867; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 2868; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2871; Match(WEEKDAY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericParameterListContext : ParserRuleContext {
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public NumericListParameterContext[] numericListParameter() {
			return GetRuleContexts<NumericListParameterContext>();
		}
		public NumericListParameterContext numericListParameter(int i) {
			return GetRuleContext<NumericListParameterContext>(i);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public NumericParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numericParameterList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNumericParameterList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNumericParameterList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumericParameterList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericParameterListContext numericParameterList() {
		NumericParameterListContext _localctx = new NumericParameterListContext(_ctx, State);
		EnterRule(_localctx, 434, RULE_numericParameterList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2873; Match(LBRACK);
			State = 2874; numericListParameter();
			State = 2879;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2875; Match(COMMA);
				State = 2876; numericListParameter();
				}
				}
				State = 2881;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2882; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericListParameterContext : ParserRuleContext {
		public RangeOperandContext rangeOperand() {
			return GetRuleContext<RangeOperandContext>(0);
		}
		public FrequencyOperandContext frequencyOperand() {
			return GetRuleContext<FrequencyOperandContext>(0);
		}
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public NumericListParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numericListParameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNumericListParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNumericListParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumericListParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericListParameterContext numericListParameter() {
		NumericListParameterContext _localctx = new NumericListParameterContext(_ctx, State);
		EnterRule(_localctx, 436, RULE_numericListParameter);
		try {
			State = 2887;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,392,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2884; rangeOperand();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2885; frequencyOperand();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2886; numberconstant();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventPropertyContext : ParserRuleContext {
		public EventPropertyAtomicContext[] eventPropertyAtomic() {
			return GetRuleContexts<EventPropertyAtomicContext>();
		}
		public EventPropertyAtomicContext eventPropertyAtomic(int i) {
			return GetRuleContext<EventPropertyAtomicContext>(i);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public EventPropertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventProperty; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventProperty(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventProperty(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventProperty(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventPropertyContext eventProperty() {
		EventPropertyContext _localctx = new EventPropertyContext(_ctx, State);
		EnterRule(_localctx, 438, RULE_eventProperty);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2889; eventPropertyAtomic();
			State = 2894;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==DOT) {
				{
				{
				State = 2890; Match(DOT);
				State = 2891; eventPropertyAtomic();
				}
				}
				State = 2896;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventPropertyAtomicContext : ParserRuleContext {
		public IToken lb;
		public NumberContext ni;
		public IToken q;
		public IToken lp;
		public IToken s;
		public IToken q1;
		public EventPropertyIdentContext eventPropertyIdent() {
			return GetRuleContext<EventPropertyIdentContext>(0);
		}
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public ITerminalNode RPAREN() { return GetToken(EsperEPL2GrammarParser.RPAREN, 0); }
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(EsperEPL2GrammarParser.LPAREN, 0); }
		public ITerminalNode QUESTION() { return GetToken(EsperEPL2GrammarParser.QUESTION, 0); }
		public ITerminalNode STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.STRING_LITERAL, 0); }
		public ITerminalNode QUOTED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.QUOTED_STRING_LITERAL, 0); }
		public EventPropertyAtomicContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventPropertyAtomic; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventPropertyAtomic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventPropertyAtomic(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventPropertyAtomic(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventPropertyAtomicContext eventPropertyAtomic() {
		EventPropertyAtomicContext _localctx = new EventPropertyAtomicContext(_ctx, State);
		EnterRule(_localctx, 440, RULE_eventPropertyAtomic);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2897; eventPropertyIdent();
			State = 2914;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,397,_ctx) ) {
			case 1:
				{
				State = 2898; _localctx.lb = Match(LBRACK);
				State = 2899; _localctx.ni = number();
				State = 2900; Match(RBRACK);
				State = 2902;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,394,_ctx) ) {
				case 1:
					{
					State = 2901; _localctx.q = Match(QUESTION);
					}
					break;
				}
				}
				break;

			case 2:
				{
				State = 2904; _localctx.lp = Match(LPAREN);
				State = 2907;
				switch (_input.La(1)) {
				case STRING_LITERAL:
					{
					State = 2905; _localctx.s = Match(STRING_LITERAL);
					}
					break;
				case QUOTED_STRING_LITERAL:
					{
					State = 2906; _localctx.s = Match(QUOTED_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2909; Match(RPAREN);
				State = 2911;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,396,_ctx) ) {
				case 1:
					{
					State = 2910; _localctx.q = Match(QUESTION);
					}
					break;
				}
				}
				break;

			case 3:
				{
				State = 2913; _localctx.q1 = Match(QUESTION);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EventPropertyIdentContext : ParserRuleContext {
		public KeywordAllowedIdentContext ipi;
		public KeywordAllowedIdentContext ipi2;
		public KeywordAllowedIdentContext[] keywordAllowedIdent() {
			return GetRuleContexts<KeywordAllowedIdentContext>();
		}
		public KeywordAllowedIdentContext keywordAllowedIdent(int i) {
			return GetRuleContext<KeywordAllowedIdentContext>(i);
		}
		public ITerminalNode[] ESCAPECHAR() { return GetTokens(EsperEPL2GrammarParser.ESCAPECHAR); }
		public ITerminalNode ESCAPECHAR(int i) {
			return GetToken(EsperEPL2GrammarParser.ESCAPECHAR, i);
		}
		public ITerminalNode[] DOT() { return GetTokens(EsperEPL2GrammarParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(EsperEPL2GrammarParser.DOT, i);
		}
		public EventPropertyIdentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eventPropertyIdent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEventPropertyIdent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEventPropertyIdent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEventPropertyIdent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EventPropertyIdentContext eventPropertyIdent() {
		EventPropertyIdentContext _localctx = new EventPropertyIdentContext(_ctx, State);
		EnterRule(_localctx, 442, RULE_eventPropertyIdent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2916; _localctx.ipi = keywordAllowedIdent();
			State = 2924;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ESCAPECHAR) {
				{
				{
				State = 2917; Match(ESCAPECHAR);
				State = 2918; Match(DOT);
				State = 2920;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,398,_ctx) ) {
				case 1:
					{
					State = 2919; _localctx.ipi2 = keywordAllowedIdent();
					}
					break;
				}
				}
				}
				State = 2926;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordAllowedIdentContext : ParserRuleContext {
		public IToken i1;
		public IToken i2;
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode TICKED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.TICKED_STRING_LITERAL, 0); }
		public ITerminalNode AT() { return GetToken(EsperEPL2GrammarParser.AT, 0); }
		public ITerminalNode COUNT() { return GetToken(EsperEPL2GrammarParser.COUNT, 0); }
		public ITerminalNode ESCAPE() { return GetToken(EsperEPL2GrammarParser.ESCAPE, 0); }
		public ITerminalNode EVERY_EXPR() { return GetToken(EsperEPL2GrammarParser.EVERY_EXPR, 0); }
		public ITerminalNode SUM() { return GetToken(EsperEPL2GrammarParser.SUM, 0); }
		public ITerminalNode AVG() { return GetToken(EsperEPL2GrammarParser.AVG, 0); }
		public ITerminalNode MAX() { return GetToken(EsperEPL2GrammarParser.MAX, 0); }
		public ITerminalNode MIN() { return GetToken(EsperEPL2GrammarParser.MIN, 0); }
		public ITerminalNode COALESCE() { return GetToken(EsperEPL2GrammarParser.COALESCE, 0); }
		public ITerminalNode MEDIAN() { return GetToken(EsperEPL2GrammarParser.MEDIAN, 0); }
		public ITerminalNode STDDEV() { return GetToken(EsperEPL2GrammarParser.STDDEV, 0); }
		public ITerminalNode AVEDEV() { return GetToken(EsperEPL2GrammarParser.AVEDEV, 0); }
		public ITerminalNode EVENTS() { return GetToken(EsperEPL2GrammarParser.EVENTS, 0); }
		public ITerminalNode FIRST() { return GetToken(EsperEPL2GrammarParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(EsperEPL2GrammarParser.LAST, 0); }
		public ITerminalNode WHILE() { return GetToken(EsperEPL2GrammarParser.WHILE, 0); }
		public ITerminalNode MERGE() { return GetToken(EsperEPL2GrammarParser.MERGE, 0); }
		public ITerminalNode MATCHED() { return GetToken(EsperEPL2GrammarParser.MATCHED, 0); }
		public ITerminalNode UNIDIRECTIONAL() { return GetToken(EsperEPL2GrammarParser.UNIDIRECTIONAL, 0); }
		public ITerminalNode RETAINUNION() { return GetToken(EsperEPL2GrammarParser.RETAINUNION, 0); }
		public ITerminalNode RETAININTERSECTION() { return GetToken(EsperEPL2GrammarParser.RETAININTERSECTION, 0); }
		public ITerminalNode UNTIL() { return GetToken(EsperEPL2GrammarParser.UNTIL, 0); }
		public ITerminalNode PATTERN() { return GetToken(EsperEPL2GrammarParser.PATTERN, 0); }
		public ITerminalNode SQL() { return GetToken(EsperEPL2GrammarParser.SQL, 0); }
		public ITerminalNode METADATASQL() { return GetToken(EsperEPL2GrammarParser.METADATASQL, 0); }
		public ITerminalNode PREVIOUS() { return GetToken(EsperEPL2GrammarParser.PREVIOUS, 0); }
		public ITerminalNode PREVIOUSTAIL() { return GetToken(EsperEPL2GrammarParser.PREVIOUSTAIL, 0); }
		public ITerminalNode PRIOR() { return GetToken(EsperEPL2GrammarParser.PRIOR, 0); }
		public ITerminalNode WEEKDAY() { return GetToken(EsperEPL2GrammarParser.WEEKDAY, 0); }
		public ITerminalNode LW() { return GetToken(EsperEPL2GrammarParser.LW, 0); }
		public ITerminalNode INSTANCEOF() { return GetToken(EsperEPL2GrammarParser.INSTANCEOF, 0); }
		public ITerminalNode TYPEOF() { return GetToken(EsperEPL2GrammarParser.TYPEOF, 0); }
		public ITerminalNode CAST() { return GetToken(EsperEPL2GrammarParser.CAST, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(EsperEPL2GrammarParser.SNAPSHOT, 0); }
		public ITerminalNode VARIABLE() { return GetToken(EsperEPL2GrammarParser.VARIABLE, 0); }
		public ITerminalNode TABLE() { return GetToken(EsperEPL2GrammarParser.TABLE, 0); }
		public ITerminalNode INDEX() { return GetToken(EsperEPL2GrammarParser.INDEX, 0); }
		public ITerminalNode WINDOW() { return GetToken(EsperEPL2GrammarParser.WINDOW, 0); }
		public ITerminalNode LEFT() { return GetToken(EsperEPL2GrammarParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(EsperEPL2GrammarParser.RIGHT, 0); }
		public ITerminalNode OUTER() { return GetToken(EsperEPL2GrammarParser.OUTER, 0); }
		public ITerminalNode FULL() { return GetToken(EsperEPL2GrammarParser.FULL, 0); }
		public ITerminalNode JOIN() { return GetToken(EsperEPL2GrammarParser.JOIN, 0); }
		public ITerminalNode DEFINE() { return GetToken(EsperEPL2GrammarParser.DEFINE, 0); }
		public ITerminalNode PARTITION() { return GetToken(EsperEPL2GrammarParser.PARTITION, 0); }
		public ITerminalNode MATCHES() { return GetToken(EsperEPL2GrammarParser.MATCHES, 0); }
		public ITerminalNode CONTEXT() { return GetToken(EsperEPL2GrammarParser.CONTEXT, 0); }
		public ITerminalNode FOR() { return GetToken(EsperEPL2GrammarParser.FOR, 0); }
		public ITerminalNode USING() { return GetToken(EsperEPL2GrammarParser.USING, 0); }
		public KeywordAllowedIdentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keywordAllowedIdent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterKeywordAllowedIdent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitKeywordAllowedIdent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeywordAllowedIdent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordAllowedIdentContext keywordAllowedIdent() {
		KeywordAllowedIdentContext _localctx = new KeywordAllowedIdentContext(_ctx, State);
		EnterRule(_localctx, 444, RULE_keywordAllowedIdent);
		try {
			State = 2978;
			switch (_input.La(1)) {
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2927; _localctx.i1 = Match(IDENT);
				}
				break;
			case TICKED_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2928; _localctx.i2 = Match(TICKED_STRING_LITERAL);
				}
				break;
			case AT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2929; Match(AT);
				}
				break;
			case COUNT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2930; Match(COUNT);
				}
				break;
			case ESCAPE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2931; Match(ESCAPE);
				}
				break;
			case EVERY_EXPR:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2932; Match(EVERY_EXPR);
				}
				break;
			case SUM:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2933; Match(SUM);
				}
				break;
			case AVG:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2934; Match(AVG);
				}
				break;
			case MAX:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2935; Match(MAX);
				}
				break;
			case MIN:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2936; Match(MIN);
				}
				break;
			case COALESCE:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2937; Match(COALESCE);
				}
				break;
			case MEDIAN:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2938; Match(MEDIAN);
				}
				break;
			case STDDEV:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2939; Match(STDDEV);
				}
				break;
			case AVEDEV:
				EnterOuterAlt(_localctx, 14);
				{
				State = 2940; Match(AVEDEV);
				}
				break;
			case EVENTS:
				EnterOuterAlt(_localctx, 15);
				{
				State = 2941; Match(EVENTS);
				}
				break;
			case FIRST:
				EnterOuterAlt(_localctx, 16);
				{
				State = 2942; Match(FIRST);
				}
				break;
			case LAST:
				EnterOuterAlt(_localctx, 17);
				{
				State = 2943; Match(LAST);
				}
				break;
			case WHILE:
				EnterOuterAlt(_localctx, 18);
				{
				State = 2944; Match(WHILE);
				}
				break;
			case MERGE:
				EnterOuterAlt(_localctx, 19);
				{
				State = 2945; Match(MERGE);
				}
				break;
			case MATCHED:
				EnterOuterAlt(_localctx, 20);
				{
				State = 2946; Match(MATCHED);
				}
				break;
			case UNIDIRECTIONAL:
				EnterOuterAlt(_localctx, 21);
				{
				State = 2947; Match(UNIDIRECTIONAL);
				}
				break;
			case RETAINUNION:
				EnterOuterAlt(_localctx, 22);
				{
				State = 2948; Match(RETAINUNION);
				}
				break;
			case RETAININTERSECTION:
				EnterOuterAlt(_localctx, 23);
				{
				State = 2949; Match(RETAININTERSECTION);
				}
				break;
			case UNTIL:
				EnterOuterAlt(_localctx, 24);
				{
				State = 2950; Match(UNTIL);
				}
				break;
			case PATTERN:
				EnterOuterAlt(_localctx, 25);
				{
				State = 2951; Match(PATTERN);
				}
				break;
			case SQL:
				EnterOuterAlt(_localctx, 26);
				{
				State = 2952; Match(SQL);
				}
				break;
			case METADATASQL:
				EnterOuterAlt(_localctx, 27);
				{
				State = 2953; Match(METADATASQL);
				}
				break;
			case PREVIOUS:
				EnterOuterAlt(_localctx, 28);
				{
				State = 2954; Match(PREVIOUS);
				}
				break;
			case PREVIOUSTAIL:
				EnterOuterAlt(_localctx, 29);
				{
				State = 2955; Match(PREVIOUSTAIL);
				}
				break;
			case PRIOR:
				EnterOuterAlt(_localctx, 30);
				{
				State = 2956; Match(PRIOR);
				}
				break;
			case WEEKDAY:
				EnterOuterAlt(_localctx, 31);
				{
				State = 2957; Match(WEEKDAY);
				}
				break;
			case LW:
				EnterOuterAlt(_localctx, 32);
				{
				State = 2958; Match(LW);
				}
				break;
			case INSTANCEOF:
				EnterOuterAlt(_localctx, 33);
				{
				State = 2959; Match(INSTANCEOF);
				}
				break;
			case TYPEOF:
				EnterOuterAlt(_localctx, 34);
				{
				State = 2960; Match(TYPEOF);
				}
				break;
			case CAST:
				EnterOuterAlt(_localctx, 35);
				{
				State = 2961; Match(CAST);
				}
				break;
			case SNAPSHOT:
				EnterOuterAlt(_localctx, 36);
				{
				State = 2962; Match(SNAPSHOT);
				}
				break;
			case VARIABLE:
				EnterOuterAlt(_localctx, 37);
				{
				State = 2963; Match(VARIABLE);
				}
				break;
			case TABLE:
				EnterOuterAlt(_localctx, 38);
				{
				State = 2964; Match(TABLE);
				}
				break;
			case INDEX:
				EnterOuterAlt(_localctx, 39);
				{
				State = 2965; Match(INDEX);
				}
				break;
			case WINDOW:
				EnterOuterAlt(_localctx, 40);
				{
				State = 2966; Match(WINDOW);
				}
				break;
			case LEFT:
				EnterOuterAlt(_localctx, 41);
				{
				State = 2967; Match(LEFT);
				}
				break;
			case RIGHT:
				EnterOuterAlt(_localctx, 42);
				{
				State = 2968; Match(RIGHT);
				}
				break;
			case OUTER:
				EnterOuterAlt(_localctx, 43);
				{
				State = 2969; Match(OUTER);
				}
				break;
			case FULL:
				EnterOuterAlt(_localctx, 44);
				{
				State = 2970; Match(FULL);
				}
				break;
			case JOIN:
				EnterOuterAlt(_localctx, 45);
				{
				State = 2971; Match(JOIN);
				}
				break;
			case DEFINE:
				EnterOuterAlt(_localctx, 46);
				{
				State = 2972; Match(DEFINE);
				}
				break;
			case PARTITION:
				EnterOuterAlt(_localctx, 47);
				{
				State = 2973; Match(PARTITION);
				}
				break;
			case MATCHES:
				EnterOuterAlt(_localctx, 48);
				{
				State = 2974; Match(MATCHES);
				}
				break;
			case CONTEXT:
				EnterOuterAlt(_localctx, 49);
				{
				State = 2975; Match(CONTEXT);
				}
				break;
			case FOR:
				EnterOuterAlt(_localctx, 50);
				{
				State = 2976; Match(FOR);
				}
				break;
			case USING:
				EnterOuterAlt(_localctx, 51);
				{
				State = 2977; Match(USING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EscapableStrContext : ParserRuleContext {
		public IToken i1;
		public IToken i2;
		public IToken i3;
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode EVENTS() { return GetToken(EsperEPL2GrammarParser.EVENTS, 0); }
		public ITerminalNode TICKED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.TICKED_STRING_LITERAL, 0); }
		public EscapableStrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_escapableStr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEscapableStr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEscapableStr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEscapableStr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EscapableStrContext escapableStr() {
		EscapableStrContext _localctx = new EscapableStrContext(_ctx, State);
		EnterRule(_localctx, 446, RULE_escapableStr);
		try {
			State = 2983;
			switch (_input.La(1)) {
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2980; _localctx.i1 = Match(IDENT);
				}
				break;
			case EVENTS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2981; _localctx.i2 = Match(EVENTS);
				}
				break;
			case TICKED_STRING_LITERAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2982; _localctx.i3 = Match(TICKED_STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EscapableIdentContext : ParserRuleContext {
		public IToken t;
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public ITerminalNode TICKED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.TICKED_STRING_LITERAL, 0); }
		public EscapableIdentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_escapableIdent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterEscapableIdent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitEscapableIdent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEscapableIdent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EscapableIdentContext escapableIdent() {
		EscapableIdentContext _localctx = new EscapableIdentContext(_ctx, State);
		EnterRule(_localctx, 448, RULE_escapableIdent);
		try {
			State = 2987;
			switch (_input.La(1)) {
			case IDENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2985; Match(IDENT);
				}
				break;
			case TICKED_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2986; _localctx.t = Match(TICKED_STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimePeriodContext : ParserRuleContext {
		public YearPartContext yearPart() {
			return GetRuleContext<YearPartContext>(0);
		}
		public MonthPartContext monthPart() {
			return GetRuleContext<MonthPartContext>(0);
		}
		public WeekPartContext weekPart() {
			return GetRuleContext<WeekPartContext>(0);
		}
		public DayPartContext dayPart() {
			return GetRuleContext<DayPartContext>(0);
		}
		public HourPartContext hourPart() {
			return GetRuleContext<HourPartContext>(0);
		}
		public MinutePartContext minutePart() {
			return GetRuleContext<MinutePartContext>(0);
		}
		public SecondPartContext secondPart() {
			return GetRuleContext<SecondPartContext>(0);
		}
		public MillisecondPartContext millisecondPart() {
			return GetRuleContext<MillisecondPartContext>(0);
		}
		public TimePeriodContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timePeriod; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterTimePeriod(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitTimePeriod(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimePeriod(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TimePeriodContext timePeriod() {
		TimePeriodContext _localctx = new TimePeriodContext(_ctx, State);
		EnterRule(_localctx, 450, RULE_timePeriod);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3081;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,431,_ctx) ) {
			case 1:
				{
				State = 2989; yearPart();
				State = 2991;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,403,_ctx) ) {
				case 1:
					{
					State = 2990; monthPart();
					}
					break;
				}
				State = 2994;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,404,_ctx) ) {
				case 1:
					{
					State = 2993; weekPart();
					}
					break;
				}
				State = 2997;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,405,_ctx) ) {
				case 1:
					{
					State = 2996; dayPart();
					}
					break;
				}
				State = 3000;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,406,_ctx) ) {
				case 1:
					{
					State = 2999; hourPart();
					}
					break;
				}
				State = 3003;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,407,_ctx) ) {
				case 1:
					{
					State = 3002; minutePart();
					}
					break;
				}
				State = 3006;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,408,_ctx) ) {
				case 1:
					{
					State = 3005; secondPart();
					}
					break;
				}
				State = 3009;
				_la = _input.La(1);
				if (((((_la - 140)) & ~0x3f) == 0 && ((1L << (_la - 140)) & ((1L << (QUESTION - 140)) | (1L << (PLUS - 140)) | (1L << (MINUS - 140)) | (1L << (IDENT - 140)) | (1L << (IntegerLiteral - 140)) | (1L << (FloatingPointLiteral - 140)))) != 0)) {
					{
					State = 3008; millisecondPart();
					}
				}

				}
				break;

			case 2:
				{
				State = 3011; monthPart();
				State = 3013;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,410,_ctx) ) {
				case 1:
					{
					State = 3012; weekPart();
					}
					break;
				}
				State = 3016;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,411,_ctx) ) {
				case 1:
					{
					State = 3015; dayPart();
					}
					break;
				}
				State = 3019;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,412,_ctx) ) {
				case 1:
					{
					State = 3018; hourPart();
					}
					break;
				}
				State = 3022;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,413,_ctx) ) {
				case 1:
					{
					State = 3021; minutePart();
					}
					break;
				}
				State = 3025;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,414,_ctx) ) {
				case 1:
					{
					State = 3024; secondPart();
					}
					break;
				}
				State = 3028;
				_la = _input.La(1);
				if (((((_la - 140)) & ~0x3f) == 0 && ((1L << (_la - 140)) & ((1L << (QUESTION - 140)) | (1L << (PLUS - 140)) | (1L << (MINUS - 140)) | (1L << (IDENT - 140)) | (1L << (IntegerLiteral - 140)) | (1L << (FloatingPointLiteral - 140)))) != 0)) {
					{
					State = 3027; millisecondPart();
					}
				}

				}
				break;

			case 3:
				{
				State = 3030; weekPart();
				State = 3032;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,416,_ctx) ) {
				case 1:
					{
					State = 3031; dayPart();
					}
					break;
				}
				State = 3035;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,417,_ctx) ) {
				case 1:
					{
					State = 3034; hourPart();
					}
					break;
				}
				State = 3038;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,418,_ctx) ) {
				case 1:
					{
					State = 3037; minutePart();
					}
					break;
				}
				State = 3041;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,419,_ctx) ) {
				case 1:
					{
					State = 3040; secondPart();
					}
					break;
				}
				State = 3044;
				_la = _input.La(1);
				if (((((_la - 140)) & ~0x3f) == 0 && ((1L << (_la - 140)) & ((1L << (QUESTION - 140)) | (1L << (PLUS - 140)) | (1L << (MINUS - 140)) | (1L << (IDENT - 140)) | (1L << (IntegerLiteral - 140)) | (1L << (FloatingPointLiteral - 140)))) != 0)) {
					{
					State = 3043; millisecondPart();
					}
				}

				}
				break;

			case 4:
				{
				State = 3046; dayPart();
				State = 3048;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,421,_ctx) ) {
				case 1:
					{
					State = 3047; hourPart();
					}
					break;
				}
				State = 3051;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,422,_ctx) ) {
				case 1:
					{
					State = 3050; minutePart();
					}
					break;
				}
				State = 3054;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,423,_ctx) ) {
				case 1:
					{
					State = 3053; secondPart();
					}
					break;
				}
				State = 3057;
				_la = _input.La(1);
				if (((((_la - 140)) & ~0x3f) == 0 && ((1L << (_la - 140)) & ((1L << (QUESTION - 140)) | (1L << (PLUS - 140)) | (1L << (MINUS - 140)) | (1L << (IDENT - 140)) | (1L << (IntegerLiteral - 140)) | (1L << (FloatingPointLiteral - 140)))) != 0)) {
					{
					State = 3056; millisecondPart();
					}
				}

				}
				break;

			case 5:
				{
				State = 3059; hourPart();
				State = 3061;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,425,_ctx) ) {
				case 1:
					{
					State = 3060; minutePart();
					}
					break;
				}
				State = 3064;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,426,_ctx) ) {
				case 1:
					{
					State = 3063; secondPart();
					}
					break;
				}
				State = 3067;
				_la = _input.La(1);
				if (((((_la - 140)) & ~0x3f) == 0 && ((1L << (_la - 140)) & ((1L << (QUESTION - 140)) | (1L << (PLUS - 140)) | (1L << (MINUS - 140)) | (1L << (IDENT - 140)) | (1L << (IntegerLiteral - 140)) | (1L << (FloatingPointLiteral - 140)))) != 0)) {
					{
					State = 3066; millisecondPart();
					}
				}

				}
				break;

			case 6:
				{
				State = 3069; minutePart();
				State = 3071;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,428,_ctx) ) {
				case 1:
					{
					State = 3070; secondPart();
					}
					break;
				}
				State = 3074;
				_la = _input.La(1);
				if (((((_la - 140)) & ~0x3f) == 0 && ((1L << (_la - 140)) & ((1L << (QUESTION - 140)) | (1L << (PLUS - 140)) | (1L << (MINUS - 140)) | (1L << (IDENT - 140)) | (1L << (IntegerLiteral - 140)) | (1L << (FloatingPointLiteral - 140)))) != 0)) {
					{
					State = 3073; millisecondPart();
					}
				}

				}
				break;

			case 7:
				{
				State = 3076; secondPart();
				State = 3078;
				_la = _input.La(1);
				if (((((_la - 140)) & ~0x3f) == 0 && ((1L << (_la - 140)) & ((1L << (QUESTION - 140)) | (1L << (PLUS - 140)) | (1L << (MINUS - 140)) | (1L << (IDENT - 140)) | (1L << (IntegerLiteral - 140)) | (1L << (FloatingPointLiteral - 140)))) != 0)) {
					{
					State = 3077; millisecondPart();
					}
				}

				}
				break;

			case 8:
				{
				State = 3080; millisecondPart();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class YearPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_YEARS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_YEARS, 0); }
		public ITerminalNode TIMEPERIOD_YEAR() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_YEAR, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public YearPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_yearPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterYearPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitYearPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitYearPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public YearPartContext yearPart() {
		YearPartContext _localctx = new YearPartContext(_ctx, State);
		EnterRule(_localctx, 452, RULE_yearPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3086;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3083; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3084; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3085; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3088;
			_la = _input.La(1);
			if ( !(_la==TIMEPERIOD_YEAR || _la==TIMEPERIOD_YEARS) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MonthPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_MONTHS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MONTHS, 0); }
		public ITerminalNode TIMEPERIOD_MONTH() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MONTH, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MonthPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_monthPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMonthPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMonthPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMonthPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MonthPartContext monthPart() {
		MonthPartContext _localctx = new MonthPartContext(_ctx, State);
		EnterRule(_localctx, 454, RULE_monthPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3093;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3090; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3091; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3092; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3095;
			_la = _input.La(1);
			if ( !(_la==TIMEPERIOD_MONTH || _la==TIMEPERIOD_MONTHS) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WeekPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_WEEKS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_WEEKS, 0); }
		public ITerminalNode TIMEPERIOD_WEEK() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_WEEK, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public WeekPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_weekPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterWeekPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitWeekPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWeekPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WeekPartContext weekPart() {
		WeekPartContext _localctx = new WeekPartContext(_ctx, State);
		EnterRule(_localctx, 456, RULE_weekPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3100;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3097; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3098; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3099; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3102;
			_la = _input.La(1);
			if ( !(_la==TIMEPERIOD_WEEK || _la==TIMEPERIOD_WEEKS) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DayPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_DAYS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_DAYS, 0); }
		public ITerminalNode TIMEPERIOD_DAY() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_DAY, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public DayPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dayPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterDayPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitDayPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDayPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DayPartContext dayPart() {
		DayPartContext _localctx = new DayPartContext(_ctx, State);
		EnterRule(_localctx, 458, RULE_dayPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3107;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3104; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3105; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3106; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3109;
			_la = _input.La(1);
			if ( !(_la==TIMEPERIOD_DAY || _la==TIMEPERIOD_DAYS) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HourPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_HOURS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_HOURS, 0); }
		public ITerminalNode TIMEPERIOD_HOUR() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_HOUR, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public HourPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hourPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterHourPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitHourPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHourPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HourPartContext hourPart() {
		HourPartContext _localctx = new HourPartContext(_ctx, State);
		EnterRule(_localctx, 460, RULE_hourPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3114;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3111; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3112; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3113; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3116;
			_la = _input.La(1);
			if ( !(_la==TIMEPERIOD_HOUR || _la==TIMEPERIOD_HOURS) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MinutePartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_MINUTES() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MINUTES, 0); }
		public ITerminalNode TIMEPERIOD_MINUTE() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MINUTE, 0); }
		public ITerminalNode MIN() { return GetToken(EsperEPL2GrammarParser.MIN, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MinutePartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_minutePart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMinutePart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMinutePart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMinutePart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MinutePartContext minutePart() {
		MinutePartContext _localctx = new MinutePartContext(_ctx, State);
		EnterRule(_localctx, 462, RULE_minutePart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3121;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3118; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3119; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3120; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3123;
			_la = _input.La(1);
			if ( !(_la==MIN || _la==TIMEPERIOD_MINUTE || _la==TIMEPERIOD_MINUTES) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SecondPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_SECONDS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SECONDS, 0); }
		public ITerminalNode TIMEPERIOD_SECOND() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SECOND, 0); }
		public ITerminalNode TIMEPERIOD_SEC() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_SEC, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public SecondPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_secondPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSecondPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSecondPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSecondPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SecondPartContext secondPart() {
		SecondPartContext _localctx = new SecondPartContext(_ctx, State);
		EnterRule(_localctx, 464, RULE_secondPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3128;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3125; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3126; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3127; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3130;
			_la = _input.La(1);
			if ( !(((((_la - 98)) & ~0x3f) == 0 && ((1L << (_la - 98)) & ((1L << (TIMEPERIOD_SEC - 98)) | (1L << (TIMEPERIOD_SECOND - 98)) | (1L << (TIMEPERIOD_SECONDS - 98)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MillisecondPartContext : ParserRuleContext {
		public IToken i;
		public ITerminalNode TIMEPERIOD_MILLISECONDS() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MILLISECONDS, 0); }
		public ITerminalNode TIMEPERIOD_MILLISECOND() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MILLISECOND, 0); }
		public ITerminalNode TIMEPERIOD_MILLISEC() { return GetToken(EsperEPL2GrammarParser.TIMEPERIOD_MILLISEC, 0); }
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public SubstitutionContext substitution() {
			return GetRuleContext<SubstitutionContext>(0);
		}
		public ITerminalNode IDENT() { return GetToken(EsperEPL2GrammarParser.IDENT, 0); }
		public MillisecondPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_millisecondPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterMillisecondPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitMillisecondPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMillisecondPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MillisecondPartContext millisecondPart() {
		MillisecondPartContext _localctx = new MillisecondPartContext(_ctx, State);
		EnterRule(_localctx, 466, RULE_millisecondPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3135;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				{
				State = 3132; numberconstant();
				}
				break;
			case IDENT:
				{
				State = 3133; _localctx.i = Match(IDENT);
				}
				break;
			case QUESTION:
				{
				State = 3134; substitution();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3137;
			_la = _input.La(1);
			if ( !(((((_la - 101)) & ~0x3f) == 0 && ((1L << (_la - 101)) & ((1L << (TIMEPERIOD_MILLISEC - 101)) | (1L << (TIMEPERIOD_MILLISECOND - 101)) | (1L << (TIMEPERIOD_MILLISECONDS - 101)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberContext : ParserRuleContext {
		public ITerminalNode IntegerLiteral() { return GetToken(EsperEPL2GrammarParser.IntegerLiteral, 0); }
		public ITerminalNode FloatingPointLiteral() { return GetToken(EsperEPL2GrammarParser.FloatingPointLiteral, 0); }
		public NumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_number; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberContext number() {
		NumberContext _localctx = new NumberContext(_ctx, State);
		EnterRule(_localctx, 468, RULE_number);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3139;
			_la = _input.La(1);
			if ( !(_la==IntegerLiteral || _la==FloatingPointLiteral) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubstitutionContext : ParserRuleContext {
		public IToken q;
		public ITerminalNode QUESTION() { return GetToken(EsperEPL2GrammarParser.QUESTION, 0); }
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public SlashIdentifierContext slashIdentifier() {
			return GetRuleContext<SlashIdentifierContext>(0);
		}
		public SubstitutionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_substitution; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterSubstitution(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitSubstitution(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubstitution(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubstitutionContext substitution() {
		SubstitutionContext _localctx = new SubstitutionContext(_ctx, State);
		EnterRule(_localctx, 470, RULE_substitution);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3141; _localctx.q = Match(QUESTION);
			State = 3144;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,440,_ctx) ) {
			case 1:
				{
				State = 3142; Match(COLON);
				State = 3143; slashIdentifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public IToken t;
		public IToken f;
		public IToken nu;
		public NumberconstantContext numberconstant() {
			return GetRuleContext<NumberconstantContext>(0);
		}
		public StringconstantContext stringconstant() {
			return GetRuleContext<StringconstantContext>(0);
		}
		public ITerminalNode BOOLEAN_TRUE() { return GetToken(EsperEPL2GrammarParser.BOOLEAN_TRUE, 0); }
		public ITerminalNode BOOLEAN_FALSE() { return GetToken(EsperEPL2GrammarParser.BOOLEAN_FALSE, 0); }
		public ITerminalNode VALUE_NULL() { return GetToken(EsperEPL2GrammarParser.VALUE_NULL, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(_ctx, State);
		EnterRule(_localctx, 472, RULE_constant);
		try {
			State = 3151;
			switch (_input.La(1)) {
			case PLUS:
			case MINUS:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3146; numberconstant();
				}
				break;
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3147; stringconstant();
				}
				break;
			case BOOLEAN_TRUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3148; _localctx.t = Match(BOOLEAN_TRUE);
				}
				break;
			case BOOLEAN_FALSE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3149; _localctx.f = Match(BOOLEAN_FALSE);
				}
				break;
			case VALUE_NULL:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3150; _localctx.nu = Match(VALUE_NULL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberconstantContext : ParserRuleContext {
		public IToken m;
		public IToken p;
		public NumberContext number() {
			return GetRuleContext<NumberContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(EsperEPL2GrammarParser.MINUS, 0); }
		public ITerminalNode PLUS() { return GetToken(EsperEPL2GrammarParser.PLUS, 0); }
		public NumberconstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numberconstant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterNumberconstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitNumberconstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberconstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberconstantContext numberconstant() {
		NumberconstantContext _localctx = new NumberconstantContext(_ctx, State);
		EnterRule(_localctx, 474, RULE_numberconstant);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3155;
			switch (_input.La(1)) {
			case MINUS:
				{
				State = 3153; _localctx.m = Match(MINUS);
				}
				break;
			case PLUS:
				{
				State = 3154; _localctx.p = Match(PLUS);
				}
				break;
			case IntegerLiteral:
			case FloatingPointLiteral:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3157; number();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringconstantContext : ParserRuleContext {
		public IToken sl;
		public IToken qsl;
		public ITerminalNode STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.STRING_LITERAL, 0); }
		public ITerminalNode QUOTED_STRING_LITERAL() { return GetToken(EsperEPL2GrammarParser.QUOTED_STRING_LITERAL, 0); }
		public StringconstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringconstant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterStringconstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitStringconstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringconstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringconstantContext stringconstant() {
		StringconstantContext _localctx = new StringconstantContext(_ctx, State);
		EnterRule(_localctx, 476, RULE_stringconstant);
		try {
			State = 3161;
			switch (_input.La(1)) {
			case STRING_LITERAL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3159; _localctx.sl = Match(STRING_LITERAL);
				}
				break;
			case QUOTED_STRING_LITERAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3160; _localctx.qsl = Match(QUOTED_STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonvalueContext : ParserRuleContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public JsonobjectContext jsonobject() {
			return GetRuleContext<JsonobjectContext>(0);
		}
		public JsonarrayContext jsonarray() {
			return GetRuleContext<JsonarrayContext>(0);
		}
		public JsonvalueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonvalue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonvalue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonvalue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonvalue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonvalueContext jsonvalue() {
		JsonvalueContext _localctx = new JsonvalueContext(_ctx, State);
		EnterRule(_localctx, 478, RULE_jsonvalue);
		try {
			State = 3166;
			switch (_input.La(1)) {
			case BOOLEAN_TRUE:
			case BOOLEAN_FALSE:
			case VALUE_NULL:
			case PLUS:
			case MINUS:
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
			case IntegerLiteral:
			case FloatingPointLiteral:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3163; constant();
				}
				break;
			case LCURLY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3164; jsonobject();
				}
				break;
			case LBRACK:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3165; jsonarray();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonobjectContext : ParserRuleContext {
		public ITerminalNode LCURLY() { return GetToken(EsperEPL2GrammarParser.LCURLY, 0); }
		public JsonmembersContext jsonmembers() {
			return GetRuleContext<JsonmembersContext>(0);
		}
		public ITerminalNode RCURLY() { return GetToken(EsperEPL2GrammarParser.RCURLY, 0); }
		public JsonobjectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonobject; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonobject(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonobject(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonobject(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonobjectContext jsonobject() {
		JsonobjectContext _localctx = new JsonobjectContext(_ctx, State);
		EnterRule(_localctx, 480, RULE_jsonobject);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3168; Match(LCURLY);
			State = 3169; jsonmembers();
			State = 3170; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonarrayContext : ParserRuleContext {
		public ITerminalNode LBRACK() { return GetToken(EsperEPL2GrammarParser.LBRACK, 0); }
		public ITerminalNode RBRACK() { return GetToken(EsperEPL2GrammarParser.RBRACK, 0); }
		public JsonelementsContext jsonelements() {
			return GetRuleContext<JsonelementsContext>(0);
		}
		public JsonarrayContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonarray; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonarray(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonarray(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonarray(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonarrayContext jsonarray() {
		JsonarrayContext _localctx = new JsonarrayContext(_ctx, State);
		EnterRule(_localctx, 482, RULE_jsonarray);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3172; Match(LBRACK);
			State = 3174;
			_la = _input.La(1);
			if (((((_la - 104)) & ~0x3f) == 0 && ((1L << (_la - 104)) & ((1L << (BOOLEAN_TRUE - 104)) | (1L << (BOOLEAN_FALSE - 104)) | (1L << (VALUE_NULL - 104)) | (1L << (LBRACK - 104)) | (1L << (LCURLY - 104)) | (1L << (PLUS - 104)) | (1L << (MINUS - 104)))) != 0) || ((((_la - 189)) & ~0x3f) == 0 && ((1L << (_la - 189)) & ((1L << (QUOTED_STRING_LITERAL - 189)) | (1L << (STRING_LITERAL - 189)) | (1L << (IntegerLiteral - 189)) | (1L << (FloatingPointLiteral - 189)))) != 0)) {
				{
				State = 3173; jsonelements();
				}
			}

			State = 3176; Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonelementsContext : ParserRuleContext {
		public JsonvalueContext[] jsonvalue() {
			return GetRuleContexts<JsonvalueContext>();
		}
		public JsonvalueContext jsonvalue(int i) {
			return GetRuleContext<JsonvalueContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public JsonelementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonelements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonelements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonelements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonelements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonelementsContext jsonelements() {
		JsonelementsContext _localctx = new JsonelementsContext(_ctx, State);
		EnterRule(_localctx, 484, RULE_jsonelements);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3178; jsonvalue();
			State = 3183;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,446,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3179; Match(COMMA);
					State = 3180; jsonvalue();
					}
					} 
				}
				State = 3185;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,446,_ctx);
			}
			State = 3187;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 3186; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonmembersContext : ParserRuleContext {
		public JsonpairContext[] jsonpair() {
			return GetRuleContexts<JsonpairContext>();
		}
		public JsonpairContext jsonpair(int i) {
			return GetRuleContext<JsonpairContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(EsperEPL2GrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(EsperEPL2GrammarParser.COMMA, i);
		}
		public JsonmembersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonmembers; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonmembers(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonmembers(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonmembers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonmembersContext jsonmembers() {
		JsonmembersContext _localctx = new JsonmembersContext(_ctx, State);
		EnterRule(_localctx, 486, RULE_jsonmembers);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3189; jsonpair();
			State = 3194;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,448,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3190; Match(COMMA);
					State = 3191; jsonpair();
					}
					} 
				}
				State = 3196;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,448,_ctx);
			}
			State = 3198;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 3197; Match(COMMA);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JsonpairContext : ParserRuleContext {
		public ITerminalNode COLON() { return GetToken(EsperEPL2GrammarParser.COLON, 0); }
		public JsonvalueContext jsonvalue() {
			return GetRuleContext<JsonvalueContext>(0);
		}
		public StringconstantContext stringconstant() {
			return GetRuleContext<StringconstantContext>(0);
		}
		public KeywordAllowedIdentContext keywordAllowedIdent() {
			return GetRuleContext<KeywordAllowedIdentContext>(0);
		}
		public JsonpairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jsonpair; } }
		public override void EnterRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.EnterJsonpair(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IEsperEPL2GrammarListener typedListener = listener as IEsperEPL2GrammarListener;
			if (typedListener != null) typedListener.ExitJsonpair(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IEsperEPL2GrammarVisitor<TResult> typedVisitor = visitor as IEsperEPL2GrammarVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJsonpair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JsonpairContext jsonpair() {
		JsonpairContext _localctx = new JsonpairContext(_ctx, State);
		EnterRule(_localctx, 488, RULE_jsonpair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3202;
			switch (_input.La(1)) {
			case QUOTED_STRING_LITERAL:
			case STRING_LITERAL:
				{
				State = 3200; stringconstant();
				}
				break;
			case WINDOW:
			case ESCAPE:
			case EVERY_EXPR:
			case SUM:
			case AVG:
			case MAX:
			case MIN:
			case COALESCE:
			case MEDIAN:
			case STDDEV:
			case AVEDEV:
			case COUNT:
			case OUTER:
			case JOIN:
			case LEFT:
			case RIGHT:
			case FULL:
			case EVENTS:
			case FIRST:
			case LAST:
			case UNIDIRECTIONAL:
			case RETAINUNION:
			case RETAININTERSECTION:
			case PATTERN:
			case SQL:
			case METADATASQL:
			case PREVIOUS:
			case PREVIOUSTAIL:
			case PRIOR:
			case WEEKDAY:
			case LW:
			case INSTANCEOF:
			case TYPEOF:
			case CAST:
			case SNAPSHOT:
			case VARIABLE:
			case TABLE:
			case UNTIL:
			case AT:
			case INDEX:
			case DEFINE:
			case PARTITION:
			case MATCHES:
			case FOR:
			case WHILE:
			case USING:
			case MERGE:
			case MATCHED:
			case CONTEXT:
			case TICKED_STRING_LITERAL:
			case IDENT:
				{
				State = 3201; keywordAllowedIdent();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3204; Match(COLON);
			State = 3205; jsonvalue();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xC3\xC8A\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37"+
		"\x4\x38\t\x38\x4\x39\t\x39\x4:\t:\x4;\t;\x4<\t<\x4=\t=\x4>\t>\x4?\t?\x4"+
		"@\t@\x4\x41\t\x41\x4\x42\t\x42\x4\x43\t\x43\x4\x44\t\x44\x4\x45\t\x45"+
		"\x4\x46\t\x46\x4G\tG\x4H\tH\x4I\tI\x4J\tJ\x4K\tK\x4L\tL\x4M\tM\x4N\tN"+
		"\x4O\tO\x4P\tP\x4Q\tQ\x4R\tR\x4S\tS\x4T\tT\x4U\tU\x4V\tV\x4W\tW\x4X\t"+
		"X\x4Y\tY\x4Z\tZ\x4[\t[\x4\\\t\\\x4]\t]\x4^\t^\x4_\t_\x4`\t`\x4\x61\t\x61"+
		"\x4\x62\t\x62\x4\x63\t\x63\x4\x64\t\x64\x4\x65\t\x65\x4\x66\t\x66\x4g"+
		"\tg\x4h\th\x4i\ti\x4j\tj\x4k\tk\x4l\tl\x4m\tm\x4n\tn\x4o\to\x4p\tp\x4"+
		"q\tq\x4r\tr\x4s\ts\x4t\tt\x4u\tu\x4v\tv\x4w\tw\x4x\tx\x4y\ty\x4z\tz\x4"+
		"{\t{\x4|\t|\x4}\t}\x4~\t~\x4\x7F\t\x7F\x4\x80\t\x80\x4\x81\t\x81\x4\x82"+
		"\t\x82\x4\x83\t\x83\x4\x84\t\x84\x4\x85\t\x85\x4\x86\t\x86\x4\x87\t\x87"+
		"\x4\x88\t\x88\x4\x89\t\x89\x4\x8A\t\x8A\x4\x8B\t\x8B\x4\x8C\t\x8C\x4\x8D"+
		"\t\x8D\x4\x8E\t\x8E\x4\x8F\t\x8F\x4\x90\t\x90\x4\x91\t\x91\x4\x92\t\x92"+
		"\x4\x93\t\x93\x4\x94\t\x94\x4\x95\t\x95\x4\x96\t\x96\x4\x97\t\x97\x4\x98"+
		"\t\x98\x4\x99\t\x99\x4\x9A\t\x9A\x4\x9B\t\x9B\x4\x9C\t\x9C\x4\x9D\t\x9D"+
		"\x4\x9E\t\x9E\x4\x9F\t\x9F\x4\xA0\t\xA0\x4\xA1\t\xA1\x4\xA2\t\xA2\x4\xA3"+
		"\t\xA3\x4\xA4\t\xA4\x4\xA5\t\xA5\x4\xA6\t\xA6\x4\xA7\t\xA7\x4\xA8\t\xA8"+
		"\x4\xA9\t\xA9\x4\xAA\t\xAA\x4\xAB\t\xAB\x4\xAC\t\xAC\x4\xAD\t\xAD\x4\xAE"+
		"\t\xAE\x4\xAF\t\xAF\x4\xB0\t\xB0\x4\xB1\t\xB1\x4\xB2\t\xB2\x4\xB3\t\xB3"+
		"\x4\xB4\t\xB4\x4\xB5\t\xB5\x4\xB6\t\xB6\x4\xB7\t\xB7\x4\xB8\t\xB8\x4\xB9"+
		"\t\xB9\x4\xBA\t\xBA\x4\xBB\t\xBB\x4\xBC\t\xBC\x4\xBD\t\xBD\x4\xBE\t\xBE"+
		"\x4\xBF\t\xBF\x4\xC0\t\xC0\x4\xC1\t\xC1\x4\xC2\t\xC2\x4\xC3\t\xC3\x4\xC4"+
		"\t\xC4\x4\xC5\t\xC5\x4\xC6\t\xC6\x4\xC7\t\xC7\x4\xC8\t\xC8\x4\xC9\t\xC9"+
		"\x4\xCA\t\xCA\x4\xCB\t\xCB\x4\xCC\t\xCC\x4\xCD\t\xCD\x4\xCE\t\xCE\x4\xCF"+
		"\t\xCF\x4\xD0\t\xD0\x4\xD1\t\xD1\x4\xD2\t\xD2\x4\xD3\t\xD3\x4\xD4\t\xD4"+
		"\x4\xD5\t\xD5\x4\xD6\t\xD6\x4\xD7\t\xD7\x4\xD8\t\xD8\x4\xD9\t\xD9\x4\xDA"+
		"\t\xDA\x4\xDB\t\xDB\x4\xDC\t\xDC\x4\xDD\t\xDD\x4\xDE\t\xDE\x4\xDF\t\xDF"+
		"\x4\xE0\t\xE0\x4\xE1\t\xE1\x4\xE2\t\xE2\x4\xE3\t\xE3\x4\xE4\t\xE4\x4\xE5"+
		"\t\xE5\x4\xE6\t\xE6\x4\xE7\t\xE7\x4\xE8\t\xE8\x4\xE9\t\xE9\x4\xEA\t\xEA"+
		"\x4\xEB\t\xEB\x4\xEC\t\xEC\x4\xED\t\xED\x4\xEE\t\xEE\x4\xEF\t\xEF\x4\xF0"+
		"\t\xF0\x4\xF1\t\xF1\x4\xF2\t\xF2\x4\xF3\t\xF3\x4\xF4\t\xF4\x4\xF5\t\xF5"+
		"\x4\xF6\t\xF6\x3\x2\x3\x2\a\x2\x1EF\n\x2\f\x2\xE\x2\x1F2\v\x2\x3\x2\x3"+
		"\x2\x3\x2\x3\x3\x3\x3\a\x3\x1F9\n\x3\f\x3\xE\x3\x1FC\v\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5\x3\x6\x3\x6\x5\x6\x209\n\x6"+
		"\x3\x6\x3\x6\x5\x6\x20D\n\x6\x3\x6\x5\x6\x210\n\x6\x3\x6\x3\x6\x3\x6\x5"+
		"\x6\x215\n\x6\x3\x6\x5\x6\x218\n\x6\x3\x6\x3\x6\x5\x6\x21C\n\x6\x3\x6"+
		"\x3\x6\x3\a\x3\a\x3\a\x3\b\x3\b\x5\b\x225\n\b\x3\b\x3\b\x3\b\x3\b\x3\b"+
		"\x3\b\x3\b\x5\b\x22E\n\b\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\x235\n\t\x3\t\x3"+
		"\t\x3\n\x3\n\x3\n\x3\n\x3\n\x5\n\x23E\n\n\x3\n\x5\n\x241\n\n\x3\v\x3\v"+
		"\x3\v\a\v\x246\n\v\f\v\xE\v\x249\v\v\x3\f\x3\f\x3\f\x3\f\x3\r\x3\r\x3"+
		"\r\x3\r\x3\r\x5\r\x254\n\r\x3\xE\x3\xE\x3\xE\x3\xE\a\xE\x25A\n\xE\f\xE"+
		"\xE\xE\x25D\v\xE\x5\xE\x25F\n\xE\x3\xE\x5\xE\x262\n\xE\x3\xE\x3\xE\x3"+
		"\xF\x5\xF\x267\n\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3"+
		"\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\x277\n\xF\x3\xF\x5\xF\x27A\n\xF"+
		"\x3\x10\x3\x10\x3\x10\x3\x11\x3\x11\x5\x11\x281\n\x11\x3\x11\x3\x11\x5"+
		"\x11\x285\n\x11\x3\x11\x3\x11\x3\x11\x3\x11\x5\x11\x28B\n\x11\x3\x11\x5"+
		"\x11\x28E\n\x11\x3\x11\x3\x11\x5\x11\x292\n\x11\x3\x11\x3\x11\x3\x11\x5"+
		"\x11\x297\n\x11\x3\x11\x3\x11\x5\x11\x29B\n\x11\x3\x11\x3\x11\x5\x11\x29F"+
		"\n\x11\x3\x11\x3\x11\x3\x11\x5\x11\x2A4\n\x11\x3\x11\x3\x11\x5\x11\x2A8"+
		"\n\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12\x6\x12\x2AF\n\x12\r\x12\xE\x12"+
		"\x2B0\x3\x12\x5\x12\x2B4\n\x12\x5\x12\x2B6\n\x12\x3\x12\x3\x12\x3\x12"+
		"\x5\x12\x2BB\n\x12\x3\x13\x3\x13\x5\x13\x2BF\n\x13\x3\x13\x3\x13\x3\x13"+
		"\x5\x13\x2C4\n\x13\x3\x14\x3\x14\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3"+
		"\x15\x5\x15\x2CE\n\x15\x3\x15\x3\x15\x3\x15\x3\x15\x5\x15\x2D4\n\x15\x3"+
		"\x16\x3\x16\x5\x16\x2D8\n\x16\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\x2DE"+
		"\n\x16\x3\x16\x3\x16\x5\x16\x2E2\n\x16\x3\x16\x6\x16\x2E5\n\x16\r\x16"+
		"\xE\x16\x2E6\x3\x17\x3\x17\x5\x17\x2EB\n\x17\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x5\x18\x2F1\n\x18\x3\x18\x6\x18\x2F4\n\x18\r\x18\xE\x18\x2F5\x3\x19\x3"+
		"\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x5\x19\x2FF\n\x19\x3\x19\x3\x19"+
		"\x3\x19\x5\x19\x304\n\x19\x3\x19\x5\x19\x307\n\x19\x3\x1A\x3\x1A\x3\x1A"+
		"\x3\x1A\x3\x1A\x5\x1A\x30E\n\x1A\x3\x1A\x6\x1A\x311\n\x1A\r\x1A\xE\x1A"+
		"\x312\x3\x1B\x3\x1B\x3\x1B\x3\x1C\x3\x1C\x3\x1C\x5\x1C\x31B\n\x1C\x3\x1C"+
		"\x3\x1C\x3\x1C\x3\x1C\x5\x1C\x321\n\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x5"+
		"\x1C\x327\n\x1C\x3\x1D\x3\x1D\x5\x1D\x32B\n\x1D\x3\x1D\x3\x1D\x5\x1D\x32F"+
		"\n\x1D\x3\x1D\x5\x1D\x332\n\x1D\x3\x1D\x5\x1D\x335\n\x1D\x3\x1D\x3\x1D"+
		"\x5\x1D\x339\n\x1D\x3\x1D\x3\x1D\x5\x1D\x33D\n\x1D\x3\x1D\x3\x1D\x3\x1D"+
		"\x5\x1D\x342\n\x1D\x3\x1D\x3\x1D\x5\x1D\x346\n\x1D\x3\x1D\x3\x1D\x3\x1D"+
		"\x5\x1D\x34B\n\x1D\x3\x1D\x3\x1D\x5\x1D\x34F\n\x1D\x3\x1E\x3\x1E\x3\x1E"+
		"\x3\x1E\x3\x1E\x5\x1E\x356\n\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1E\x5\x1E\x35C"+
		"\n\x1E\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F\x5\x1F\x364\n\x1F\x3"+
		" \x3 \x3 \x5 \x369\n \x3!\x3!\x3!\x3!\x5!\x36F\n!\x3\"\x3\"\x3\"\x3#\x3"+
		"#\x3#\a#\x377\n#\f#\xE#\x37A\v#\x3$\x3$\x3$\x3$\x3$\x5$\x381\n$\x3%\x3"+
		"%\x3%\x3%\x3%\x5%\x388\n%\x3&\x3&\x3&\x3&\x3&\x3&\x3&\a&\x391\n&\f&\xE"+
		"&\x394\v&\x5&\x396\n&\x3&\x3&\x5&\x39A\n&\x3&\x5&\x39D\n&\x3&\x3&\x3&"+
		"\x3&\x3&\x5&\x3A4\n&\x3&\x3&\x3&\x5&\x3A9\n&\x5&\x3AB\n&\x3\'\x3\'\x3"+
		"\'\x3\'\x5\'\x3B1\n\'\x3\'\x3\'\x3(\x3(\x5(\x3B7\n(\x3(\x3(\x3(\x3(\x3"+
		"(\x3(\x3(\x3(\x3)\x3)\x3)\a)\x3C4\n)\f)\xE)\x3C7\v)\x3*\x3*\x5*\x3CB\n"+
		"*\x3+\x3+\x5+\x3CF\n+\x3+\x3+\x3+\x3+\x5+\x3D5\n+\x3+\x5+\x3D8\n+\x3+"+
		"\x3+\x3+\x5+\x3DD\n+\x3,\x3,\x3,\x3,\x5,\x3E3\n,\x3,\x3,\x3,\x3,\x3-\x3"+
		"-\x3-\a-\x3EC\n-\f-\xE-\x3EF\v-\x3.\x3.\x3.\x3.\x5.\x3F5\n.\x3.\x5.\x3F8"+
		"\n.\x3.\x5.\x3FB\n.\x3.\x3.\a.\x3FF\n.\f.\xE.\x402\v.\x3/\x3/\x3/\x5/"+
		"\x407\n/\x3/\x5/\x40A\n/\x3\x30\x3\x30\x3\x30\a\x30\x40F\n\x30\f\x30\xE"+
		"\x30\x412\v\x30\x3\x31\x3\x31\x3\x31\x3\x31\x3\x31\x5\x31\x419\n\x31\x3"+
		"\x31\x5\x31\x41C\n\x31\x5\x31\x41E\n\x31\x3\x32\x3\x32\x3\x32\a\x32\x423"+
		"\n\x32\f\x32\xE\x32\x426\v\x32\x3\x33\x3\x33\x3\x33\x3\x33\x5\x33\x42C"+
		"\n\x33\x3\x33\x3\x33\x3\x33\x3\x33\x5\x33\x432\n\x33\x3\x34\x3\x34\x5"+
		"\x34\x436\n\x34\x3\x34\x3\x34\x3\x35\x3\x35\x3\x35\x5\x35\x43D\n\x35\x3"+
		"\x35\x3\x35\x3\x35\x5\x35\x442\n\x35\x3\x35\x5\x35\x445\n\x35\x3\x35\a"+
		"\x35\x448\n\x35\f\x35\xE\x35\x44B\v\x35\x3\x36\x3\x36\x3\x36\x3\x36\x3"+
		"\x36\x3\x36\x5\x36\x453\n\x36\x3\x36\x3\x36\x5\x36\x457\n\x36\x3\x37\x3"+
		"\x37\x3\x37\x3\x38\x3\x38\x3\x38\x3\x38\x3\x38\x3\x38\x3\x38\x3\x39\x3"+
		"\x39\x3\x39\x3\x39\x5\x39\x467\n\x39\x3\x39\x3\x39\x3:\x3:\a:\x46D\n:"+
		"\f:\xE:\x470\v:\x3;\a;\x473\n;\f;\xE;\x476\v;\x3;\x3;\x5;\x47A\n;\x3;"+
		"\x5;\x47D\n;\x3;\x5;\x480\n;\x3;\x3;\x5;\x484\n;\x3;\x5;\x487\n;\x3;\x3"+
		";\x3;\x3;\x5;\x48D\n;\x3<\x3<\x3<\x3<\x3=\x3=\x3=\a=\x496\n=\f=\xE=\x499"+
		"\v=\x3>\x3>\x5>\x49D\n>\x3>\x5>\x4A0\n>\x3?\x3?\x3?\x3?\x3?\x3?\x3?\x3"+
		"@\x3@\x3@\x3\x41\x3\x41\x3\x41\x3\x41\a\x41\x4B0\n\x41\f\x41\xE\x41\x4B3"+
		"\v\x41\x3\x42\x3\x42\x5\x42\x4B7\n\x42\x3\x43\x3\x43\x3\x43\x3\x43\a\x43"+
		"\x4BD\n\x43\f\x43\xE\x43\x4C0\v\x43\x3\x43\x3\x43\x3\x44\x3\x44\x5\x44"+
		"\x4C6\n\x44\x3\x45\x3\x45\x5\x45\x4CA\n\x45\x3\x46\x3\x46\x3\x46\a\x46"+
		"\x4CF\n\x46\f\x46\xE\x46\x4D2\v\x46\x3G\x3G\x3G\x3G\x3G\x3G\x3G\x3G\x3"+
		"G\x3G\x3G\x5G\x4DF\nG\x5G\x4E1\nG\x3H\x3H\x3H\x3H\x5H\x4E7\nH\x3H\x3H"+
		"\x3I\x3I\x3I\x3J\x3J\x3J\x3J\x3J\x3J\aJ\x4F4\nJ\fJ\xEJ\x4F7\vJ\x5J\x4F9"+
		"\nJ\x3K\x3K\x3K\x5K\x4FE\nK\x3K\x3K\x3L\x3L\x3L\x3L\x5L\x506\nL\x3L\x3"+
		"L\x3L\x3L\x5L\x50C\nL\x3L\x5L\x50F\nL\x3L\x3L\x3L\x5L\x514\nL\x3L\x3L"+
		"\x3L\x5L\x519\nL\x3L\x3L\x3L\x3L\x5L\x51F\nL\x3L\x3L\x3L\aL\x524\nL\f"+
		"L\xEL\x527\vL\x3L\x3L\x3L\aL\x52C\nL\fL\xEL\x52F\vL\x3L\x3L\x3L\x3L\x3"+
		"L\x5L\x536\nL\x3L\x3L\x3L\aL\x53B\nL\fL\xEL\x53E\vL\x3L\x3L\x3L\x5L\x543"+
		"\nL\x5L\x545\nL\x3M\x3M\x3M\x5M\x54A\nM\x3M\x3M\x3N\x3N\x3N\x3N\x5N\x552"+
		"\nN\x3N\x3N\x3N\x5N\x557\nN\x3O\x3O\x5O\x55B\nO\x3O\x5O\x55E\nO\x3P\x3"+
		"P\x3P\aP\x563\nP\fP\xEP\x566\vP\x3P\x3P\x3P\x3Q\x3Q\x3Q\x3Q\x3R\x3R\x5"+
		"R\x571\nR\x3R\x3R\x3R\x3R\x3S\x3S\x3S\x3T\x3T\x3T\aT\x57D\nT\fT\xET\x580"+
		"\vT\x3U\x3U\x5U\x584\nU\x3V\x3V\x3V\x3W\x3W\x3W\x5W\x58C\nW\x3W\x3W\x3"+
		"W\x3W\x5W\x592\nW\x3W\x5W\x595\nW\x3X\x3X\x3X\aX\x59A\nX\fX\xEX\x59D\v"+
		"X\x3Y\x3Y\x3Y\x5Y\x5A2\nY\x3Z\x3Z\aZ\x5A6\nZ\fZ\xEZ\x5A9\vZ\x3[\x3[\a"+
		"[\x5AD\n[\f[\xE[\x5B0\v[\x3\\\x3\\\x3\\\x5\\\x5B5\n\\\x3\\\x5\\\x5B8\n"+
		"\\\x3\\\x5\\\x5BB\n\\\x3\\\x3\\\x3\\\x5\\\x5C0\n\\\x3]\x3]\x3]\x3]\a]"+
		"\x5C6\n]\f]\xE]\x5C9\v]\x3^\x3^\x3^\x3^\x3_\x3_\x3`\x3`\x3`\x5`\x5D4\n"+
		"`\x3`\x5`\x5D7\n`\x3`\x3`\x3\x61\x3\x61\x3\x61\a\x61\x5DE\n\x61\f\x61"+
		"\xE\x61\x5E1\v\x61\x3\x62\x3\x62\x3\x62\x5\x62\x5E6\n\x62\x3\x63\x3\x63"+
		"\x5\x63\x5EA\n\x63\x3\x63\x5\x63\x5ED\n\x63\x3\x63\x5\x63\x5F0\n\x63\x3"+
		"\x64\x3\x64\x3\x64\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x5\x65\x5FA\n\x65"+
		"\x3\x66\x3\x66\x3\x66\x3\x66\x5\x66\x600\n\x66\x3\x66\x3\x66\x3\x66\x3"+
		"\x66\a\x66\x606\n\x66\f\x66\xE\x66\x609\v\x66\x5\x66\x60B\n\x66\x3\x66"+
		"\x3\x66\x3\x66\x5\x66\x610\n\x66\x3\x66\x5\x66\x613\n\x66\x3\x66\x3\x66"+
		"\x5\x66\x617\n\x66\x3g\x3g\x3g\x3g\x5g\x61D\ng\x3g\x5g\x620\ng\x3h\x3"+
		"h\ah\x624\nh\fh\xEh\x627\vh\x3h\x3h\x3h\x3h\x3i\x3i\x3i\x3i\x3i\x3i\x5"+
		"i\x633\ni\x3i\x3i\x3i\x5i\x638\ni\x5i\x63A\ni\x3i\x3i\x3j\x3j\x3j\x3j"+
		"\x3j\x5j\x643\nj\x3j\x5j\x646\nj\x3k\x3k\x3k\x3k\x5k\x64C\nk\x3k\x3k\x5"+
		"k\x650\nk\x3k\x3k\x3l\x3l\x3l\al\x657\nl\fl\xEl\x65A\vl\x3m\x3m\x3m\x5"+
		"m\x65F\nm\x3n\x3n\x3n\x3n\x3n\an\x666\nn\fn\xEn\x669\vn\x3n\x3n\x3o\x3"+
		"o\x3o\x3o\x3o\x3o\ao\x673\no\fo\xEo\x676\vo\x3o\x3o\x3p\x3p\x5p\x67C\n"+
		"p\x3q\x3q\x3q\x3q\x3q\aq\x683\nq\fq\xEq\x686\vq\x5q\x688\nq\x3q\x5q\x68B"+
		"\nq\x3r\x3r\x3r\ar\x690\nr\fr\xEr\x693\vr\x3s\x3s\x3s\x5s\x698\ns\x3t"+
		"\x3t\x3u\x5u\x69D\nu\x3u\x3u\x3u\x3u\x5u\x6A3\nu\x3u\x3u\x3u\x3u\x5u\x6A9"+
		"\nu\x3u\x5u\x6AC\nu\x3u\x3u\x3u\x3u\x3u\x3u\x5u\x6B4\nu\x3u\x3u\x3u\x3"+
		"u\x5u\x6BA\nu\x3u\x3u\x5u\x6BE\nu\x3u\x5u\x6C1\nu\x3u\x5u\x6C4\nu\x3v"+
		"\x3v\x3v\x3v\x3v\x5v\x6CB\nv\x3v\x3v\x5v\x6CF\nv\x3w\x3w\x3w\x3w\x3w\x5"+
		"w\x6D6\nw\x3x\x3x\x5x\x6DA\nx\x3x\x3x\x5x\x6DE\nx\x3x\x3x\x5x\x6E2\nx"+
		"\x5x\x6E4\nx\x3y\x3y\x3y\x3y\x3z\x3z\x3z\x3z\x3z\x3{\x3{\x3{\x3|\x3|\x3"+
		"|\x5|\x6F5\n|\x3|\x3|\x5|\x6F9\n|\x3|\x5|\x6FC\n|\x3|\x3|\x5|\x700\n|"+
		"\x3|\x5|\x703\n|\x3|\x3|\x3}\x3}\x3}\x3}\x3}\a}\x70C\n}\f}\xE}\x70F\v"+
		"}\x3~\x3~\x3~\x3~\a~\x715\n~\f~\xE~\x718\v~\x3\x7F\x3\x7F\x3\x7F\x5\x7F"+
		"\x71D\n\x7F\x5\x7F\x71F\n\x7F\x3\x80\x3\x80\x3\x80\x3\x81\x3\x81\x3\x81"+
		"\x3\x81\x3\x81\x3\x82\x3\x82\x3\x82\x3\x82\x3\x82\x3\x82\x3\x82\x3\x83"+
		"\x3\x83\x3\x83\x3\x83\x5\x83\x734\n\x83\x3\x84\x3\x84\x3\x84\a\x84\x739"+
		"\n\x84\f\x84\xE\x84\x73C\v\x84\x3\x85\x6\x85\x73F\n\x85\r\x85\xE\x85\x740"+
		"\x3\x86\x3\x86\x3\x86\x5\x86\x746\n\x86\x3\x87\x3\x87\x3\x87\x3\x87\x3"+
		"\x87\x3\x87\x5\x87\x74E\n\x87\x3\x87\x5\x87\x751\n\x87\x3\x88\x3\x88\x3"+
		"\x88\x3\x88\x3\x88\a\x88\x758\n\x88\f\x88\xE\x88\x75B\v\x88\x3\x88\x3"+
		"\x88\x3\x89\x3\x89\x3\x89\x3\x89\x5\x89\x763\n\x89\x3\x89\x5\x89\x766"+
		"\n\x89\x5\x89\x768\n\x89\x3\x89\x5\x89\x76B\n\x89\x3\x8A\x3\x8A\x5\x8A"+
		"\x76F\n\x8A\x3\x8A\x5\x8A\x772\n\x8A\x3\x8A\x5\x8A\x775\n\x8A\x3\x8A\x3"+
		"\x8A\x3\x8B\x3\x8B\x3\x8B\x3\x8B\a\x8B\x77D\n\x8B\f\x8B\xE\x8B\x780\v"+
		"\x8B\x3\x8C\x3\x8C\x3\x8C\x3\x8C\x3\x8D\x3\x8D\x3\x8E\x3\x8E\x3\x8E\x6"+
		"\x8E\x78B\n\x8E\r\x8E\xE\x8E\x78C\x3\x8E\x5\x8E\x790\n\x8E\x3\x8E\x3\x8E"+
		"\x3\x8E\x3\x8E\x3\x8E\x3\x8E\x3\x8E\x6\x8E\x799\n\x8E\r\x8E\xE\x8E\x79A"+
		"\x3\x8E\x5\x8E\x79E\n\x8E\x3\x8E\x3\x8E\x3\x8E\x3\x8E\x5\x8E\x7A4\n\x8E"+
		"\x3\x8F\x3\x8F\x3\x8F\a\x8F\x7A9\n\x8F\f\x8F\xE\x8F\x7AC\v\x8F\x3\x90"+
		"\x3\x90\x3\x90\a\x90\x7B1\n\x90\f\x90\xE\x90\x7B4\v\x90\x3\x91\x3\x91"+
		"\x3\x91\a\x91\x7B9\n\x91\f\x91\xE\x91\x7BC\v\x91\x3\x92\x3\x92\x3\x92"+
		"\x5\x92\x7C1\n\x92\x3\x93\x3\x93\x3\x93\x3\x93\x3\x93\x3\x93\x3\x93\x5"+
		"\x93\x7CA\n\x93\x3\x93\x3\x93\x3\x93\x3\x93\x5\x93\x7D0\n\x93\x3\x93\x3"+
		"\x93\x5\x93\x7D4\n\x93\x3\x93\x3\x93\x5\x93\x7D8\n\x93\x5\x93\x7DA\n\x93"+
		"\a\x93\x7DC\n\x93\f\x93\xE\x93\x7DF\v\x93\x3\x94\x3\x94\x3\x94\x3\x94"+
		"\x3\x94\x5\x94\x7E6\n\x94\x3\x94\x3\x94\x3\x94\x3\x94\x5\x94\x7EC\n\x94"+
		"\x3\x94\x3\x94\x5\x94\x7F0\n\x94\x3\x94\x3\x94\x5\x94\x7F4\n\x94\x5\x94"+
		"\x7F6\n\x94\a\x94\x7F8\n\x94\f\x94\xE\x94\x7FB\v\x94\x3\x94\x5\x94\x7FE"+
		"\n\x94\x3\x94\x3\x94\x3\x94\x5\x94\x803\n\x94\x3\x94\x3\x94\x3\x94\x3"+
		"\x94\x3\x94\a\x94\x80A\n\x94\f\x94\xE\x94\x80D\v\x94\x5\x94\x80F\n\x94"+
		"\x3\x94\x3\x94\x5\x94\x813\n\x94\x3\x94\x3\x94\x3\x94\x3\x94\x3\x94\x3"+
		"\x94\x3\x94\x3\x94\x5\x94\x81D\n\x94\x3\x94\x3\x94\x5\x94\x821\n\x94\x5"+
		"\x94\x823\n\x94\x3\x95\x3\x95\x3\x96\x3\x96\x3\x96\x3\x96\x3\x96\a\x96"+
		"\x82C\n\x96\f\x96\xE\x96\x82F\v\x96\x5\x96\x831\n\x96\x3\x97\x3\x97\x3"+
		"\x97\a\x97\x836\n\x97\f\x97\xE\x97\x839\v\x97\x3\x98\x3\x98\x3\x98\a\x98"+
		"\x83E\n\x98\f\x98\xE\x98\x841\v\x98\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99"+
		"\x3\x99\x3\x99\x3\x99\x5\x99\x84B\n\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3"+
		"\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\a\x99\x857\n\x99\f\x99\xE\x99"+
		"\x85A\v\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\a"+
		"\x99\x864\n\x99\f\x99\xE\x99\x867\v\x99\x5\x99\x869\n\x99\x3\x99\x3\x99"+
		"\x5\x99\x86D\n\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\a\x99\x874\n\x99"+
		"\f\x99\xE\x99\x877\v\x99\x3\x99\x3\x99\x5\x99\x87B\n\x99\x3\x99\x5\x99"+
		"\x87E\n\x99\x3\x9A\x3\x9A\x5\x9A\x882\n\x9A\x3\x9B\x3\x9B\x3\x9B\x3\x9B"+
		"\a\x9B\x888\n\x9B\f\x9B\xE\x9B\x88B\v\x9B\x3\x9C\x3\x9C\x3\x9C\x5\x9C"+
		"\x890\n\x9C\x3\x9D\x3\x9D\x5\x9D\x894\n\x9D\x3\x9E\x3\x9E\x3\x9F\x3\x9F"+
		"\x3\x9F\x3\xA0\x3\xA0\x3\xA0\x5\xA0\x89E\n\xA0\x3\xA0\x3\xA0\x3\xA0\x3"+
		"\xA0\x3\xA0\x5\xA0\x8A5\n\xA0\x3\xA0\x3\xA0\x3\xA0\x5\xA0\x8AA\n\xA0\x3"+
		"\xA0\x3\xA0\x3\xA1\x3\xA1\x3\xA1\x3\xA1\x3\xA1\a\xA1\x8B3\n\xA1\f\xA1"+
		"\xE\xA1\x8B6\v\xA1\x5\xA1\x8B8\n\xA1\x3\xA1\x3\xA1\x3\xA1\x5\xA1\x8BD"+
		"\n\xA1\x3\xA1\x3\xA1\x5\xA1\x8C1\n\xA1\x3\xA2\x3\xA2\x3\xA2\x3\xA2\a\xA2"+
		"\x8C7\n\xA2\f\xA2\xE\xA2\x8CA\v\xA2\x5\xA2\x8CC\n\xA2\x3\xA2\x3\xA2\x5"+
		"\xA2\x8D0\n\xA2\x3\xA3\x3\xA3\x3\xA3\x5\xA3\x8D5\n\xA3\x3\xA3\x3\xA3\x3"+
		"\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\x8DD\n\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3"+
		"\x3\xA3\x3\xA3\x3\xA3\x5\xA3\x8E6\n\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3"+
		"\xA3\x3\xA3\x5\xA3\x8EE\n\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3"+
		"\x5\xA3\x8F6\n\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\x8FE"+
		"\n\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3"+
		"\x3\xA3\x3\xA3\a\xA3\x90B\n\xA3\f\xA3\xE\xA3\x90E\v\xA3\x3\xA3\x3\xA3"+
		"\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\x917\n\xA3\x3\xA3\x3\xA3\x5"+
		"\xA3\x91B\n\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\x922\n\xA3\x3"+
		"\xA3\x3\xA3\x5\xA3\x926\n\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3"+
		"\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\x932\n\xA3\x3\xA3\x3\xA3\x3\xA3\x3"+
		"\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3"+
		"\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3"+
		"\xA3\a\xA3\x94C\n\xA3\f\xA3\xE\xA3\x94F\v\xA3\x3\xA3\x3\xA3\x3\xA3\x3"+
		"\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3"+
		"\xA3\x5\xA3\x95F\n\xA3\x3\xA3\x3\xA3\x5\xA3\x963\n\xA3\x3\xA3\x3\xA3\x3"+
		"\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\x96D\n\xA3\x3\xA3\x5\xA3"+
		"\x970\n\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\x975\n\xA3\x3\xA4\x3\xA4\x3\xA4"+
		"\x5\xA4\x97A\n\xA4\x3\xA4\x3\xA4\x5\xA4\x97E\n\xA4\x3\xA4\x3\xA4\x5\xA4"+
		"\x982\n\xA4\x3\xA5\x3\xA5\x5\xA5\x986\n\xA5\x3\xA6\x3\xA6\x3\xA6\a\xA6"+
		"\x98B\n\xA6\f\xA6\xE\xA6\x98E\v\xA6\x3\xA7\x3\xA7\x3\xA7\x3\xA7\x3\xA7"+
		"\x5\xA7\x995\n\xA7\x3\xA7\x3\xA7\x5\xA7\x999\n\xA7\x3\xA7\x5\xA7\x99C"+
		"\n\xA7\x3\xA8\x3\xA8\x3\xA8\x5\xA8\x9A1\n\xA8\x3\xA8\x5\xA8\x9A4\n\xA8"+
		"\x3\xA9\x3\xA9\x3\xA9\x5\xA9\x9A9\n\xA9\x3\xAA\x3\xAA\x3\xAA\x3\xAA\x5"+
		"\xAA\x9AF\n\xAA\x3\xAB\x3\xAB\x3\xAB\x3\xAB\x3\xAB\x3\xAB\x3\xAB\x3\xAB"+
		"\x3\xAB\x3\xAB\x5\xAB\x9BB\n\xAB\x3\xAC\x5\xAC\x9BE\n\xAC\x3\xAC\x3\xAC"+
		"\x3\xAC\a\xAC\x9C3\n\xAC\f\xAC\xE\xAC\x9C6\v\xAC\x3\xAD\x5\xAD\x9C9\n"+
		"\xAD\x3\xAD\x3\xAD\x3\xAE\x3\xAE\x3\xAE\x3\xAE\x3\xAF\x3\xAF\x3\xB0\x3"+
		"\xB0\a\xB0\x9D5\n\xB0\f\xB0\xE\xB0\x9D8\v\xB0\x3\xB1\x3\xB1\x3\xB1\x3"+
		"\xB1\x3\xB1\x5\xB1\x9DF\n\xB1\x3\xB1\x3\xB1\x3\xB2\x3\xB2\x3\xB2\a\xB2"+
		"\x9E6\n\xB2\f\xB2\xE\xB2\x9E9\v\xB2\x3\xB3\x3\xB3\x3\xB3\a\xB3\x9EE\n"+
		"\xB3\f\xB3\xE\xB3\x9F1\v\xB3\x3\xB4\x5\xB4\x9F4\n\xB4\x3\xB4\x3\xB4\x3"+
		"\xB4\x5\xB4\x9F9\n\xB4\x3\xB5\x3\xB5\x3\xB5\x3\xB5\x5\xB5\x9FF\n\xB5\x3"+
		"\xB5\x5\xB5\xA02\n\xB5\x5\xB5\xA04\n\xB5\x3\xB5\x3\xB5\x3\xB6\x3\xB6\x3"+
		"\xB6\x3\xB6\x3\xB6\x5\xB6\xA0D\n\xB6\x3\xB6\x3\xB6\x3\xB6\x3\xB6\x5\xB6"+
		"\xA13\n\xB6\x3\xB7\x3\xB7\x3\xB7\x3\xB7\a\xB7\xA19\n\xB7\f\xB7\xE\xB7"+
		"\xA1C\v\xB7\x3\xB7\x3\xB7\x3\xB8\x3\xB8\x3\xB9\x3\xB9\x5\xB9\xA24\n\xB9"+
		"\x3\xBA\x3\xBA\x3\xBA\x3\xBA\x5\xBA\xA2A\n\xBA\x3\xBA\x3\xBA\x5\xBA\xA2E"+
		"\n\xBA\x3\xBA\x3\xBA\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x5\xBB\xA37\n"+
		"\xBB\x3\xBB\x3\xBB\x3\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBD\x3\xBD\x3\xBD\x3"+
		"\xBD\x5\xBD\xA43\n\xBD\x5\xBD\xA45\n\xBD\x3\xBD\x3\xBD\x5\xBD\xA49\n\xBD"+
		"\x3\xBD\x3\xBD\x3\xBE\x3\xBE\x5\xBE\xA4F\n\xBE\x3\xBE\x3\xBE\x3\xBE\x5"+
		"\xBE\xA54\n\xBE\x3\xBE\x5\xBE\xA57\n\xBE\x3\xBE\x5\xBE\xA5A\n\xBE\x3\xBF"+
		"\x3\xBF\a\xBF\xA5E\n\xBF\f\xBF\xE\xBF\xA61\v\xBF\x3\xC0\x3\xC0\x5\xC0"+
		"\xA65\n\xC0\x3\xC0\x3\xC0\x5\xC0\xA69\n\xC0\x3\xC0\x3\xC0\x5\xC0\xA6D"+
		"\n\xC0\x3\xC0\x3\xC0\x5\xC0\xA71\n\xC0\x3\xC0\x3\xC0\x3\xC1\x3\xC1\x3"+
		"\xC1\x3\xC1\x3\xC2\x3\xC2\x3\xC2\x3\xC2\x3\xC2\x3\xC2\x3\xC3\x3\xC3\x3"+
		"\xC3\a\xC3\xA82\n\xC3\f\xC3\xE\xC3\xA85\v\xC3\x3\xC4\x3\xC4\x3\xC4\x3"+
		"\xC4\x3\xC4\x5\xC4\xA8C\n\xC4\x5\xC4\xA8E\n\xC4\x3\xC5\x3\xC5\x3\xC5\x3"+
		"\xC5\x3\xC5\x5\xC5\xA95\n\xC5\x3\xC6\x3\xC6\x5\xC6\xA99\n\xC6\x3\xC6\x3"+
		"\xC6\x3\xC6\x5\xC6\xA9E\n\xC6\x3\xC6\x5\xC6\xAA1\n\xC6\x3\xC6\x5\xC6\xAA4"+
		"\n\xC6\x3\xC6\x5\xC6\xAA7\n\xC6\x3\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC7\x3"+
		"\xC7\x5\xC7\xAAF\n\xC7\x3\xC8\x3\xC8\x3\xC8\a\xC8\xAB4\n\xC8\f\xC8\xE"+
		"\xC8\xAB7\v\xC8\x3\xC9\x5\xC9\xABA\n\xC9\x3\xC9\x3\xC9\x3\xC9\a\xC9\xABF"+
		"\n\xC9\f\xC9\xE\xC9\xAC2\v\xC9\x3\xCA\x3\xCA\x3\xCA\a\xCA\xAC7\n\xCA\f"+
		"\xCA\xE\xCA\xACA\v\xCA\x3\xCB\x3\xCB\x3\xCB\a\xCB\xACF\n\xCB\f\xCB\xE"+
		"\xCB\xAD2\v\xCB\x3\xCC\x3\xCC\x5\xCC\xAD6\n\xCC\x3\xCD\x3\xCD\x5\xCD\xADA"+
		"\n\xCD\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x3\xCE\x5\xCE\xAE1\n\xCE\x3\xCE\x5"+
		"\xCE\xAE4\n\xCE\x3\xCF\x3\xCF\x3\xCF\x3\xCF\x3\xCF\x5\xCF\xAEB\n\xCF\x3"+
		"\xCF\x5\xCF\xAEE\n\xCF\x3\xD0\x3\xD0\x3\xD0\a\xD0\xAF3\n\xD0\f\xD0\xE"+
		"\xD0\xAF6\v\xD0\x3\xD1\x3\xD1\x3\xD1\a\xD1\xAFB\n\xD1\f\xD1\xE\xD1\xAFE"+
		"\v\xD1\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2\x3\xD2"+
		"\x3\xD2\x5\xD2\xB0A\n\xD2\x3\xD3\x3\xD3\x5\xD3\xB0E\n\xD3\x3\xD4\x3\xD4"+
		"\x3\xD4\x3\xD4\x3\xD4\x3\xD4\x5\xD4\xB16\n\xD4\x3\xD5\x3\xD5\x3\xD6\x3"+
		"\xD6\x3\xD7\x3\xD7\x3\xD7\x3\xD7\x3\xD7\x5\xD7\xB21\n\xD7\x3\xD8\x3\xD8"+
		"\x3\xD8\x5\xD8\xB26\n\xD8\x3\xD8\x3\xD8\x3\xD8\x3\xD8\x5\xD8\xB2C\n\xD8"+
		"\x3\xD9\x3\xD9\x3\xD9\x5\xD9\xB31\n\xD9\x3\xD9\x3\xD9\x3\xDA\x3\xDA\x3"+
		"\xDA\x5\xDA\xB38\n\xDA\x3\xDA\x3\xDA\x3\xDB\x3\xDB\x3\xDB\x3\xDB\a\xDB"+
		"\xB40\n\xDB\f\xDB\xE\xDB\xB43\v\xDB\x3\xDB\x3\xDB\x3\xDC\x3\xDC\x3\xDC"+
		"\x5\xDC\xB4A\n\xDC\x3\xDD\x3\xDD\x3\xDD\a\xDD\xB4F\n\xDD\f\xDD\xE\xDD"+
		"\xB52\v\xDD\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x3\xDE\x5\xDE\xB59\n\xDE\x3\xDE"+
		"\x3\xDE\x3\xDE\x5\xDE\xB5E\n\xDE\x3\xDE\x3\xDE\x5\xDE\xB62\n\xDE\x3\xDE"+
		"\x5\xDE\xB65\n\xDE\x3\xDF\x3\xDF\x3\xDF\x3\xDF\x5\xDF\xB6B\n\xDF\a\xDF"+
		"\xB6D\n\xDF\f\xDF\xE\xDF\xB70\v\xDF\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0"+
		"\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0"+
		"\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0"+
		"\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0"+
		"\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0"+
		"\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x3\xE0\x5\xE0\xBA5\n\xE0\x3\xE1\x3"+
		"\xE1\x3\xE1\x5\xE1\xBAA\n\xE1\x3\xE2\x3\xE2\x5\xE2\xBAE\n\xE2\x3\xE3\x3"+
		"\xE3\x5\xE3\xBB2\n\xE3\x3\xE3\x5\xE3\xBB5\n\xE3\x3\xE3\x5\xE3\xBB8\n\xE3"+
		"\x3\xE3\x5\xE3\xBBB\n\xE3\x3\xE3\x5\xE3\xBBE\n\xE3\x3\xE3\x5\xE3\xBC1"+
		"\n\xE3\x3\xE3\x5\xE3\xBC4\n\xE3\x3\xE3\x3\xE3\x5\xE3\xBC8\n\xE3\x3\xE3"+
		"\x5\xE3\xBCB\n\xE3\x3\xE3\x5\xE3\xBCE\n\xE3\x3\xE3\x5\xE3\xBD1\n\xE3\x3"+
		"\xE3\x5\xE3\xBD4\n\xE3\x3\xE3\x5\xE3\xBD7\n\xE3\x3\xE3\x3\xE3\x5\xE3\xBDB"+
		"\n\xE3\x3\xE3\x5\xE3\xBDE\n\xE3\x3\xE3\x5\xE3\xBE1\n\xE3\x3\xE3\x5\xE3"+
		"\xBE4\n\xE3\x3\xE3\x5\xE3\xBE7\n\xE3\x3\xE3\x3\xE3\x5\xE3\xBEB\n\xE3\x3"+
		"\xE3\x5\xE3\xBEE\n\xE3\x3\xE3\x5\xE3\xBF1\n\xE3\x3\xE3\x5\xE3\xBF4\n\xE3"+
		"\x3\xE3\x3\xE3\x5\xE3\xBF8\n\xE3\x3\xE3\x5\xE3\xBFB\n\xE3\x3\xE3\x5\xE3"+
		"\xBFE\n\xE3\x3\xE3\x3\xE3\x5\xE3\xC02\n\xE3\x3\xE3\x5\xE3\xC05\n\xE3\x3"+
		"\xE3\x3\xE3\x5\xE3\xC09\n\xE3\x3\xE3\x5\xE3\xC0C\n\xE3\x3\xE4\x3\xE4\x3"+
		"\xE4\x5\xE4\xC11\n\xE4\x3\xE4\x3\xE4\x3\xE5\x3\xE5\x3\xE5\x5\xE5\xC18"+
		"\n\xE5\x3\xE5\x3\xE5\x3\xE6\x3\xE6\x3\xE6\x5\xE6\xC1F\n\xE6\x3\xE6\x3"+
		"\xE6\x3\xE7\x3\xE7\x3\xE7\x5\xE7\xC26\n\xE7\x3\xE7\x3\xE7\x3\xE8\x3\xE8"+
		"\x3\xE8\x5\xE8\xC2D\n\xE8\x3\xE8\x3\xE8\x3\xE9\x3\xE9\x3\xE9\x5\xE9\xC34"+
		"\n\xE9\x3\xE9\x3\xE9\x3\xEA\x3\xEA\x3\xEA\x5\xEA\xC3B\n\xEA\x3\xEA\x3"+
		"\xEA\x3\xEB\x3\xEB\x3\xEB\x5\xEB\xC42\n\xEB\x3\xEB\x3\xEB\x3\xEC\x3\xEC"+
		"\x3\xED\x3\xED\x3\xED\x5\xED\xC4B\n\xED\x3\xEE\x3\xEE\x3\xEE\x3\xEE\x3"+
		"\xEE\x5\xEE\xC52\n\xEE\x3\xEF\x3\xEF\x5\xEF\xC56\n\xEF\x3\xEF\x3\xEF\x3"+
		"\xF0\x3\xF0\x5\xF0\xC5C\n\xF0\x3\xF1\x3\xF1\x3\xF1\x5\xF1\xC61\n\xF1\x3"+
		"\xF2\x3\xF2\x3\xF2\x3\xF2\x3\xF3\x3\xF3\x5\xF3\xC69\n\xF3\x3\xF3\x3\xF3"+
		"\x3\xF4\x3\xF4\x3\xF4\a\xF4\xC70\n\xF4\f\xF4\xE\xF4\xC73\v\xF4\x3\xF4"+
		"\x5\xF4\xC76\n\xF4\x3\xF5\x3\xF5\x3\xF5\a\xF5\xC7B\n\xF5\f\xF5\xE\xF5"+
		"\xC7E\v\xF5\x3\xF5\x5\xF5\xC81\n\xF5\x3\xF6\x3\xF6\x5\xF6\xC85\n\xF6\x3"+
		"\xF6\x3\xF6\x3\xF6\x3\xF6\x2\x2\x2\xF7\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2"+
		"\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2"+
		"$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2"+
		"@\x2\x42\x2\x44\x2\x46\x2H\x2J\x2L\x2N\x2P\x2R\x2T\x2V\x2X\x2Z\x2\\\x2"+
		"^\x2`\x2\x62\x2\x64\x2\x66\x2h\x2j\x2l\x2n\x2p\x2r\x2t\x2v\x2x\x2z\x2"+
		"|\x2~\x2\x80\x2\x82\x2\x84\x2\x86\x2\x88\x2\x8A\x2\x8C\x2\x8E\x2\x90\x2"+
		"\x92\x2\x94\x2\x96\x2\x98\x2\x9A\x2\x9C\x2\x9E\x2\xA0\x2\xA2\x2\xA4\x2"+
		"\xA6\x2\xA8\x2\xAA\x2\xAC\x2\xAE\x2\xB0\x2\xB2\x2\xB4\x2\xB6\x2\xB8\x2"+
		"\xBA\x2\xBC\x2\xBE\x2\xC0\x2\xC2\x2\xC4\x2\xC6\x2\xC8\x2\xCA\x2\xCC\x2"+
		"\xCE\x2\xD0\x2\xD2\x2\xD4\x2\xD6\x2\xD8\x2\xDA\x2\xDC\x2\xDE\x2\xE0\x2"+
		"\xE2\x2\xE4\x2\xE6\x2\xE8\x2\xEA\x2\xEC\x2\xEE\x2\xF0\x2\xF2\x2\xF4\x2"+
		"\xF6\x2\xF8\x2\xFA\x2\xFC\x2\xFE\x2\x100\x2\x102\x2\x104\x2\x106\x2\x108"+
		"\x2\x10A\x2\x10C\x2\x10E\x2\x110\x2\x112\x2\x114\x2\x116\x2\x118\x2\x11A"+
		"\x2\x11C\x2\x11E\x2\x120\x2\x122\x2\x124\x2\x126\x2\x128\x2\x12A\x2\x12C"+
		"\x2\x12E\x2\x130\x2\x132\x2\x134\x2\x136\x2\x138\x2\x13A\x2\x13C\x2\x13E"+
		"\x2\x140\x2\x142\x2\x144\x2\x146\x2\x148\x2\x14A\x2\x14C\x2\x14E\x2\x150"+
		"\x2\x152\x2\x154\x2\x156\x2\x158\x2\x15A\x2\x15C\x2\x15E\x2\x160\x2\x162"+
		"\x2\x164\x2\x166\x2\x168\x2\x16A\x2\x16C\x2\x16E\x2\x170\x2\x172\x2\x174"+
		"\x2\x176\x2\x178\x2\x17A\x2\x17C\x2\x17E\x2\x180\x2\x182\x2\x184\x2\x186"+
		"\x2\x188\x2\x18A\x2\x18C\x2\x18E\x2\x190\x2\x192\x2\x194\x2\x196\x2\x198"+
		"\x2\x19A\x2\x19C\x2\x19E\x2\x1A0\x2\x1A2\x2\x1A4\x2\x1A6\x2\x1A8\x2\x1AA"+
		"\x2\x1AC\x2\x1AE\x2\x1B0\x2\x1B2\x2\x1B4\x2\x1B6\x2\x1B8\x2\x1BA\x2\x1BC"+
		"\x2\x1BE\x2\x1C0\x2\x1C2\x2\x1C4\x2\x1C6\x2\x1C8\x2\x1CA\x2\x1CC\x2\x1CE"+
		"\x2\x1D0\x2\x1D2\x2\x1D4\x2\x1D6\x2\x1D8\x2\x1DA\x2\x1DC\x2\x1DE\x2\x1E0"+
		"\x2\x1E2\x2\x1E4\x2\x1E6\x2\x1E8\x2\x1EA\x2\x2\x14\x3\x2\x8A\x8B\x4\x2"+
		"\x8C\x8C\x95\x95\x4\x2\v\v\x96\x96\x3\x2\x83\x84\x5\x2\xAB\xAB\xAD\xAD"+
		"\xB0\xB0\x4\x2\x9D\x9D\xA0\xA0\x5\x2\x9B\x9B\xA3\xA3\xA5\xA5\x3\x2,-\x4"+
		"\x2\x10\x10\x96\x96\x3\x2XY\x3\x2Z[\x3\x2\\]\x3\x2^_\x3\x2`\x61\x4\x2"+
		"\x14\x14\x62\x63\x3\x2\x64\x66\x3\x2gi\x3\x2\xC2\xC3\xE24\x2\x1F0\x3\x2"+
		"\x2\x2\x4\x1FA\x3\x2\x2\x2\x6\x200\x3\x2\x2\x2\b\x203\x3\x2\x2\x2\n\x206"+
		"\x3\x2\x2\x2\f\x21F\x3\x2\x2\x2\xE\x22D\x3\x2\x2\x2\x10\x234\x3\x2\x2"+
		"\x2\x12\x238\x3\x2\x2\x2\x14\x242\x3\x2\x2\x2\x16\x24A\x3\x2\x2\x2\x18"+
		"\x253\x3\x2\x2\x2\x1A\x255\x3\x2\x2\x2\x1C\x266\x3\x2\x2\x2\x1E\x27B\x3"+
		"\x2\x2\x2 \x280\x3\x2\x2\x2\"\x2A9\x3\x2\x2\x2$\x2BE\x3\x2\x2\x2&\x2C5"+
		"\x3\x2\x2\x2(\x2C9\x3\x2\x2\x2*\x2D5\x3\x2\x2\x2,\x2EA\x3\x2\x2\x2.\x2EC"+
		"\x3\x2\x2\x2\x30\x2F7\x3\x2\x2\x2\x32\x308\x3\x2\x2\x2\x34\x314\x3\x2"+
		"\x2\x2\x36\x317\x3\x2\x2\x2\x38\x32A\x3\x2\x2\x2:\x350\x3\x2\x2\x2<\x35D"+
		"\x3\x2\x2\x2>\x365\x3\x2\x2\x2@\x36A\x3\x2\x2\x2\x42\x370\x3\x2\x2\x2"+
		"\x44\x373\x3\x2\x2\x2\x46\x380\x3\x2\x2\x2H\x382\x3\x2\x2\x2J\x389\x3"+
		"\x2\x2\x2L\x3B0\x3\x2\x2\x2N\x3B4\x3\x2\x2\x2P\x3C0\x3\x2\x2\x2R\x3C8"+
		"\x3\x2\x2\x2T\x3CC\x3\x2\x2\x2V\x3DE\x3\x2\x2\x2X\x3E8\x3\x2\x2\x2Z\x3F0"+
		"\x3\x2\x2\x2\\\x403\x3\x2\x2\x2^\x40B\x3\x2\x2\x2`\x413\x3\x2\x2\x2\x62"+
		"\x41F\x3\x2\x2\x2\x64\x431\x3\x2\x2\x2\x66\x433\x3\x2\x2\x2h\x439\x3\x2"+
		"\x2\x2j\x44C\x3\x2\x2\x2l\x458\x3\x2\x2\x2n\x45B\x3\x2\x2\x2p\x462\x3"+
		"\x2\x2\x2r\x46A\x3\x2\x2\x2t\x48C\x3\x2\x2\x2v\x48E\x3\x2\x2\x2x\x492"+
		"\x3\x2\x2\x2z\x49C\x3\x2\x2\x2|\x4A1\x3\x2\x2\x2~\x4A8\x3\x2\x2\x2\x80"+
		"\x4AB\x3\x2\x2\x2\x82\x4B4\x3\x2\x2\x2\x84\x4B8\x3\x2\x2\x2\x86\x4C5\x3"+
		"\x2\x2\x2\x88\x4C7\x3\x2\x2\x2\x8A\x4CB\x3\x2\x2\x2\x8C\x4E0\x3\x2\x2"+
		"\x2\x8E\x4E2\x3\x2\x2\x2\x90\x4EA\x3\x2\x2\x2\x92\x4F8\x3\x2\x2\x2\x94"+
		"\x4FA\x3\x2\x2\x2\x96\x544\x3\x2\x2\x2\x98\x546\x3\x2\x2\x2\x9A\x556\x3"+
		"\x2\x2\x2\x9C\x558\x3\x2\x2\x2\x9E\x55F\x3\x2\x2\x2\xA0\x56A\x3\x2\x2"+
		"\x2\xA2\x56E\x3\x2\x2\x2\xA4\x576\x3\x2\x2\x2\xA6\x579\x3\x2\x2\x2\xA8"+
		"\x583\x3\x2\x2\x2\xAA\x585\x3\x2\x2\x2\xAC\x58B\x3\x2\x2\x2\xAE\x596\x3"+
		"\x2\x2\x2\xB0\x59E\x3\x2\x2\x2\xB2\x5A7\x3\x2\x2\x2\xB4\x5AA\x3\x2\x2"+
		"\x2\xB6\x5BA\x3\x2\x2\x2\xB8\x5C1\x3\x2\x2\x2\xBA\x5CA\x3\x2\x2\x2\xBC"+
		"\x5CE\x3\x2\x2\x2\xBE\x5D3\x3\x2\x2\x2\xC0\x5DA\x3\x2\x2\x2\xC2\x5E5\x3"+
		"\x2\x2\x2\xC4\x5E7\x3\x2\x2\x2\xC6\x5F1\x3\x2\x2\x2\xC8\x5F4\x3\x2\x2"+
		"\x2\xCA\x5FF\x3\x2\x2\x2\xCC\x618\x3\x2\x2\x2\xCE\x621\x3\x2\x2\x2\xD0"+
		"\x62C\x3\x2\x2\x2\xD2\x63D\x3\x2\x2\x2\xD4\x647\x3\x2\x2\x2\xD6\x653\x3"+
		"\x2\x2\x2\xD8\x65E\x3\x2\x2\x2\xDA\x660\x3\x2\x2\x2\xDC\x66C\x3\x2\x2"+
		"\x2\xDE\x67B\x3\x2\x2\x2\xE0\x68A\x3\x2\x2\x2\xE2\x68C\x3\x2\x2\x2\xE4"+
		"\x694\x3\x2\x2\x2\xE6\x699\x3\x2\x2\x2\xE8\x69C\x3\x2\x2\x2\xEA\x6C5\x3"+
		"\x2\x2\x2\xEC\x6D0\x3\x2\x2\x2\xEE\x6D9\x3\x2\x2\x2\xF0\x6E5\x3\x2\x2"+
		"\x2\xF2\x6E9\x3\x2\x2\x2\xF4\x6EE\x3\x2\x2\x2\xF6\x6F1\x3\x2\x2\x2\xF8"+
		"\x706\x3\x2\x2\x2\xFA\x710\x3\x2\x2\x2\xFC\x719\x3\x2\x2\x2\xFE\x720\x3"+
		"\x2\x2\x2\x100\x723\x3\x2\x2\x2\x102\x728\x3\x2\x2\x2\x104\x72F\x3\x2"+
		"\x2\x2\x106\x735\x3\x2\x2\x2\x108\x73E\x3\x2\x2\x2\x10A\x745\x3\x2\x2"+
		"\x2\x10C\x747\x3\x2\x2\x2\x10E\x752\x3\x2\x2\x2\x110\x75E\x3\x2\x2\x2"+
		"\x112\x76C\x3\x2\x2\x2\x114\x778\x3\x2\x2\x2\x116\x781\x3\x2\x2\x2\x118"+
		"\x785\x3\x2\x2\x2\x11A\x7A3\x3\x2\x2\x2\x11C\x7A5\x3\x2\x2\x2\x11E\x7AD"+
		"\x3\x2\x2\x2\x120\x7B5\x3\x2\x2\x2\x122\x7C0\x3\x2\x2\x2\x124\x7C2\x3"+
		"\x2\x2\x2\x126\x7E0\x3\x2\x2\x2\x128\x824\x3\x2\x2\x2\x12A\x826\x3\x2"+
		"\x2\x2\x12C\x832\x3\x2\x2\x2\x12E\x83A\x3\x2\x2\x2\x130\x87D\x3\x2\x2"+
		"\x2\x132\x87F\x3\x2\x2\x2\x134\x883\x3\x2\x2\x2\x136\x88C\x3\x2\x2\x2"+
		"\x138\x891\x3\x2\x2\x2\x13A\x895\x3\x2\x2\x2\x13C\x897\x3\x2\x2\x2\x13E"+
		"\x89A\x3\x2\x2\x2\x140\x8AD\x3\x2\x2\x2\x142\x8C2\x3\x2\x2\x2\x144\x974"+
		"\x3\x2\x2\x2\x146\x979\x3\x2\x2\x2\x148\x985\x3\x2\x2\x2\x14A\x987\x3"+
		"\x2\x2\x2\x14C\x994\x3\x2\x2\x2\x14E\x99D\x3\x2\x2\x2\x150\x9A8\x3\x2"+
		"\x2\x2\x152\x9AE\x3\x2\x2\x2\x154\x9BA\x3\x2\x2\x2\x156\x9BD\x3\x2\x2"+
		"\x2\x158\x9C8\x3\x2\x2\x2\x15A\x9CC\x3\x2\x2\x2\x15C\x9D0\x3\x2\x2\x2"+
		"\x15E\x9D2\x3\x2\x2\x2\x160\x9DE\x3\x2\x2\x2\x162\x9E2\x3\x2\x2\x2\x164"+
		"\x9EA\x3\x2\x2\x2\x166\x9F3\x3\x2\x2\x2\x168\xA03\x3\x2\x2\x2\x16A\xA0C"+
		"\x3\x2\x2\x2\x16C\xA14\x3\x2\x2\x2\x16E\xA1F\x3\x2\x2\x2\x170\xA23\x3"+
		"\x2\x2\x2\x172\xA25\x3\x2\x2\x2\x174\xA31\x3\x2\x2\x2\x176\xA3A\x3\x2"+
		"\x2\x2\x178\xA3E\x3\x2\x2\x2\x17A\xA4E\x3\x2\x2\x2\x17C\xA5B\x3\x2\x2"+
		"\x2\x17E\xA62\x3\x2\x2\x2\x180\xA74\x3\x2\x2\x2\x182\xA78\x3\x2\x2\x2"+
		"\x184\xA7E\x3\x2\x2\x2\x186\xA8D\x3\x2\x2\x2\x188\xA8F\x3\x2\x2\x2\x18A"+
		"\xA98\x3\x2\x2\x2\x18C\xAA8\x3\x2\x2\x2\x18E\xAB0\x3\x2\x2\x2\x190\xAB9"+
		"\x3\x2\x2\x2\x192\xAC3\x3\x2\x2\x2\x194\xACB\x3\x2\x2\x2\x196\xAD5\x3"+
		"\x2\x2\x2\x198\xAD9\x3\x2\x2\x2\x19A\xADB\x3\x2\x2\x2\x19C\xAE5\x3\x2"+
		"\x2\x2\x19E\xAEF\x3\x2\x2\x2\x1A0\xAF7\x3\x2\x2\x2\x1A2\xB09\x3\x2\x2"+
		"\x2\x1A4\xB0D\x3\x2\x2\x2\x1A6\xB0F\x3\x2\x2\x2\x1A8\xB17\x3\x2\x2\x2"+
		"\x1AA\xB19\x3\x2\x2\x2\x1AC\xB1B\x3\x2\x2\x2\x1AE\xB25\x3\x2\x2\x2\x1B0"+
		"\xB30\x3\x2\x2\x2\x1B2\xB37\x3\x2\x2\x2\x1B4\xB3B\x3\x2\x2\x2\x1B6\xB49"+
		"\x3\x2\x2\x2\x1B8\xB4B\x3\x2\x2\x2\x1BA\xB53\x3\x2\x2\x2\x1BC\xB66\x3"+
		"\x2\x2\x2\x1BE\xBA4\x3\x2\x2\x2\x1C0\xBA9\x3\x2\x2\x2\x1C2\xBAD\x3\x2"+
		"\x2\x2\x1C4\xC0B\x3\x2\x2\x2\x1C6\xC10\x3\x2\x2\x2\x1C8\xC17\x3\x2\x2"+
		"\x2\x1CA\xC1E\x3\x2\x2\x2\x1CC\xC25\x3\x2\x2\x2\x1CE\xC2C\x3\x2\x2\x2"+
		"\x1D0\xC33\x3\x2\x2\x2\x1D2\xC3A\x3\x2\x2\x2\x1D4\xC41\x3\x2\x2\x2\x1D6"+
		"\xC45\x3\x2\x2\x2\x1D8\xC47\x3\x2\x2\x2\x1DA\xC51\x3\x2\x2\x2\x1DC\xC55"+
		"\x3\x2\x2\x2\x1DE\xC5B\x3\x2\x2\x2\x1E0\xC60\x3\x2\x2\x2\x1E2\xC62\x3"+
		"\x2\x2\x2\x1E4\xC66\x3\x2\x2\x2\x1E6\xC6C\x3\x2\x2\x2\x1E8\xC77\x3\x2"+
		"\x2\x2\x1EA\xC84\x3\x2\x2\x2\x1EC\x1EF\x5\x12\n\x2\x1ED\x1EF\x5\n\x6\x2"+
		"\x1EE\x1EC\x3\x2\x2\x2\x1EE\x1ED\x3\x2\x2\x2\x1EF\x1F2\x3\x2\x2\x2\x1F0"+
		"\x1EE\x3\x2\x2\x2\x1F0\x1F1\x3\x2\x2\x2\x1F1\x1F3\x3\x2\x2\x2\x1F2\x1F0"+
		"\x3\x2\x2\x2\x1F3\x1F4\x5\x15C\xAF\x2\x1F4\x1F5\a\x2\x2\x3\x1F5\x3\x3"+
		"\x2\x2\x2\x1F6\x1F9\x5\x12\n\x2\x1F7\x1F9\x5\n\x6\x2\x1F8\x1F6\x3\x2\x2"+
		"\x2\x1F8\x1F7\x3\x2\x2\x2\x1F9\x1FC\x3\x2\x2\x2\x1FA\x1F8\x3\x2\x2\x2"+
		"\x1FA\x1FB\x3\x2\x2\x2\x1FB\x1FD\x3\x2\x2\x2\x1FC\x1FA\x3\x2\x2\x2\x1FD"+
		"\x1FE\x5\x1C\xF\x2\x1FE\x1FF\a\x2\x2\x3\x1FF\x5\x3\x2\x2\x2\x200\x201"+
		"\x5\x1B8\xDD\x2\x201\x202\a\x2\x2\x3\x202\a\x3\x2\x2\x2\x203\x204\x5\x1E0"+
		"\xF1\x2\x204\x205\a\x2\x2\x3\x205\t\x3\x2\x2\x2\x206\x208\a|\x2\x2\x207"+
		"\x209\x5\x18E\xC8\x2\x208\x207\x3\x2\x2\x2\x208\x209\x3\x2\x2\x2\x209"+
		"\x20C\x3\x2\x2\x2\x20A\x20B\a\x91\x2\x2\x20B\x20D\a\x92\x2\x2\x20C\x20A"+
		"\x3\x2\x2\x2\x20C\x20D\x3\x2\x2\x2\x20D\x20F\x3\x2\x2\x2\x20E\x210\x5"+
		"\f\a\x2\x20F\x20E\x3\x2\x2\x2\x20F\x210\x3\x2\x2\x2\x210\x211\x3\x2\x2"+
		"\x2\x211\x217\a\xC1\x2\x2\x212\x214\a\x8F\x2\x2\x213\x215\x5\xAEX\x2\x214"+
		"\x213\x3\x2\x2\x2\x214\x215\x3\x2\x2\x2\x215\x216\x3\x2\x2\x2\x216\x218"+
		"\a\x90\x2\x2\x217\x212\x3\x2\x2\x2\x217\x218\x3\x2\x2\x2\x218\x21B\x3"+
		"\x2\x2\x2\x219\x21A\a\xC1\x2\x2\x21A\x21C\aw\x2\x2\x21B\x219\x3\x2\x2"+
		"\x2\x21B\x21C\x3\x2\x2\x2\x21C\x21D\x3\x2\x2\x2\x21D\x21E\x5\xE\b\x2\x21E"+
		"\v\x3\x2\x2\x2\x21F\x220\a\xC1\x2\x2\x220\x221\a\x95\x2\x2\x221\r\x3\x2"+
		"\x2\x2\x222\x224\a\x93\x2\x2\x223\x225\x5\x10\t\x2\x224\x223\x3\x2\x2"+
		"\x2\x224\x225\x3\x2\x2\x2\x225\x226\x3\x2\x2\x2\x226\x227\x5\x118\x8D"+
		"\x2\x227\x228\a\x94\x2\x2\x228\x22E\x3\x2\x2\x2\x229\x22A\a\x91\x2\x2"+
		"\x22A\x22B\x5\x1DE\xF0\x2\x22B\x22C\a\x92\x2\x2\x22C\x22E\x3\x2\x2\x2"+
		"\x22D\x222\x3\x2\x2\x2\x22D\x229\x3\x2\x2\x2\x22E\xF\x3\x2\x2\x2\x22F"+
		"\x235\a\xC1\x2\x2\x230\x231\a\x8F\x2\x2\x231\x232\x5\xAEX\x2\x232\x233"+
		"\a\x90\x2\x2\x233\x235\x3\x2\x2\x2\x234\x22F\x3\x2\x2\x2\x234\x230\x3"+
		"\x2\x2\x2\x235\x236\x3\x2\x2\x2\x236\x237\t\x2\x2\x2\x237\x11\x3\x2\x2"+
		"\x2\x238\x239\a\xBA\x2\x2\x239\x240\x5\x18E\xC8\x2\x23A\x23D\a\x8F\x2"+
		"\x2\x23B\x23E\x5\x14\v\x2\x23C\x23E\x5\x18\r\x2\x23D\x23B\x3\x2\x2\x2"+
		"\x23D\x23C\x3\x2\x2\x2\x23D\x23E\x3\x2\x2\x2\x23E\x23F\x3\x2\x2\x2\x23F"+
		"\x241\a\x90\x2\x2\x240\x23A\x3\x2\x2\x2\x240\x241\x3\x2\x2\x2\x241\x13"+
		"\x3\x2\x2\x2\x242\x247\x5\x16\f\x2\x243\x244\a\x96\x2\x2\x244\x246\x5"+
		"\x16\f\x2\x245\x243\x3\x2\x2\x2\x246\x249\x3\x2\x2\x2\x247\x245\x3\x2"+
		"\x2\x2\x247\x248\x3\x2\x2\x2\x248\x15\x3\x2\x2\x2\x249\x247\x3\x2\x2\x2"+
		"\x24A\x24B\a\xC1\x2\x2\x24B\x24C\a\x8C\x2\x2\x24C\x24D\x5\x18\r\x2\x24D"+
		"\x17\x3\x2\x2\x2\x24E\x254\x5\x12\n\x2\x24F\x254\x5\x1A\xE\x2\x250\x254"+
		"\x5\x1DA\xEE\x2\x251\x254\a\xC1\x2\x2\x252\x254\x5\x18E\xC8\x2\x253\x24E"+
		"\x3\x2\x2\x2\x253\x24F\x3\x2\x2\x2\x253\x250\x3\x2\x2\x2\x253\x251\x3"+
		"\x2\x2\x2\x253\x252\x3\x2\x2\x2\x254\x19\x3\x2\x2\x2\x255\x25E\a\x93\x2"+
		"\x2\x256\x25B\x5\x18\r\x2\x257\x258\a\x96\x2\x2\x258\x25A\x5\x18\r\x2"+
		"\x259\x257\x3\x2\x2\x2\x25A\x25D\x3\x2\x2\x2\x25B\x259\x3\x2\x2\x2\x25B"+
		"\x25C\x3\x2\x2\x2\x25C\x25F\x3\x2\x2\x2\x25D\x25B\x3\x2\x2\x2\x25E\x256"+
		"\x3\x2\x2\x2\x25E\x25F\x3\x2\x2\x2\x25F\x261\x3\x2\x2\x2\x260\x262\a\x96"+
		"\x2\x2\x261\x260\x3\x2\x2\x2\x261\x262\x3\x2\x2\x2\x262\x263\x3\x2\x2"+
		"\x2\x263\x264\a\x94\x2\x2\x264\x1B\x3\x2\x2\x2\x265\x267\x5\x1E\x10\x2"+
		"\x266\x265\x3\x2\x2\x2\x266\x267\x3\x2\x2\x2\x267\x276\x3\x2\x2\x2\x268"+
		"\x277\x5 \x11\x2\x269\x277\x5J&\x2\x26A\x277\x5N(\x2\x26B\x277\x5T+\x2"+
		"\x26C\x277\x5V,\x2\x26D\x277\x5\x66\x34\x2\x26E\x277\x5\x8EH\x2\x26F\x277"+
		"\x5\x90I\x2\x270\x277\x5\"\x12\x2\x271\x277\x5&\x14\x2\x272\x277\x5p\x39"+
		"\x2\x273\x277\x5j\x36\x2\x274\x277\x5l\x37\x2\x275\x277\x5n\x38\x2\x276"+
		"\x268\x3\x2\x2\x2\x276\x269\x3\x2\x2\x2\x276\x26A\x3\x2\x2\x2\x276\x26B"+
		"\x3\x2\x2\x2\x276\x26C\x3\x2\x2\x2\x276\x26D\x3\x2\x2\x2\x276\x26E\x3"+
		"\x2\x2\x2\x276\x26F\x3\x2\x2\x2\x276\x270\x3\x2\x2\x2\x276\x271\x3\x2"+
		"\x2\x2\x276\x272\x3\x2\x2\x2\x276\x273\x3\x2\x2\x2\x276\x274\x3\x2\x2"+
		"\x2\x276\x275\x3\x2\x2\x2\x277\x279\x3\x2\x2\x2\x278\x27A\x5\xCCg\x2\x279"+
		"\x278\x3\x2\x2\x2\x279\x27A\x3\x2\x2\x2\x27A\x1D\x3\x2\x2\x2\x27B\x27C"+
		"\a\x7F\x2\x2\x27C\x27D\a\xC1\x2\x2\x27D\x1F\x3\x2\x2\x2\x27E\x27F\a\x35"+
		"\x2\x2\x27F\x281\x5\xAAV\x2\x280\x27E\x3\x2\x2\x2\x280\x281\x3\x2\x2\x2"+
		"\x281\x284\x3\x2\x2\x2\x282\x283\a\x34\x2\x2\x283\x285\x5\xACW\x2\x284"+
		"\x282\x3\x2\x2\x2\x284\x285\x3\x2\x2\x2\x285\x286\x3\x2\x2\x2\x286\x287"+
		"\a\x1A\x2\x2\x287\x28A\x5\xBE`\x2\x288\x289\a \x2\x2\x289\x28B\x5\xB0"+
		"Y\x2\x28A\x288\x3\x2\x2\x2\x28A\x28B\x3\x2\x2\x2\x28B\x28D\x3\x2\x2\x2"+
		"\x28C\x28E\x5\xF6|\x2\x28D\x28C\x3\x2\x2\x2\x28D\x28E\x3\x2\x2\x2\x28E"+
		"\x291\x3\x2\x2\x2\x28F\x290\a\xF\x2\x2\x290\x292\x5\xBC_\x2\x291\x28F"+
		"\x3\x2\x2\x2\x291\x292\x3\x2\x2\x2\x292\x296\x3\x2\x2\x2\x293\x294\a*"+
		"\x2\x2\x294\x295\a)\x2\x2\x295\x297\x5\xD6l\x2\x296\x293\x3\x2\x2\x2\x296"+
		"\x297\x3\x2\x2\x2\x297\x29A\x3\x2\x2\x2\x298\x299\a+\x2\x2\x299\x29B\x5"+
		"\xE6t\x2\x29A\x298\x3\x2\x2\x2\x29A\x29B\x3\x2\x2\x2\x29B\x29E\x3\x2\x2"+
		"\x2\x29C\x29D\a\x30\x2\x2\x29D\x29F\x5\xE8u\x2\x29E\x29C\x3\x2\x2\x2\x29E"+
		"\x29F\x3\x2\x2\x2\x29F\x2A3\x3\x2\x2\x2\x2A0\x2A1\a\x37\x2\x2\x2A1\x2A2"+
		"\a)\x2\x2\x2A2\x2A4\x5\xE2r\x2\x2A3\x2A0\x3\x2\x2\x2\x2A3\x2A4\x3\x2\x2"+
		"\x2\x2A4\x2A7\x3\x2\x2\x2\x2A5\x2A6\am\x2\x2\x2A6\x2A8\x5\xEEx\x2\x2A7"+
		"\x2A5\x3\x2\x2\x2\x2A7\x2A8\x3\x2\x2\x2\x2A8!\x3\x2\x2\x2\x2A9\x2AA\a"+
		"\'\x2\x2\x2AA\x2BA\x5$\x13\x2\x2AB\x2BB\x5@!\x2\x2AC\x2B5\x5\x38\x1D\x2"+
		"\x2AD\x2AF\x5<\x1F\x2\x2AE\x2AD\x3\x2\x2\x2\x2AF\x2B0\x3\x2\x2\x2\x2B0"+
		"\x2AE\x3\x2\x2\x2\x2B0\x2B1\x3\x2\x2\x2\x2B1\x2B3\x3\x2\x2\x2\x2B2\x2B4"+
		"\x5> \x2\x2B3\x2B2\x3\x2\x2\x2\x2B3\x2B4\x3\x2\x2\x2\x2B4\x2B6\x3\x2\x2"+
		"\x2\x2B5\x2AE\x3\x2\x2\x2\x2B5\x2B6\x3\x2\x2\x2\x2B6\x2BB\x3\x2\x2\x2"+
		"\x2B7\x2BB\x5\x42\"\x2\x2B8\x2BB\x5:\x1E\x2\x2B9\x2BB\x5*\x16\x2\x2BA"+
		"\x2AB\x3\x2\x2\x2\x2BA\x2AC\x3\x2\x2\x2\x2BA\x2B7\x3\x2\x2\x2\x2BA\x2B8"+
		"\x3\x2\x2\x2\x2BA\x2B9\x3\x2\x2\x2\x2BB#\x3\x2\x2\x2\x2BC\x2BF\x5\x17A"+
		"\xBE\x2\x2BD\x2BF\x5\xCEh\x2\x2BE\x2BC\x3\x2\x2\x2\x2BE\x2BD\x3\x2\x2"+
		"\x2\x2BF\x2C3\x3\x2\x2\x2\x2C0\x2C1\a\x10\x2\x2\x2C1\x2C4\a\xC1\x2\x2"+
		"\x2C2\x2C4\a\xC1\x2\x2\x2C3\x2C0\x3\x2\x2\x2\x2C3\x2C2\x3\x2\x2\x2\x2C3"+
		"\x2C4\x3\x2\x2\x2\x2C4%\x3\x2\x2\x2\x2C5\x2C6\ao\x2\x2\x2C6\x2C7\a;\x2"+
		"\x2\x2C7\x2C8\x5(\x15\x2\x2C8\'\x3\x2\x2\x2\x2C9\x2CD\x5\x18E\xC8\x2\x2CA"+
		"\x2CB\a\x10\x2\x2\x2CB\x2CE\a\xC1\x2\x2\x2CC\x2CE\a\xC1\x2\x2\x2CD\x2CA"+
		"\x3\x2\x2\x2\x2CD\x2CC\x3\x2\x2\x2\x2CD\x2CE\x3\x2\x2\x2\x2CE\x2CF\x3"+
		"\x2\x2\x2\x2CF\x2D0\aR\x2\x2\x2D0\x2D3\x5\x44#\x2\x2D1\x2D2\a\xF\x2\x2"+
		"\x2D2\x2D4\x5\xBC_\x2\x2D3\x2D1\x3\x2\x2\x2\x2D3\x2D4\x3\x2\x2\x2\x2D4"+
		")\x3\x2\x2\x2\x2D5\x2D7\az\x2\x2\x2D6\x2D8\a\x35\x2\x2\x2D7\x2D6\x3\x2"+
		"\x2\x2\x2D7\x2D8\x3\x2\x2\x2\x2D8\x2D9\x3\x2\x2\x2\x2D9\x2DD\a\xC1\x2"+
		"\x2\x2DA\x2DB\a\x10\x2\x2\x2DB\x2DE\a\xC1\x2\x2\x2DC\x2DE\a\xC1\x2\x2"+
		"\x2DD\x2DA\x3\x2\x2\x2\x2DD\x2DC\x3\x2\x2\x2\x2DD\x2DE\x3\x2\x2\x2\x2DE"+
		"\x2E1\x3\x2\x2\x2\x2DF\x2E0\a\xF\x2\x2\x2E0\x2E2\x5\xBC_\x2\x2E1\x2DF"+
		"\x3\x2\x2\x2\x2E1\x2E2\x3\x2\x2\x2\x2E2\x2E4\x3\x2\x2\x2\x2E3\x2E5\x5"+
		",\x17\x2\x2E4\x2E3\x3\x2\x2\x2\x2E5\x2E6\x3\x2\x2\x2\x2E6\x2E4\x3\x2\x2"+
		"\x2\x2E6\x2E7\x3\x2\x2\x2\x2E7+\x3\x2\x2\x2\x2E8\x2EB\x5.\x18\x2\x2E9"+
		"\x2EB\x5\x32\x1A\x2\x2EA\x2E8\x3\x2\x2\x2\x2EA\x2E9\x3\x2\x2\x2\x2EB-"+
		"\x3\x2\x2\x2\x2EC\x2ED\a\x1D\x2\x2\x2ED\x2F0\a{\x2\x2\x2EE\x2EF\a\v\x2"+
		"\x2\x2EF\x2F1\x5\x118\x8D\x2\x2F0\x2EE\x3\x2\x2\x2\x2F0\x2F1\x3\x2\x2"+
		"\x2\x2F1\x2F3\x3\x2\x2\x2\x2F2\x2F4\x5\x30\x19\x2\x2F3\x2F2\x3\x2\x2\x2"+
		"\x2F4\x2F5\x3\x2\x2\x2\x2F5\x2F3\x3\x2\x2\x2\x2F5\x2F6\x3\x2\x2\x2\x2F6"+
		"/\x3\x2\x2\x2\x2F7\x306\a\x1E\x2\x2\x2F8\x2F9\ao\x2\x2\x2F9\x2FA\aR\x2"+
		"\x2\x2FA\x2FB\x5\x44#\x2\x2FB\x2FE\x3\x2\x2\x2\x2FC\x2FD\a\xF\x2\x2\x2FD"+
		"\x2FF\x5\xBC_\x2\x2FE\x2FC\x3\x2\x2\x2\x2FE\x2FF\x3\x2\x2\x2\x2FF\x307"+
		"\x3\x2\x2\x2\x300\x303\aP\x2\x2\x301\x302\a\xF\x2\x2\x302\x304\x5\xBC"+
		"_\x2\x303\x301\x3\x2\x2\x2\x303\x304\x3\x2\x2\x2\x304\x307\x3\x2\x2\x2"+
		"\x305\x307\x5\x36\x1C\x2\x306\x2F8\x3\x2\x2\x2\x306\x300\x3\x2\x2\x2\x306"+
		"\x305\x3\x2\x2\x2\x307\x31\x3\x2\x2\x2\x308\x309\a\x1D\x2\x2\x309\x30A"+
		"\a\f\x2\x2\x30A\x30D\a{\x2\x2\x30B\x30C\a\v\x2\x2\x30C\x30E\x5\x118\x8D"+
		"\x2\x30D\x30B\x3\x2\x2\x2\x30D\x30E\x3\x2\x2\x2\x30E\x310\x3\x2\x2\x2"+
		"\x30F\x311\x5\x34\x1B\x2\x310\x30F\x3\x2\x2\x2\x311\x312\x3\x2\x2\x2\x312"+
		"\x310\x3\x2\x2\x2\x312\x313\x3\x2\x2\x2\x313\x33\x3\x2\x2\x2\x314\x315"+
		"\a\x1E\x2\x2\x315\x316\x5\x36\x1C\x2\x316\x35\x3\x2\x2\x2\x317\x31A\a"+
		"\x34\x2\x2\x318\x319\a\x35\x2\x2\x319\x31B\x5\x18E\xC8\x2\x31A\x318\x3"+
		"\x2\x2\x2\x31A\x31B\x3\x2\x2\x2\x31B\x320\x3\x2\x2\x2\x31C\x31D\a\x8F"+
		"\x2\x2\x31D\x31E\x5\xAEX\x2\x31E\x31F\a\x90\x2\x2\x31F\x321\x3\x2\x2\x2"+
		"\x320\x31C\x3\x2\x2\x2\x320\x321\x3\x2\x2\x2\x321\x322\x3\x2\x2\x2\x322"+
		"\x323\a\x1A\x2\x2\x323\x326\x5\xC0\x61\x2\x324\x325\a\xF\x2\x2\x325\x327"+
		"\x5\xBC_\x2\x326\x324\x3\x2\x2\x2\x326\x327\x3\x2\x2\x2\x327\x37\x3\x2"+
		"\x2\x2\x328\x329\a\x34\x2\x2\x329\x32B\x5\xACW\x2\x32A\x328\x3\x2\x2\x2"+
		"\x32A\x32B\x3\x2\x2\x2\x32B\x32C\x3\x2\x2\x2\x32C\x331\a\x1A\x2\x2\x32D"+
		"\x32F\a\v\x2\x2\x32E\x32D\x3\x2\x2\x2\x32E\x32F\x3\x2\x2\x2\x32F\x330"+
		"\x3\x2\x2\x2\x330\x332\aP\x2\x2\x331\x32E\x3\x2\x2\x2\x331\x332\x3\x2"+
		"\x2\x2\x332\x334\x3\x2\x2\x2\x333\x335\a,\x2\x2\x334\x333\x3\x2\x2\x2"+
		"\x334\x335\x3\x2\x2\x2\x335\x336\x3\x2\x2\x2\x336\x338\x5\xC0\x61\x2\x337"+
		"\x339\x5H%\x2\x338\x337\x3\x2\x2\x2\x338\x339\x3\x2\x2\x2\x339\x33C\x3"+
		"\x2\x2\x2\x33A\x33B\a\xF\x2\x2\x33B\x33D\x5\xBC_\x2\x33C\x33A\x3\x2\x2"+
		"\x2\x33C\x33D\x3\x2\x2\x2\x33D\x341\x3\x2\x2\x2\x33E\x33F\a*\x2\x2\x33F"+
		"\x340\a)\x2\x2\x340\x342\x5\xD6l\x2\x341\x33E\x3\x2\x2\x2\x341\x342\x3"+
		"\x2\x2\x2\x342\x345\x3\x2\x2\x2\x343\x344\a+\x2\x2\x344\x346\x5\xE6t\x2"+
		"\x345\x343\x3\x2\x2\x2\x345\x346\x3\x2\x2\x2\x346\x34A\x3\x2\x2\x2\x347"+
		"\x348\a\x37\x2\x2\x348\x349\a)\x2\x2\x349\x34B\x5\xE2r\x2\x34A\x347\x3"+
		"\x2\x2\x2\x34A\x34B\x3\x2\x2\x2\x34B\x34E\x3\x2\x2\x2\x34C\x34D\am\x2"+
		"\x2\x34D\x34F\x5\xEEx\x2\x34E\x34C\x3\x2\x2\x2\x34E\x34F\x3\x2\x2\x2\x34F"+
		"\x39\x3\x2\x2\x2\x350\x351\ao\x2\x2\x351\x355\a\xC1\x2\x2\x352\x353\a"+
		"\x10\x2\x2\x353\x356\a\xC1\x2\x2\x354\x356\a\xC1\x2\x2\x355\x352\x3\x2"+
		"\x2\x2\x355\x354\x3\x2\x2\x2\x355\x356\x3\x2\x2\x2\x356\x357\x3\x2\x2"+
		"\x2\x357\x358\aR\x2\x2\x358\x35B\x5\x44#\x2\x359\x35A\a\xF\x2\x2\x35A"+
		"\x35C\x5\xBC_\x2\x35B\x359\x3\x2\x2\x2\x35B\x35C\x3\x2\x2\x2\x35C;\x3"+
		"\x2\x2\x2\x35D\x35E\a\x34\x2\x2\x35E\x35F\x5\xACW\x2\x35F\x360\a\x1A\x2"+
		"\x2\x360\x363\x5\xC0\x61\x2\x361\x362\a\xF\x2\x2\x362\x364\x5\xBC_\x2"+
		"\x363\x361\x3\x2\x2\x2\x363\x364\x3\x2\x2\x2\x364=\x3\x2\x2\x2\x365\x368"+
		"\a\x30\x2\x2\x366\x369\a\x32\x2\x2\x367\x369\a-\x2\x2\x368\x366\x3\x2"+
		"\x2\x2\x368\x367\x3\x2\x2\x2\x369?\x3\x2\x2\x2\x36A\x36B\aP\x2\x2\x36B"+
		"\x36E\x5H%\x2\x36C\x36D\a\xF\x2\x2\x36D\x36F\x5\xBC_\x2\x36E\x36C\x3\x2"+
		"\x2\x2\x36E\x36F\x3\x2\x2\x2\x36F\x41\x3\x2\x2\x2\x370\x371\aR\x2\x2\x371"+
		"\x372\x5\x44#\x2\x372\x43\x3\x2\x2\x2\x373\x378\x5\x46$\x2\x374\x375\a"+
		"\x96\x2\x2\x375\x377\x5\x46$\x2\x376\x374\x3\x2\x2\x2\x377\x37A\x3\x2"+
		"\x2\x2\x378\x376\x3\x2\x2\x2\x378\x379\x3\x2\x2\x2\x379\x45\x3\x2\x2\x2"+
		"\x37A\x378\x3\x2\x2\x2\x37B\x37C\x5\x1B8\xDD\x2\x37C\x37D\a\x8C\x2\x2"+
		"\x37D\x37E\x5\x118\x8D\x2\x37E\x381\x3\x2\x2\x2\x37F\x381\x5\x118\x8D"+
		"\x2\x380\x37B\x3\x2\x2\x2\x380\x37F\x3\x2\x2\x2\x381G\x3\x2\x2\x2\x382"+
		"\x383\a \x2\x2\x383\x387\a\xC1\x2\x2\x384\x385\a\x10\x2\x2\x385\x388\a"+
		"\xC1\x2\x2\x386\x388\a\xC1\x2\x2\x387\x384\x3\x2\x2\x2\x387\x386\x3\x2"+
		"\x2\x2\x387\x388\x3\x2\x2\x2\x388I\x3\x2\x2\x2\x389\x38A\a\x3\x2\x2\x38A"+
		"\x38B\a\x4\x2\x2\x38B\x395\a\xC1\x2\x2\x38C\x38D\a\xB4\x2\x2\x38D\x392"+
		"\x5\xD4k\x2\x38E\x38F\a\xB4\x2\x2\x38F\x391\x5\xD4k\x2\x390\x38E\x3\x2"+
		"\x2\x2\x391\x394\x3\x2\x2\x2\x392\x390\x3\x2\x2\x2\x392\x393\x3\x2\x2"+
		"\x2\x393\x396\x3\x2\x2\x2\x394\x392\x3\x2\x2\x2\x395\x38C\x3\x2\x2\x2"+
		"\x395\x396\x3\x2\x2\x2\x396\x399\x3\x2\x2\x2\x397\x39A\a?\x2\x2\x398\x39A"+
		"\a@\x2\x2\x399\x397\x3\x2\x2\x2\x399\x398\x3\x2\x2\x2\x399\x39A\x3\x2"+
		"\x2\x2\x39A\x39C\x3\x2\x2\x2\x39B\x39D\a\x10\x2\x2\x39C\x39B\x3\x2\x2"+
		"\x2\x39C\x39D\x3\x2\x2\x2\x39D\x3A3\x3\x2\x2\x2\x39E\x3A4\x5L\'\x2\x39F"+
		"\x3A0\a\x8F\x2\x2\x3A0\x3A1\x5^\x30\x2\x3A1\x3A2\a\x90\x2\x2\x3A2\x3A4"+
		"\x3\x2\x2\x2\x3A3\x39E\x3\x2\x2\x2\x3A3\x39F\x3\x2\x2\x2\x3A4\x3AA\x3"+
		"\x2\x2\x2\x3A5\x3A8\a\x34\x2\x2\x3A6\x3A7\a\xF\x2\x2\x3A7\x3A9\x5\x118"+
		"\x8D\x2\x3A8\x3A6\x3\x2\x2\x2\x3A8\x3A9\x3\x2\x2\x2\x3A9\x3AB\x3\x2\x2"+
		"\x2\x3AA\x3A5\x3\x2\x2\x2\x3AA\x3AB\x3\x2\x2\x2\x3ABK\x3\x2\x2\x2\x3AC"+
		"\x3AD\a\x1A\x2\x2\x3AD\x3AE\x5\x62\x32\x2\x3AE\x3AF\a \x2\x2\x3AF\x3B1"+
		"\x3\x2\x2\x2\x3B0\x3AC\x3\x2\x2\x2\x3B0\x3B1\x3\x2\x2\x2\x3B1\x3B2\x3"+
		"\x2\x2\x2\x3B2\x3B3\x5\x18E\xC8\x2\x3B3M\x3\x2\x2\x2\x3B4\x3B6\a\x3\x2"+
		"\x2\x3B5\x3B7\a\xC1\x2\x2\x3B6\x3B5\x3\x2\x2\x2\x3B6\x3B7\x3\x2\x2\x2"+
		"\x3B7\x3B8\x3\x2\x2\x2\x3B8\x3B9\aW\x2\x2\x3B9\x3BA\a\xC1\x2\x2\x3BA\x3BB"+
		"\a\'\x2\x2\x3BB\x3BC\a\xC1\x2\x2\x3BC\x3BD\a\x8F\x2\x2\x3BD\x3BE\x5P)"+
		"\x2\x3BE\x3BF\a\x90\x2\x2\x3BFO\x3\x2\x2\x2\x3C0\x3C5\x5R*\x2\x3C1\x3C2"+
		"\a\x96\x2\x2\x3C2\x3C4\x5R*\x2\x3C3\x3C1\x3\x2\x2\x2\x3C4\x3C7\x3\x2\x2"+
		"\x2\x3C5\x3C3\x3\x2\x2\x2\x3C5\x3C6\x3\x2\x2\x2\x3C6Q\x3\x2\x2\x2\x3C7"+
		"\x3C5\x3\x2\x2\x2\x3C8\x3CA\a\xC1\x2\x2\x3C9\x3CB\a\xC1\x2\x2\x3CA\x3C9"+
		"\x3\x2\x2\x2\x3CA\x3CB\x3\x2\x2\x2\x3CBS\x3\x2\x2\x2\x3CC\x3CE\a\x3\x2"+
		"\x2\x3CD\x3CF\a\xC1\x2\x2\x3CE\x3CD\x3\x2\x2\x2\x3CE\x3CF\x3\x2\x2\x2"+
		"\x3CF\x3D0\x3\x2\x2\x2\x3D0\x3D1\aS\x2\x2\x3D1\x3D7\x5\x18E\xC8\x2\x3D2"+
		"\x3D4\a\x91\x2\x2\x3D3\x3D5\a\xC1\x2\x2\x3D4\x3D3\x3\x2\x2\x2\x3D4\x3D5"+
		"\x3\x2\x2\x2\x3D5\x3D6\x3\x2\x2\x2\x3D6\x3D8\a\x92\x2\x2\x3D7\x3D2\x3"+
		"\x2\x2\x2\x3D7\x3D8\x3\x2\x2\x2\x3D8\x3D9\x3\x2\x2\x2\x3D9\x3DC\a\xC1"+
		"\x2\x2\x3DA\x3DB\a\x8C\x2\x2\x3DB\x3DD\x5\x118\x8D\x2\x3DC\x3DA\x3\x2"+
		"\x2\x2\x3DC\x3DD\x3\x2\x2\x2\x3DDU\x3\x2\x2\x2\x3DE\x3DF\a\x3\x2\x2\x3DF"+
		"\x3E0\aT\x2\x2\x3E0\x3E2\a\xC1\x2\x2\x3E1\x3E3\a\x10\x2\x2\x3E2\x3E1\x3"+
		"\x2\x2\x2\x3E2\x3E3\x3\x2\x2\x2\x3E3\x3E4\x3\x2\x2\x2\x3E4\x3E5\a\x8F"+
		"\x2\x2\x3E5\x3E6\x5X-\x2\x3E6\x3E7\a\x90\x2\x2\x3E7W\x3\x2\x2\x2\x3E8"+
		"\x3ED\x5Z.\x2\x3E9\x3EA\a\x96\x2\x2\x3EA\x3EC\x5Z.\x2\x3EB\x3E9\x3\x2"+
		"\x2\x2\x3EC\x3EF\x3\x2\x2\x2\x3ED\x3EB\x3\x2\x2\x2\x3ED\x3EE\x3\x2\x2"+
		"\x2\x3EEY\x3\x2\x2\x2\x3EF\x3ED\x3\x2\x2\x2\x3F0\x3F4\a\xC1\x2\x2\x3F1"+
		"\x3F5\x5\\/\x2\x3F2\x3F5\x5\x144\xA3\x2\x3F3\x3F5\x5\x14A\xA6\x2\x3F4"+
		"\x3F1\x3\x2\x2\x2\x3F4\x3F2\x3\x2\x2\x2\x3F4\x3F3\x3\x2\x2\x2\x3F5\x3F7"+
		"\x3\x2\x2\x2\x3F6\x3F8\a\xC1\x2\x2\x3F7\x3F6\x3\x2\x2\x2\x3F7\x3F8\x3"+
		"\x2\x2\x2\x3F8\x3FA\x3\x2\x2\x2\x3F9\x3FB\a\xC1\x2\x2\x3FA\x3F9\x3\x2"+
		"\x2\x2\x3FA\x3FB\x3\x2\x2\x2\x3FB\x400\x3\x2\x2\x2\x3FC\x3FF\x5\x182\xC2"+
		"\x2\x3FD\x3FF\x5\x12\n\x2\x3FE\x3FC\x3\x2\x2\x2\x3FE\x3FD\x3\x2\x2\x2"+
		"\x3FF\x402\x3\x2\x2\x2\x400\x3FE\x3\x2\x2\x2\x400\x401\x3\x2\x2\x2\x401"+
		"[\x3\x2\x2\x2\x402\x400\x3\x2\x2\x2\x403\x409\x5\x18E\xC8\x2\x404\x406"+
		"\a\x91\x2\x2\x405\x407\a\xC1\x2\x2\x406\x405\x3\x2\x2\x2\x406\x407\x3"+
		"\x2\x2\x2\x407\x408\x3\x2\x2\x2\x408\x40A\a\x92\x2\x2\x409\x404\x3\x2"+
		"\x2\x2\x409\x40A\x3\x2\x2\x2\x40A]\x3\x2\x2\x2\x40B\x410\x5`\x31\x2\x40C"+
		"\x40D\a\x96\x2\x2\x40D\x40F\x5`\x31\x2\x40E\x40C\x3\x2\x2\x2\x40F\x412"+
		"\x3\x2\x2\x2\x410\x40E\x3\x2\x2\x2\x410\x411\x3\x2\x2\x2\x411_\x3\x2\x2"+
		"\x2\x412\x410\x3\x2\x2\x2\x413\x41D\x5\x18E\xC8\x2\x414\x41E\al\x2\x2"+
		"\x415\x41B\x5\x18E\xC8\x2\x416\x418\a\x91\x2\x2\x417\x419\a\xC1\x2\x2"+
		"\x418\x417\x3\x2\x2\x2\x418\x419\x3\x2\x2\x2\x419\x41A\x3\x2\x2\x2\x41A"+
		"\x41C\a\x92\x2\x2\x41B\x416\x3\x2\x2\x2\x41B\x41C\x3\x2\x2\x2\x41C\x41E"+
		"\x3\x2\x2\x2\x41D\x414\x3\x2\x2\x2\x41D\x415\x3\x2\x2\x2\x41E\x61\x3\x2"+
		"\x2\x2\x41F\x424\x5\x64\x33\x2\x420\x421\a\x96\x2\x2\x421\x423\x5\x64"+
		"\x33\x2\x422\x420\x3\x2\x2\x2\x423\x426\x3\x2\x2\x2\x424\x422\x3\x2\x2"+
		"\x2\x424\x425\x3\x2\x2\x2\x425\x63\x3\x2\x2\x2\x426\x424\x3\x2\x2\x2\x427"+
		"\x432\a\xA3\x2\x2\x428\x42B\x5\x1B8\xDD\x2\x429\x42A\a\x10\x2\x2\x42A"+
		"\x42C\a\xC1\x2\x2\x42B\x429\x3\x2\x2\x2\x42B\x42C\x3\x2\x2\x2\x42C\x432"+
		"\x3\x2\x2\x2\x42D\x42E\x5\x1DA\xEE\x2\x42E\x42F\a\x10\x2\x2\x42F\x430"+
		"\a\xC1\x2\x2\x430\x432\x3\x2\x2\x2\x431\x427\x3\x2\x2\x2\x431\x428\x3"+
		"\x2\x2\x2\x431\x42D\x3\x2\x2\x2\x432\x65\x3\x2\x2\x2\x433\x435\a\x3\x2"+
		"\x2\x434\x436\a\xC1\x2\x2\x435\x434\x3\x2\x2\x2\x435\x436\x3\x2\x2\x2"+
		"\x436\x437\x3\x2\x2\x2\x437\x438\x5h\x35\x2\x438g\x3\x2\x2\x2\x439\x43A"+
		"\a=\x2\x2\x43A\x43C\a\xC1\x2\x2\x43B\x43D\a\x10\x2\x2\x43C\x43B\x3\x2"+
		"\x2\x2\x43C\x43D\x3\x2\x2\x2\x43D\x444\x3\x2\x2\x2\x43E\x445\x5\xA6T\x2"+
		"\x43F\x441\a\x8F\x2\x2\x440\x442\x5^\x30\x2\x441\x440\x3\x2\x2\x2\x441"+
		"\x442\x3\x2\x2\x2\x442\x443\x3\x2\x2\x2\x443\x445\a\x90\x2\x2\x444\x43E"+
		"\x3\x2\x2\x2\x444\x43F\x3\x2\x2\x2\x445\x449\x3\x2\x2\x2\x446\x448\x5"+
		"\xA4S\x2\x447\x446\x3\x2\x2\x2\x448\x44B\x3\x2\x2\x2\x449\x447\x3\x2\x2"+
		"\x2\x449\x44A\x3\x2\x2\x2\x44Ai\x3\x2\x2\x2\x44B\x449\x3\x2\x2\x2\x44C"+
		"\x44D\aP\x2\x2\x44D\x44E\a \x2\x2\x44E\x452\x5\x18E\xC8\x2\x44F\x450\a"+
		"\x10\x2\x2\x450\x453\a\xC1\x2\x2\x451\x453\a\xC1\x2\x2\x452\x44F\x3\x2"+
		"\x2\x2\x452\x451\x3\x2\x2\x2\x452\x453\x3\x2\x2\x2\x453\x456\x3\x2\x2"+
		"\x2\x454\x455\a\xF\x2\x2\x455\x457\x5\xBC_\x2\x456\x454\x3\x2\x2\x2\x456"+
		"\x457\x3\x2\x2\x2\x457k\x3\x2\x2\x2\x458\x459\ao\x2\x2\x459\x45A\x5(\x15"+
		"\x2\x45Am\x3\x2\x2\x2\x45B\x45C\a\x34\x2\x2\x45C\x45D\x5\xACW\x2\x45D"+
		"\x45E\a\x36\x2\x2\x45E\x45F\a\x8F\x2\x2\x45F\x460\x5\x19E\xD0\x2\x460"+
		"\x461\a\x90\x2\x2\x461o\x3\x2\x2\x2\x462\x463\a\x3\x2\x2\x463\x464\a\x82"+
		"\x2\x2\x464\x466\a\xC1\x2\x2\x465\x467\a\x10\x2\x2\x466\x465\x3\x2\x2"+
		"\x2\x466\x467\x3\x2\x2\x2\x467\x468\x3\x2\x2\x2\x468\x469\x5r:\x2\x469"+
		"q\x3\x2\x2\x2\x46A\x46E\x5t;\x2\x46B\x46D\x5t;\x2\x46C\x46B\x3\x2\x2\x2"+
		"\x46D\x470\x3\x2\x2\x2\x46E\x46C\x3\x2\x2\x2\x46E\x46F\x3\x2\x2\x2\x46F"+
		"s\x3\x2\x2\x2\x470\x46E\x3\x2\x2\x2\x471\x473\x5\x12\n\x2\x472\x471\x3"+
		"\x2\x2\x2\x473\x476\x3\x2\x2\x2\x474\x472\x3\x2\x2\x2\x474\x475\x3\x2"+
		"\x2\x2\x475\x479\x3\x2\x2\x2\x476\x474\x3\x2\x2\x2\x477\x47A\a\xC1\x2"+
		"\x2\x478\x47A\a\x1A\x2\x2\x479\x477\x3\x2\x2\x2\x479\x478\x3\x2\x2\x2"+
		"\x47A\x47C\x3\x2\x2\x2\x47B\x47D\x5v<\x2\x47C\x47B\x3\x2\x2\x2\x47C\x47D"+
		"\x3\x2\x2\x2\x47D\x47F\x3\x2\x2\x2\x47E\x480\x5\x80\x41\x2\x47F\x47E\x3"+
		"\x2\x2\x2\x47F\x480\x3\x2\x2\x2\x480\x481\x3\x2\x2\x2\x481\x483\a\x93"+
		"\x2\x2\x482\x484\x5\x8A\x46\x2\x483\x482\x3\x2\x2\x2\x483\x484\x3\x2\x2"+
		"\x2\x484\x486\x3\x2\x2\x2\x485\x487\a\x96\x2\x2\x486\x485\x3\x2\x2\x2"+
		"\x486\x487\x3\x2\x2\x2\x487\x488\x3\x2\x2\x2\x488\x48D\a\x94\x2\x2\x489"+
		"\x48A\x5\x66\x34\x2\x48A\x48B\a\x96\x2\x2\x48B\x48D\x3\x2\x2\x2\x48C\x474"+
		"\x3\x2\x2\x2\x48C\x489\x3\x2\x2\x2\x48Du\x3\x2\x2\x2\x48E\x48F\a\x8F\x2"+
		"\x2\x48F\x490\x5x=\x2\x490\x491\a\x90\x2\x2\x491w\x3\x2\x2\x2\x492\x497"+
		"\x5z>\x2\x493\x494\a\x96\x2\x2\x494\x496\x5z>\x2\x495\x493\x3\x2\x2\x2"+
		"\x496\x499\x3\x2\x2\x2\x497\x495\x3\x2\x2\x2\x497\x498\x3\x2\x2\x2\x498"+
		"y\x3\x2\x2\x2\x499\x497\x3\x2\x2\x2\x49A\x49D\x5\x18E\xC8\x2\x49B\x49D"+
		"\x5|?\x2\x49C\x49A\x3\x2\x2\x2\x49C\x49B\x3\x2\x2\x2\x49D\x49F\x3\x2\x2"+
		"\x2\x49E\x4A0\x5~@\x2\x49F\x49E\x3\x2\x2\x2\x49F\x4A0\x3\x2\x2\x2\x4A0"+
		"{\x3\x2\x2\x2\x4A1\x4A2\a\x8F\x2\x2\x4A2\x4A3\x5\x18E\xC8\x2\x4A3\x4A4"+
		"\a\x96\x2\x2\x4A4\x4A5\x5\x18E\xC8\x2\x4A5\x4A6\x3\x2\x2\x2\x4A6\x4A7"+
		"\a\x90\x2\x2\x4A7}\x3\x2\x2\x2\x4A8\x4A9\a\x10\x2\x2\x4A9\x4AA\a\xC1\x2"+
		"\x2\x4AA\x7F\x3\x2\x2\x2\x4AB\x4AC\a\x8A\x2\x2\x4AC\x4B1\x5\x82\x42\x2"+
		"\x4AD\x4AE\a\x96\x2\x2\x4AE\x4B0\x5\x82\x42\x2\x4AF\x4AD\x3\x2\x2\x2\x4B0"+
		"\x4B3\x3\x2\x2\x2\x4B1\x4AF\x3\x2\x2\x2\x4B1\x4B2\x3\x2\x2\x2\x4B2\x81"+
		"\x3\x2\x2\x2\x4B3\x4B1\x3\x2\x2\x2\x4B4\x4B6\x5\x18E\xC8\x2\x4B5\x4B7"+
		"\x5\x84\x43\x2\x4B6\x4B5\x3\x2\x2\x2\x4B6\x4B7\x3\x2\x2\x2\x4B7\x83\x3"+
		"\x2\x2\x2\x4B8\x4B9\a\xAA\x2\x2\x4B9\x4BE\x5\x86\x44\x2\x4BA\x4BB\a\x96"+
		"\x2\x2\x4BB\x4BD\x5\x86\x44\x2\x4BC\x4BA\x3\x2\x2\x2\x4BD\x4C0\x3\x2\x2"+
		"\x2\x4BE\x4BC\x3\x2\x2\x2\x4BE\x4BF\x3\x2\x2\x2\x4BF\x4C1\x3\x2\x2\x2"+
		"\x4C0\x4BE\x3\x2\x2\x2\x4C1\x4C2\a\xA8\x2\x2\x4C2\x85\x3\x2\x2\x2\x4C3"+
		"\x4C6\x5\x88\x45\x2\x4C4\x4C6\a\x8E\x2\x2\x4C5\x4C3\x3\x2\x2\x2\x4C5\x4C4"+
		"\x3\x2\x2\x2\x4C6\x87\x3\x2\x2\x2\x4C7\x4C9\x5\x18E\xC8\x2\x4C8\x4CA\x5"+
		"\x84\x43\x2\x4C9\x4C8\x3\x2\x2\x2\x4C9\x4CA\x3\x2\x2\x2\x4CA\x89\x3\x2"+
		"\x2\x2\x4CB\x4D0\x5\x8CG\x2\x4CC\x4CD\a\x96\x2\x2\x4CD\x4CF\x5\x8CG\x2"+
		"\x4CE\x4CC\x3\x2\x2\x2\x4CF\x4D2\x3\x2\x2\x2\x4D0\x4CE\x3\x2\x2\x2\x4D0"+
		"\x4D1\x3\x2\x2\x2\x4D1\x8B\x3\x2\x2\x2\x4D2\x4D0\x3\x2\x2\x2\x4D3\x4D4"+
		"\a\x1A\x2\x2\x4D4\x4D5\t\x3\x2\x2\x4D5\x4D6\a\x8F\x2\x2\x4D6\x4D7\x5 "+
		"\x11\x2\x4D7\x4D8\a\x90\x2\x2\x4D8\x4E1\x3\x2\x2\x2\x4D9\x4DA\a\xC1\x2"+
		"\x2\x4DA\x4DE\t\x3\x2\x2\x4DB\x4DF\x5\x118\x8D\x2\x4DC\x4DF\x5\x1E2\xF2"+
		"\x2\x4DD\x4DF\x5\x1E4\xF3\x2\x4DE\x4DB\x3\x2\x2\x2\x4DE\x4DC\x3\x2\x2"+
		"\x2\x4DE\x4DD\x3\x2\x2\x2\x4DF\x4E1\x3\x2\x2\x2\x4E0\x4D3\x3\x2\x2\x2"+
		"\x4E0\x4D9\x3\x2\x2\x2\x4E1\x8D\x3\x2\x2\x2\x4E2\x4E3\a\x3\x2\x2\x4E3"+
		"\x4E4\a\x7F\x2\x2\x4E4\x4E6\a\xC1\x2\x2\x4E5\x4E7\a\x10\x2\x2\x4E6\x4E5"+
		"\x3\x2\x2\x2\x4E6\x4E7\x3\x2\x2\x2\x4E7\x4E8\x3\x2\x2\x2\x4E8\x4E9\x5"+
		"\x92J\x2\x4E9\x8F\x3\x2\x2\x2\x4EA\x4EB\a\x3\x2\x2\x4EB\x4EC\x5\n\x6\x2"+
		"\x4EC\x91\x3\x2\x2\x2\x4ED\x4F9\x5\x96L\x2\x4EE\x4EF\x5\x94K\x2\x4EF\x4F0"+
		"\a\x96\x2\x2\x4F0\x4F5\x5\x94K\x2\x4F1\x4F2\a\x96\x2\x2\x4F2\x4F4\x5\x94"+
		"K\x2\x4F3\x4F1\x3\x2\x2\x2\x4F4\x4F7\x3\x2\x2\x2\x4F5\x4F3\x3\x2\x2\x2"+
		"\x4F5\x4F6\x3\x2\x2\x2\x4F6\x4F9\x3\x2\x2\x2\x4F7\x4F5\x3\x2\x2\x2\x4F8"+
		"\x4ED\x3\x2\x2\x2\x4F8\x4EE\x3\x2\x2\x2\x4F9\x93\x3\x2\x2\x2\x4FA\x4FB"+
		"\a\x7F\x2\x2\x4FB\x4FD\a\xC1\x2\x2\x4FC\x4FE\a\x10\x2\x2\x4FD\x4FC\x3"+
		"\x2\x2\x2\x4FD\x4FE\x3\x2\x2\x2\x4FE\x4FF\x3\x2\x2\x2\x4FF\x500\x5\x96"+
		"L\x2\x500\x95\x3\x2\x2\x2\x501\x505\a~\x2\x2\x502\x503\a\xBA\x2\x2\x503"+
		"\x506\a\xC1\x2\x2\x504\x506\x5\x9AN\x2\x505\x502\x3\x2\x2\x2\x505\x504"+
		"\x3\x2\x2\x2\x506\x507\x3\x2\x2\x2\x507\x508\a\x1F\x2\x2\x508\x545\x5"+
		"\x9AN\x2\x509\x50B\a\x80\x2\x2\x50A\x50C\a)\x2\x2\x50B\x50A\x3\x2\x2\x2"+
		"\x50B\x50C\x3\x2\x2\x2\x50C\x50E\x3\x2\x2\x2\x50D\x50F\x5\x98M\x2\x50E"+
		"\x50D\x3\x2\x2\x2\x50E\x50F\x3\x2\x2\x2\x50F\x513\x3\x2\x2\x2\x510\x511"+
		"\a\xBA\x2\x2\x511\x512\a\xC1\x2\x2\x512\x514\a\v\x2\x2\x513\x510\x3\x2"+
		"\x2\x2\x513\x514\x3\x2\x2\x2\x514\x515\x3\x2\x2\x2\x515\x516\x5\x9AN\x2"+
		"\x516\x518\a\x81\x2\x2\x517\x519\a)\x2\x2\x518\x517\x3\x2\x2\x2\x518\x519"+
		"\x3\x2\x2\x2\x519\x51A\x3\x2\x2\x2\x51A\x51B\x5\x9AN\x2\x51B\x545\x3\x2"+
		"\x2\x2\x51C\x51E\at\x2\x2\x51D\x51F\a)\x2\x2\x51E\x51D\x3\x2\x2\x2\x51E"+
		"\x51F\x3\x2\x2\x2\x51F\x520\x3\x2\x2\x2\x520\x525\x5\x9EP\x2\x521\x522"+
		"\a\x96\x2\x2\x522\x524\x5\x9EP\x2\x523\x521\x3\x2\x2\x2\x524\x527\x3\x2"+
		"\x2\x2\x525\x523\x3\x2\x2\x2\x525\x526\x3\x2\x2\x2\x526\x545\x3\x2\x2"+
		"\x2\x527\x525\x3\x2\x2\x2\x528\x52D\x5\xA2R\x2\x529\x52A\a\x96\x2\x2\x52A"+
		"\x52C\x5\xA2R\x2\x52B\x529\x3\x2\x2\x2\x52C\x52F\x3\x2\x2\x2\x52D\x52B"+
		"\x3\x2\x2\x2\x52D\x52E\x3\x2\x2\x2\x52E\x530\x3\x2\x2\x2\x52F\x52D\x3"+
		"\x2\x2\x2\x530\x531\a \x2\x2\x531\x532\x5\x17A\xBE\x2\x532\x545\x3\x2"+
		"\x2\x2\x533\x535\a\x15\x2\x2\x534\x536\a)\x2\x2\x535\x534\x3\x2\x2\x2"+
		"\x535\x536\x3\x2\x2\x2\x536\x537\x3\x2\x2\x2\x537\x53C\x5\xA0Q\x2\x538"+
		"\x539\a\x96\x2\x2\x539\x53B\x5\xA0Q\x2\x53A\x538\x3\x2\x2\x2\x53B\x53E"+
		"\x3\x2\x2\x2\x53C\x53A\x3\x2\x2\x2\x53C\x53D\x3\x2\x2\x2\x53D\x53F\x3"+
		"\x2\x2\x2\x53E\x53C\x3\x2\x2\x2\x53F\x540\a\xC1\x2\x2\x540\x542\x5\x1D6"+
		"\xEC\x2\x541\x543\a\xC1\x2\x2\x542\x541\x3\x2\x2\x2\x542\x543\x3\x2\x2"+
		"\x2\x543\x545\x3\x2\x2\x2\x544\x501\x3\x2\x2\x2\x544\x509\x3\x2\x2\x2"+
		"\x544\x51C\x3\x2\x2\x2\x544\x528\x3\x2\x2\x2\x544\x533\x3\x2\x2\x2\x545"+
		"\x97\x3\x2\x2\x2\x546\x547\a,\x2\x2\x547\x549\a\x8F\x2\x2\x548\x54A\x5"+
		"\x19E\xD0\x2\x549\x548\x3\x2\x2\x2\x549\x54A\x3\x2\x2\x2\x54A\x54B\x3"+
		"\x2\x2\x2\x54B\x54C\a\x90\x2\x2\x54C\x99\x3\x2\x2\x2\x54D\x557\x5\x9C"+
		"O\x2\x54E\x551\x5\xCEh\x2\x54F\x550\a\xBA\x2\x2\x550\x552\a\xC1\x2\x2"+
		"\x551\x54F\x3\x2\x2\x2\x551\x552\x3\x2\x2\x2\x552\x557\x3\x2\x2\x2\x553"+
		"\x557\x5\xF0y\x2\x554\x555\av\x2\x2\x555\x557\x5\x1C4\xE3\x2\x556\x54D"+
		"\x3\x2\x2\x2\x556\x54E\x3\x2\x2\x2\x556\x553\x3\x2\x2\x2\x556\x554\x3"+
		"\x2\x2\x2\x557\x9B\x3\x2\x2\x2\x558\x55D\x5\x17A\xBE\x2\x559\x55B\a\x10"+
		"\x2\x2\x55A\x559\x3\x2\x2\x2\x55A\x55B\x3\x2\x2\x2\x55B\x55C\x3\x2\x2"+
		"\x2\x55C\x55E\a\xC1\x2\x2\x55D\x55A\x3\x2\x2\x2\x55D\x55E\x3\x2\x2\x2"+
		"\x55E\x9D\x3\x2\x2\x2\x55F\x564\x5\x1B8\xDD\x2\x560\x561\t\x4\x2\x2\x561"+
		"\x563\x5\x1B8\xDD\x2\x562\x560\x3\x2\x2\x2\x563\x566\x3\x2\x2\x2\x564"+
		"\x562\x3\x2\x2\x2\x564\x565\x3\x2\x2\x2\x565\x567\x3\x2\x2\x2\x566\x564"+
		"\x3\x2\x2\x2\x567\x568\a \x2\x2\x568\x569\x5\x17A\xBE\x2\x569\x9F\x3\x2"+
		"\x2\x2\x56A\x56B\x5\x14E\xA8\x2\x56B\x56C\a \x2\x2\x56C\x56D\x5\x17A\xBE"+
		"\x2\x56D\xA1\x3\x2\x2\x2\x56E\x570\a*\x2\x2\x56F\x571\a)\x2\x2\x570\x56F"+
		"\x3\x2\x2\x2\x570\x571\x3\x2\x2\x2\x571\x572\x3\x2\x2\x2\x572\x573\x5"+
		"\x118\x8D\x2\x573\x574\a\x10\x2\x2\x574\x575\a\xC1\x2\x2\x575\xA3\x3\x2"+
		"\x2\x2\x576\x577\a\xC1\x2\x2\x577\x578\x5\xAEX\x2\x578\xA5\x3\x2\x2\x2"+
		"\x579\x57E\x5\xA8U\x2\x57A\x57B\a\x96\x2\x2\x57B\x57D\x5\xA8U\x2\x57C"+
		"\x57A\x3\x2\x2\x2\x57D\x580\x3\x2\x2\x2\x57E\x57C\x3\x2\x2\x2\x57E\x57F"+
		"\x3\x2\x2\x2\x57F\xA7\x3\x2\x2\x2\x580\x57E\x3\x2\x2\x2\x581\x584\a\xA3"+
		"\x2\x2\x582\x584\x5\x18E\xC8\x2\x583\x581\x3\x2\x2\x2\x583\x582\x3\x2"+
		"\x2\x2\x584\xA9\x3\x2\x2\x2\x585\x586\aT\x2\x2\x586\x587\a\xC1\x2\x2\x587"+
		"\xAB\x3\x2\x2\x2\x588\x58C\a;\x2\x2\x589\x58C\a:\x2\x2\x58A\x58C\a<\x2"+
		"\x2\x58B\x588\x3\x2\x2\x2\x58B\x589\x3\x2\x2\x2\x58B\x58A\x3\x2\x2\x2"+
		"\x58B\x58C\x3\x2\x2\x2\x58C\x58D\x3\x2\x2\x2\x58D\x58E\a\x35\x2\x2\x58E"+
		"\x594\x5\x18E\xC8\x2\x58F\x591\a\x8F\x2\x2\x590\x592\x5\xAEX\x2\x591\x590"+
		"\x3\x2\x2\x2\x591\x592\x3\x2\x2\x2\x592\x593\x3\x2\x2\x2\x593\x595\a\x90"+
		"\x2\x2\x594\x58F\x3\x2\x2\x2\x594\x595\x3\x2\x2\x2\x595\xAD\x3\x2\x2\x2"+
		"\x596\x59B\a\xC1\x2\x2\x597\x598\a\x96\x2\x2\x598\x59A\a\xC1\x2\x2\x599"+
		"\x597\x3\x2\x2\x2\x59A\x59D\x3\x2\x2\x2\x59B\x599\x3\x2\x2\x2\x59B\x59C"+
		"\x3\x2\x2\x2\x59C\xAF\x3\x2\x2\x2\x59D\x59B\x3\x2\x2\x2\x59E\x5A1\x5\xCA"+
		"\x66\x2\x59F\x5A2\x5\xB2Z\x2\x5A0\x5A2\x5\xB4[\x2\x5A1\x59F\x3\x2\x2\x2"+
		"\x5A1\x5A0\x3\x2\x2\x2\x5A2\xB1\x3\x2\x2\x2\x5A3\x5A4\a\x96\x2\x2\x5A4"+
		"\x5A6\x5\xCA\x66\x2\x5A5\x5A3\x3\x2\x2\x2\x5A6\x5A9\x3\x2\x2\x2\x5A7\x5A5"+
		"\x3\x2\x2\x2\x5A7\x5A8\x3\x2\x2\x2\x5A8\xB3\x3\x2\x2\x2\x5A9\x5A7\x3\x2"+
		"\x2\x2\x5AA\x5AE\x5\xB6\\\x2\x5AB\x5AD\x5\xB6\\\x2\x5AC\x5AB\x3\x2\x2"+
		"\x2\x5AD\x5B0\x3\x2\x2\x2\x5AE\x5AC\x3\x2\x2\x2\x5AE\x5AF\x3\x2\x2\x2"+
		"\x5AF\xB5\x3\x2\x2\x2\x5B0\x5AE\x3\x2\x2\x2\x5B1\x5B5\a$\x2\x2\x5B2\x5B5"+
		"\a%\x2\x2\x5B3\x5B5\a&\x2\x2\x5B4\x5B1\x3\x2\x2\x2\x5B4\x5B2\x3\x2\x2"+
		"\x2\x5B4\x5B3\x3\x2\x2\x2\x5B5\x5B6\x3\x2\x2\x2\x5B6\x5B8\a!\x2\x2\x5B7"+
		"\x5B4\x3\x2\x2\x2\x5B7\x5B8\x3\x2\x2\x2\x5B8\x5BB\x3\x2\x2\x2\x5B9\x5BB"+
		"\a\"\x2\x2\x5BA\x5B7\x3\x2\x2\x2\x5BA\x5B9\x3\x2\x2\x2\x5BB\x5BC\x3\x2"+
		"\x2\x2\x5BC\x5BD\a#\x2\x2\x5BD\x5BF\x5\xCA\x66\x2\x5BE\x5C0\x5\xB8]\x2"+
		"\x5BF\x5BE\x3\x2\x2\x2\x5BF\x5C0\x3\x2\x2\x2\x5C0\xB7\x3\x2\x2\x2\x5C1"+
		"\x5C2\a\'\x2\x2\x5C2\x5C7\x5\xBA^\x2\x5C3\x5C4\a\v\x2\x2\x5C4\x5C6\x5"+
		"\xBA^\x2\x5C5\x5C3\x3\x2\x2\x2\x5C6\x5C9\x3\x2\x2\x2\x5C7\x5C5\x3\x2\x2"+
		"\x2\x5C7\x5C8\x3\x2\x2\x2\x5C8\xB9\x3\x2\x2\x2\x5C9\x5C7\x3\x2\x2\x2\x5CA"+
		"\x5CB\x5\x1B8\xDD\x2\x5CB\x5CC\a\x8C\x2\x2\x5CC\x5CD\x5\x1B8\xDD\x2\x5CD"+
		"\xBB\x3\x2\x2\x2\x5CE\x5CF\x5\x11C\x8F\x2\x5CF\xBD\x3\x2\x2\x2\x5D0\x5D4"+
		"\a:\x2\x2\x5D1\x5D4\a;\x2\x2\x5D2\x5D4\a<\x2\x2\x5D3\x5D0\x3\x2\x2\x2"+
		"\x5D3\x5D1\x3\x2\x2\x2\x5D3\x5D2\x3\x2\x2\x2\x5D3\x5D4\x3\x2\x2\x2\x5D4"+
		"\x5D6\x3\x2\x2\x2\x5D5\x5D7\a,\x2\x2\x5D6\x5D5\x3\x2\x2\x2\x5D6\x5D7\x3"+
		"\x2\x2\x2\x5D7\x5D8\x3\x2\x2\x2\x5D8\x5D9\x5\xC0\x61\x2\x5D9\xBF\x3\x2"+
		"\x2\x2\x5DA\x5DF\x5\xC2\x62\x2\x5DB\x5DC\a\x96\x2\x2\x5DC\x5DE\x5\xC2"+
		"\x62\x2\x5DD\x5DB\x3\x2\x2\x2\x5DE\x5E1\x3\x2\x2\x2\x5DF\x5DD\x3\x2\x2"+
		"\x2\x5DF\x5E0\x3\x2\x2\x2\x5E0\xC1\x3\x2\x2\x2\x5E1\x5DF\x3\x2\x2\x2\x5E2"+
		"\x5E6\a\xA3\x2\x2\x5E3\x5E6\x5\xC8\x65\x2\x5E4\x5E6\x5\xC4\x63\x2\x5E5"+
		"\x5E2\x3\x2\x2\x2\x5E5\x5E3\x3\x2\x2\x2\x5E5\x5E4\x3\x2\x2\x2\x5E6\xC3"+
		"\x3\x2\x2\x2\x5E7\x5E9\x5\x118\x8D\x2\x5E8\x5EA\x5\xC6\x64\x2\x5E9\x5E8"+
		"\x3\x2\x2\x2\x5E9\x5EA\x3\x2\x2\x2\x5EA\x5EF\x3\x2\x2\x2\x5EB\x5ED\a\x10"+
		"\x2\x2\x5EC\x5EB\x3\x2\x2\x2\x5EC\x5ED\x3\x2\x2\x2\x5ED\x5EE\x3\x2\x2"+
		"\x2\x5EE\x5F0\x5\x1BE\xE0\x2\x5EF\x5EC\x3\x2\x2\x2\x5EF\x5F0\x3\x2\x2"+
		"\x2\x5F0\xC5\x3\x2\x2\x2\x5F1\x5F2\a\xBA\x2\x2\x5F2\x5F3\a\xC1\x2\x2\x5F3"+
		"\xC7\x3\x2\x2\x2\x5F4\x5F5\a\xC1\x2\x2\x5F5\x5F6\a\xB4\x2\x2\x5F6\x5F9"+
		"\a\xA3\x2\x2\x5F7\x5F8\a\x10\x2\x2\x5F8\x5FA\a\xC1\x2\x2\x5F9\x5F7\x3"+
		"\x2\x2\x2\x5F9\x5FA\x3\x2\x2\x2\x5FA\xC9\x3\x2\x2\x2\x5FB\x600\x5\x17A"+
		"\xBE\x2\x5FC\x600\x5\xCEh\x2\x5FD\x600\x5\xD0i\x2\x5FE\x600\x5\xD2j\x2"+
		"\x5FF\x5FB\x3\x2\x2\x2\x5FF\x5FC\x3\x2\x2\x2\x5FF\x5FD\x3\x2\x2\x2\x5FF"+
		"\x5FE\x3\x2\x2\x2\x600\x60A\x3\x2\x2\x2\x601\x602\a\xB4\x2\x2\x602\x607"+
		"\x5\xD4k\x2\x603\x604\a\xB4\x2\x2\x604\x606\x5\xD4k\x2\x605\x603\x3\x2"+
		"\x2\x2\x606\x609\x3\x2\x2\x2\x607\x605\x3\x2\x2\x2\x607\x608\x3\x2\x2"+
		"\x2\x608\x60B\x3\x2\x2\x2\x609\x607\x3\x2\x2\x2\x60A\x601\x3\x2\x2\x2"+
		"\x60A\x60B\x3\x2\x2\x2\x60B\x60F\x3\x2\x2\x2\x60C\x60D\a\x10\x2\x2\x60D"+
		"\x610\a\xC1\x2\x2\x60E\x610\a\xC1\x2\x2\x60F\x60C\x3\x2\x2\x2\x60F\x60E"+
		"\x3\x2\x2\x2\x60F\x610\x3\x2\x2\x2\x610\x612\x3\x2\x2\x2\x611\x613\a>"+
		"\x2\x2\x612\x611\x3\x2\x2\x2\x612\x613\x3\x2\x2\x2\x613\x616\x3\x2\x2"+
		"\x2\x614\x617\a?\x2\x2\x615\x617\a@\x2\x2\x616\x614\x3\x2\x2\x2\x616\x615"+
		"\x3\x2\x2\x2\x616\x617\x3\x2\x2\x2\x617\xCB\x3\x2\x2\x2\x618\x619\aw\x2"+
		"\x2\x619\x61F\a\xC1\x2\x2\x61A\x61C\a\x8F\x2\x2\x61B\x61D\x5\x19E\xD0"+
		"\x2\x61C\x61B\x3\x2\x2\x2\x61C\x61D\x3\x2\x2\x2\x61D\x61E\x3\x2\x2\x2"+
		"\x61E\x620\a\x90\x2\x2\x61F\x61A\x3\x2\x2\x2\x61F\x620\x3\x2\x2\x2\x620"+
		"\xCD\x3\x2\x2\x2\x621\x625\a\x41\x2\x2\x622\x624\x5\x12\n\x2\x623\x622"+
		"\x3\x2\x2\x2\x624\x627\x3\x2\x2\x2\x625\x623\x3\x2\x2\x2\x625\x626\x3"+
		"\x2\x2\x2\x626\x628\x3\x2\x2\x2\x627\x625\x3\x2\x2\x2\x628\x629\a\x91"+
		"\x2\x2\x629\x62A\x5\x15C\xAF\x2\x62A\x62B\a\x92\x2\x2\x62B\xCF\x3\x2\x2"+
		"\x2\x62C\x62D\a\x42\x2\x2\x62D\x62E\a\x95\x2\x2\x62E\x62F\a\xC1\x2\x2"+
		"\x62F\x632\a\x91\x2\x2\x630\x633\a\xC0\x2\x2\x631\x633\a\xBF\x2\x2\x632"+
		"\x630\x3\x2\x2\x2\x632\x631\x3\x2\x2\x2\x633\x639\x3\x2\x2\x2\x634\x637"+
		"\a\x43\x2\x2\x635\x638\a\xC0\x2\x2\x636\x638\a\xBF\x2\x2\x637\x635\x3"+
		"\x2\x2\x2\x637\x636\x3\x2\x2\x2\x638\x63A\x3\x2\x2\x2\x639\x634\x3\x2"+
		"\x2\x2\x639\x63A\x3\x2\x2\x2\x63A\x63B\x3\x2\x2\x2\x63B\x63C\a\x92\x2"+
		"\x2\x63C\xD1\x3\x2\x2\x2\x63D\x63E\a\xC1\x2\x2\x63E\x63F\a\x95\x2\x2\x63F"+
		"\x645\x5\x18E\xC8\x2\x640\x642\a\x8F\x2\x2\x641\x643\x5\x19E\xD0\x2\x642"+
		"\x641\x3\x2\x2\x2\x642\x643\x3\x2\x2\x2\x643\x644\x3\x2\x2\x2\x644\x646"+
		"\a\x90\x2\x2\x645\x640\x3\x2\x2\x2\x645\x646\x3\x2\x2\x2\x646\xD3\x3\x2"+
		"\x2\x2\x647\x648\a\xC1\x2\x2\x648\x64B\a\x95\x2\x2\x649\x64C\a\xC1\x2"+
		"\x2\x64A\x64C\az\x2\x2\x64B\x649\x3\x2\x2\x2\x64B\x64A\x3\x2\x2\x2\x64C"+
		"\x64D\x3\x2\x2\x2\x64D\x64F\a\x8F\x2\x2\x64E\x650\x5\x1A0\xD1\x2\x64F"+
		"\x64E\x3\x2\x2\x2\x64F\x650\x3\x2\x2\x2\x650\x651\x3\x2\x2\x2\x651\x652"+
		"\a\x90\x2\x2\x652\xD5\x3\x2\x2\x2\x653\x658\x5\xD8m\x2\x654\x655\a\x96"+
		"\x2\x2\x655\x657\x5\xD8m\x2\x656\x654\x3\x2\x2\x2\x657\x65A\x3\x2\x2\x2"+
		"\x658\x656\x3\x2\x2\x2\x658\x659\x3\x2\x2\x2\x659\xD7\x3\x2\x2\x2\x65A"+
		"\x658\x3\x2\x2\x2\x65B\x65F\x5\x118\x8D\x2\x65C\x65F\x5\xDAn\x2\x65D\x65F"+
		"\x5\xDCo\x2\x65E\x65B\x3\x2\x2\x2\x65E\x65C\x3\x2\x2\x2\x65E\x65D\x3\x2"+
		"\x2\x2\x65F\xD9\x3\x2\x2\x2\x660\x661\t\x5\x2\x2\x661\x662\a\x8F\x2\x2"+
		"\x662\x667\x5\xE0q\x2\x663\x664\a\x96\x2\x2\x664\x666\x5\xE0q\x2\x665"+
		"\x663\x3\x2\x2\x2\x666\x669\x3\x2\x2\x2\x667\x665\x3\x2\x2\x2\x667\x668"+
		"\x3\x2\x2\x2\x668\x66A\x3\x2\x2\x2\x669\x667\x3\x2\x2\x2\x66A\x66B\a\x90"+
		"\x2\x2\x66B\xDB\x3\x2\x2\x2\x66C\x66D\a\x85\x2\x2\x66D\x66E\a\x87\x2\x2"+
		"\x66E\x66F\a\x8F\x2\x2\x66F\x674\x5\xDEp\x2\x670\x671\a\x96\x2\x2\x671"+
		"\x673\x5\xDEp\x2\x672\x670\x3\x2\x2\x2\x673\x676\x3\x2\x2\x2\x674\x672"+
		"\x3\x2\x2\x2\x674\x675\x3\x2\x2\x2\x675\x677\x3\x2\x2\x2\x676\x674\x3"+
		"\x2\x2\x2\x677\x678\a\x90\x2\x2\x678\xDD\x3\x2\x2\x2\x679\x67C\x5\xDA"+
		"n\x2\x67A\x67C\x5\xE0q\x2\x67B\x679\x3\x2\x2\x2\x67B\x67A\x3\x2\x2\x2"+
		"\x67C\xDF\x3\x2\x2\x2\x67D\x68B\x5\x118\x8D\x2\x67E\x687\a\x8F\x2\x2\x67F"+
		"\x684\x5\x118\x8D\x2\x680\x681\a\x96\x2\x2\x681\x683\x5\x118\x8D\x2\x682"+
		"\x680\x3\x2\x2\x2\x683\x686\x3\x2\x2\x2\x684\x682\x3\x2\x2\x2\x684\x685"+
		"\x3\x2\x2\x2\x685\x688\x3\x2\x2\x2\x686\x684\x3\x2\x2\x2\x687\x67F\x3"+
		"\x2\x2\x2\x687\x688\x3\x2\x2\x2\x688\x689\x3\x2\x2\x2\x689\x68B\a\x90"+
		"\x2\x2\x68A\x67D\x3\x2\x2\x2\x68A\x67E\x3\x2\x2\x2\x68B\xE1\x3\x2\x2\x2"+
		"\x68C\x691\x5\xE4s\x2\x68D\x68E\a\x96\x2\x2\x68E\x690\x5\xE4s\x2\x68F"+
		"\x68D\x3\x2\x2\x2\x690\x693\x3\x2\x2\x2\x691\x68F\x3\x2\x2\x2\x691\x692"+
		"\x3\x2\x2\x2\x692\xE3\x3\x2\x2\x2\x693\x691\x3\x2\x2\x2\x694\x697\x5\x118"+
		"\x8D\x2\x695\x698\a\x38\x2\x2\x696\x698\a\x39\x2\x2\x697\x695\x3\x2\x2"+
		"\x2\x697\x696\x3\x2\x2\x2\x697\x698\x3\x2\x2\x2\x698\xE5\x3\x2\x2\x2\x699"+
		"\x69A\x5\x11C\x8F\x2\x69A\xE7\x3\x2\x2\x2\x69B\x69D\x5\xECw\x2\x69C\x69B"+
		"\x3\x2\x2\x2\x69C\x69D\x3\x2\x2\x2\x69D\x6A2\x3\x2\x2\x2\x69E\x6A3\a-"+
		"\x2\x2\x69F\x6A3\a\x32\x2\x2\x6A0\x6A3\a\x33\x2\x2\x6A1\x6A3\aQ\x2\x2"+
		"\x6A2\x69E\x3\x2\x2\x2\x6A2\x69F\x3\x2\x2\x2\x6A2\x6A0\x3\x2\x2\x2\x6A2"+
		"\x6A1\x3\x2\x2\x2\x6A2\x6A3\x3\x2\x2\x2\x6A3\x6C0\x3\x2\x2\x2\x6A4\x6AB"+
		"\a\r\x2\x2\x6A5\x6AC\x5\x1C4\xE3\x2\x6A6\x6A9\x5\x1D6\xEC\x2\x6A7\x6A9"+
		"\a\xC1\x2\x2\x6A8\x6A6\x3\x2\x2\x2\x6A8\x6A7\x3\x2\x2\x2\x6A9\x6AA\x3"+
		"\x2\x2\x2\x6AA\x6AC\a\x31\x2\x2\x6AB\x6A5\x3\x2\x2\x2\x6AB\x6A8\x3\x2"+
		"\x2\x2\x6AC\x6C1\x3\x2\x2\x2\x6AD\x6AE\aV\x2\x2\x6AE\x6C1\x5\xF0y\x2\x6AF"+
		"\x6B0\a\x1D\x2\x2\x6B0\x6B3\x5\x118\x8D\x2\x6B1\x6B2\a\x1E\x2\x2\x6B2"+
		"\x6B4\x5\x42\"\x2\x6B3\x6B1\x3\x2\x2\x2\x6B3\x6B4\x3\x2\x2\x2\x6B4\x6C1"+
		"\x3\x2\x2\x2\x6B5\x6B6\a\x1D\x2\x2\x6B6\x6B9\a\x81\x2\x2\x6B7\x6B8\a\v"+
		"\x2\x2\x6B8\x6BA\x5\x118\x8D\x2\x6B9\x6B7\x3\x2\x2\x2\x6B9\x6BA\x3\x2"+
		"\x2\x2\x6BA\x6BD\x3\x2\x2\x2\x6BB\x6BC\a\x1E\x2\x2\x6BC\x6BE\x5\x42\""+
		"\x2\x6BD\x6BB\x3\x2\x2\x2\x6BD\x6BE\x3\x2\x2\x2\x6BE\x6C1\x3\x2\x2\x2"+
		"\x6BF\x6C1\x3\x2\x2\x2\x6C0\x6A4\x3\x2\x2\x2\x6C0\x6AD\x3\x2\x2\x2\x6C0"+
		"\x6AF\x3\x2\x2\x2\x6C0\x6B5\x3\x2\x2\x2\x6C0\x6BF\x3\x2\x2\x2\x6C1\x6C3"+
		"\x3\x2\x2\x2\x6C2\x6C4\x5\xEAv\x2\x6C3\x6C2\x3\x2\x2\x2\x6C3\x6C4\x3\x2"+
		"\x2\x2\x6C4\xE9\x3\x2\x2\x2\x6C5\x6C6\a\v\x2\x2\x6C6\x6C7\a\x1D\x2\x2"+
		"\x6C7\x6CA\a\x81\x2\x2\x6C8\x6C9\a\v\x2\x2\x6C9\x6CB\x5\x118\x8D\x2\x6CA"+
		"\x6C8\x3\x2\x2\x2\x6CA\x6CB\x3\x2\x2\x2\x6CB\x6CE\x3\x2\x2\x2\x6CC\x6CD"+
		"\a\x1E\x2\x2\x6CD\x6CF\x5\x42\"\x2\x6CE\x6CC\x3\x2\x2\x2\x6CE\x6CF\x3"+
		"\x2\x2\x2\x6CF\xEB\x3\x2\x2\x2\x6D0\x6D5\av\x2\x2\x6D1\x6D6\x5\x1C4\xE3"+
		"\x2\x6D2\x6D3\x5\x1D6\xEC\x2\x6D3\x6D4\a\x31\x2\x2\x6D4\x6D6\x3\x2\x2"+
		"\x2\x6D5\x6D1\x3\x2\x2\x2\x6D5\x6D2\x3\x2\x2\x2\x6D6\xED\x3\x2\x2\x2\x6D7"+
		"\x6DA\x5\x1DC\xEF\x2\x6D8\x6DA\a\xC1\x2\x2\x6D9\x6D7\x3\x2\x2\x2\x6D9"+
		"\x6D8\x3\x2\x2\x2\x6DA\x6E3\x3\x2\x2\x2\x6DB\x6DE\a\x96\x2\x2\x6DC\x6DE"+
		"\an\x2\x2\x6DD\x6DB\x3\x2\x2\x2\x6DD\x6DC\x3\x2\x2\x2\x6DE\x6E1\x3\x2"+
		"\x2\x2\x6DF\x6E2\x5\x1DC\xEF\x2\x6E0\x6E2\a\xC1\x2\x2\x6E1\x6DF\x3\x2"+
		"\x2\x2\x6E1\x6E0\x3\x2\x2\x2\x6E2\x6E4\x3\x2\x2\x2\x6E3\x6DD\x3\x2\x2"+
		"\x2\x6E3\x6E4\x3\x2\x2\x2\x6E4\xEF\x3\x2\x2\x2\x6E5\x6E6\a\x8F\x2\x2\x6E6"+
		"\x6E7\x5\x1A0\xD1\x2\x6E7\x6E8\a\x90\x2\x2\x6E8\xF1\x3\x2\x2\x2\x6E9\x6EA"+
		"\a\x1D\x2\x2\x6EA\x6EB\x5\x118\x8D\x2\x6EB\x6EC\a\x1E\x2\x2\x6EC\x6ED"+
		"\x5\x118\x8D\x2\x6ED\xF3\x3\x2\x2\x2\x6EE\x6EF\a\x1C\x2\x2\x6EF\x6F0\x5"+
		"\x118\x8D\x2\x6F0\xF5\x3\x2\x2\x2\x6F1\x6F2\ap\x2\x2\x6F2\x6F4\a\x8F\x2"+
		"\x2\x6F3\x6F5\x5\xF8}\x2\x6F4\x6F3\x3\x2\x2\x2\x6F4\x6F5\x3\x2\x2\x2\x6F5"+
		"\x6F6\x3\x2\x2\x2\x6F6\x6F8\x5\xFA~\x2\x6F7\x6F9\x5\xFE\x80\x2\x6F8\x6F7"+
		"\x3\x2\x2\x2\x6F8\x6F9\x3\x2\x2\x2\x6F9\x6FB\x3\x2\x2\x2\x6FA\x6FC\x5"+
		"\x102\x82\x2\x6FB\x6FA\x3\x2\x2\x2\x6FB\x6FC\x3\x2\x2\x2\x6FC\x6FD\x3"+
		"\x2\x2\x2\x6FD\x6FF\x5\x100\x81\x2\x6FE\x700\x5\x104\x83\x2\x6FF\x6FE"+
		"\x3\x2\x2\x2\x6FF\x700\x3\x2\x2\x2\x700\x702\x3\x2\x2\x2\x701\x703\x5"+
		"\x114\x8B\x2\x702\x701\x3\x2\x2\x2\x702\x703\x3\x2\x2\x2\x703\x704\x3"+
		"\x2\x2\x2\x704\x705\a\x90\x2\x2\x705\xF7\x3\x2\x2\x2\x706\x707\at\x2\x2"+
		"\x707\x708\a)\x2\x2\x708\x70D\x5\x118\x8D\x2\x709\x70A\a\x96\x2\x2\x70A"+
		"\x70C\x5\x118\x8D\x2\x70B\x709\x3\x2\x2\x2\x70C\x70F\x3\x2\x2\x2\x70D"+
		"\x70B\x3\x2\x2\x2\x70D\x70E\x3\x2\x2\x2\x70E\xF9\x3\x2\x2\x2\x70F\x70D"+
		"\x3\x2\x2\x2\x710\x711\ar\x2\x2\x711\x716\x5\xFC\x7F\x2\x712\x713\a\x96"+
		"\x2\x2\x713\x715\x5\xFC\x7F\x2\x714\x712\x3\x2\x2\x2\x715\x718\x3\x2\x2"+
		"\x2\x716\x714\x3\x2\x2\x2\x716\x717\x3\x2\x2\x2\x717\xFB\x3\x2\x2\x2\x718"+
		"\x716\x3\x2\x2\x2\x719\x71E\x5\x118\x8D\x2\x71A\x71C\a\x10\x2\x2\x71B"+
		"\x71D\a\xC1\x2\x2\x71C\x71B\x3\x2\x2\x2\x71C\x71D\x3\x2\x2\x2\x71D\x71F"+
		"\x3\x2\x2\x2\x71E\x71A\x3\x2\x2\x2\x71E\x71F\x3\x2\x2\x2\x71F\xFD\x3\x2"+
		"\x2\x2\x720\x721\a-\x2\x2\x721\x722\au\x2\x2\x722\xFF\x3\x2\x2\x2\x723"+
		"\x724\a\x41\x2\x2\x724\x725\a\x8F\x2\x2\x725\x726\x5\x106\x84\x2\x726"+
		"\x727\a\x90\x2\x2\x727\x101\x3\x2\x2\x2\x728\x729\av\x2\x2\x729\x72A\x5"+
		"\x1BE\xE0\x2\x72A\x72B\x5\x1BE\xE0\x2\x72B\x72C\x5\x1BE\xE0\x2\x72C\x72D"+
		"\x5\x1BE\xE0\x2\x72D\x72E\x5\x1BE\xE0\x2\x72E\x103\x3\x2\x2\x2\x72F\x730"+
		"\a\xC1\x2\x2\x730\x733\x5\x1C4\xE3\x2\x731\x732\a\n\x2\x2\x732\x734\a"+
		"\x81\x2\x2\x733\x731\x3\x2\x2\x2\x733\x734\x3\x2\x2\x2\x734\x105\x3\x2"+
		"\x2\x2\x735\x73A\x5\x108\x85\x2\x736\x737\a\xAD\x2\x2\x737\x739\x5\x108"+
		"\x85\x2\x738\x736\x3\x2\x2\x2\x739\x73C\x3\x2\x2\x2\x73A\x738\x3\x2\x2"+
		"\x2\x73A\x73B\x3\x2\x2\x2\x73B\x107\x3\x2\x2\x2\x73C\x73A\x3\x2\x2\x2"+
		"\x73D\x73F\x5\x10A\x86\x2\x73E\x73D\x3\x2\x2\x2\x73F\x740\x3\x2\x2\x2"+
		"\x740\x73E\x3\x2\x2\x2\x740\x741\x3\x2\x2\x2\x741\x109\x3\x2\x2\x2\x742"+
		"\x746\x5\x10E\x88\x2\x743\x746\x5\x10C\x87\x2\x744\x746\x5\x110\x89\x2"+
		"\x745\x742\x3\x2\x2\x2\x745\x743\x3\x2\x2\x2\x745\x744\x3\x2\x2\x2\x746"+
		"\x10B\x3\x2\x2\x2\x747\x748\a\x8F\x2\x2\x748\x749\x5\x106\x84\x2\x749"+
		"\x74D\a\x90\x2\x2\x74A\x74E\a\xA3\x2\x2\x74B\x74E\a\x9D\x2\x2\x74C\x74E"+
		"\a\x8E\x2\x2\x74D\x74A\x3\x2\x2\x2\x74D\x74B\x3\x2\x2\x2\x74D\x74C\x3"+
		"\x2\x2\x2\x74D\x74E\x3\x2\x2\x2\x74E\x750\x3\x2\x2\x2\x74F\x751\x5\x112"+
		"\x8A\x2\x750\x74F\x3\x2\x2\x2\x750\x751\x3\x2\x2\x2\x751\x10D\x3\x2\x2"+
		"\x2\x752\x753\aq\x2\x2\x753\x754\a\x8F\x2\x2\x754\x759\x5\x106\x84\x2"+
		"\x755\x756\a\x96\x2\x2\x756\x758\x5\x106\x84\x2\x757\x755\x3\x2\x2\x2"+
		"\x758\x75B\x3\x2\x2\x2\x759\x757\x3\x2\x2\x2\x759\x75A\x3\x2\x2\x2\x75A"+
		"\x75C\x3\x2\x2\x2\x75B\x759\x3\x2\x2\x2\x75C\x75D\a\x90\x2\x2\x75D\x10F"+
		"\x3\x2\x2\x2\x75E\x767\a\xC1\x2\x2\x75F\x763\a\xA3\x2\x2\x760\x763\a\x9D"+
		"\x2\x2\x761\x763\a\x8E\x2\x2\x762\x75F\x3\x2\x2\x2\x762\x760\x3\x2\x2"+
		"\x2\x762\x761\x3\x2\x2\x2\x763\x765\x3\x2\x2\x2\x764\x766\a\x8E\x2\x2"+
		"\x765\x764\x3\x2\x2\x2\x765\x766\x3\x2\x2\x2\x766\x768\x3\x2\x2\x2\x767"+
		"\x762\x3\x2\x2\x2\x767\x768\x3\x2\x2\x2\x768\x76A\x3\x2\x2\x2\x769\x76B"+
		"\x5\x112\x8A\x2\x76A\x769\x3\x2\x2\x2\x76A\x76B\x3\x2\x2\x2\x76B\x111"+
		"\x3\x2\x2\x2\x76C\x76E\a\x93\x2\x2\x76D\x76F\x5\x118\x8D\x2\x76E\x76D"+
		"\x3\x2\x2\x2\x76E\x76F\x3\x2\x2\x2\x76F\x771\x3\x2\x2\x2\x770\x772\a\x96"+
		"\x2\x2\x771\x770\x3\x2\x2\x2\x771\x772\x3\x2\x2\x2\x772\x774\x3\x2\x2"+
		"\x2\x773\x775\x5\x118\x8D\x2\x774\x773\x3\x2\x2\x2\x774\x775\x3\x2\x2"+
		"\x2\x775\x776\x3\x2\x2\x2\x776\x777\a\x94\x2\x2\x777\x113\x3\x2\x2\x2"+
		"\x778\x779\as\x2\x2\x779\x77E\x5\x116\x8C\x2\x77A\x77B\a\x96\x2\x2\x77B"+
		"\x77D\x5\x116\x8C\x2\x77C\x77A\x3\x2\x2\x2\x77D\x780\x3\x2\x2\x2\x77E"+
		"\x77C\x3\x2\x2\x2\x77E\x77F\x3\x2\x2\x2\x77F\x115\x3\x2\x2\x2\x780\x77E"+
		"\x3\x2\x2\x2\x781\x782\a\xC1\x2\x2\x782\x783\a\x10\x2\x2\x783\x784\x5"+
		"\x118\x8D\x2\x784\x117\x3\x2\x2\x2\x785\x786\x5\x11A\x8E\x2\x786\x119"+
		"\x3\x2\x2\x2\x787\x788\b\x8E\x1\x2\x788\x78A\a\x1B\x2\x2\x789\x78B\x5"+
		"\xF2z\x2\x78A\x789\x3\x2\x2\x2\x78B\x78C\x3\x2\x2\x2\x78C\x78A\x3\x2\x2"+
		"\x2\x78C\x78D\x3\x2\x2\x2\x78D\x78F\x3\x2\x2\x2\x78E\x790\x5\xF4{\x2\x78F"+
		"\x78E\x3\x2\x2\x2\x78F\x790\x3\x2\x2\x2\x790\x791\x3\x2\x2\x2\x791\x792"+
		"\a\x1F\x2\x2\x792\x793\b\x8E\x1\x2\x793\x7A4\x3\x2\x2\x2\x794\x795\b\x8E"+
		"\x1\x2\x795\x796\a\x1B\x2\x2\x796\x798\x5\x118\x8D\x2\x797\x799\x5\xF2"+
		"z\x2\x798\x797\x3\x2\x2\x2\x799\x79A\x3\x2\x2\x2\x79A\x798\x3\x2\x2\x2"+
		"\x79A\x79B\x3\x2\x2\x2\x79B\x79D\x3\x2\x2\x2\x79C\x79E\x5\xF4{\x2\x79D"+
		"\x79C\x3\x2\x2\x2\x79D\x79E\x3\x2\x2\x2\x79E\x79F\x3\x2\x2\x2\x79F\x7A0"+
		"\a\x1F\x2\x2\x7A0\x7A1\b\x8E\x1\x2\x7A1\x7A4\x3\x2\x2\x2\x7A2\x7A4\x5"+
		"\x11C\x8F\x2\x7A3\x787\x3\x2\x2\x2\x7A3\x794\x3\x2\x2\x2\x7A3\x7A2\x3"+
		"\x2\x2\x2\x7A4\x11B\x3\x2\x2\x2\x7A5\x7AA\x5\x11E\x90\x2\x7A6\x7A7\a\n"+
		"\x2\x2\x7A7\x7A9\x5\x11E\x90\x2\x7A8\x7A6\x3\x2\x2\x2\x7A9\x7AC\x3\x2"+
		"\x2\x2\x7AA\x7A8\x3\x2\x2\x2\x7AA\x7AB\x3\x2\x2\x2\x7AB\x11D\x3\x2\x2"+
		"\x2\x7AC\x7AA\x3\x2\x2\x2\x7AD\x7B2\x5\x120\x91\x2\x7AE\x7AF\a\v\x2\x2"+
		"\x7AF\x7B1\x5\x120\x91\x2\x7B0\x7AE\x3\x2\x2\x2\x7B1\x7B4\x3\x2\x2\x2"+
		"\x7B2\x7B0\x3\x2\x2\x2\x7B2\x7B3\x3\x2\x2\x2\x7B3\x11F\x3\x2\x2\x2\x7B4"+
		"\x7B2\x3\x2\x2\x2\x7B5\x7BA\x5\x122\x92\x2\x7B6\x7B7\t\x6\x2\x2\x7B7\x7B9"+
		"\x5\x122\x92\x2\x7B8\x7B6\x3\x2\x2\x2\x7B9\x7BC\x3\x2\x2\x2\x7BA\x7B8"+
		"\x3\x2\x2\x2\x7BA\x7BB\x3\x2\x2\x2\x7BB\x121\x3\x2\x2\x2\x7BC\x7BA\x3"+
		"\x2\x2\x2\x7BD\x7C1\x5\x124\x93\x2\x7BE\x7BF\a\f\x2\x2\x7BF\x7C1\x5\x124"+
		"\x93\x2\x7C0\x7BD\x3\x2\x2\x2\x7C0\x7BE\x3\x2\x2\x2\x7C1\x123\x3\x2\x2"+
		"\x2\x7C2\x7DD\x5\x126\x94\x2\x7C3\x7CA\a\x8C\x2\x2\x7C4\x7CA\a(\x2\x2"+
		"\x7C5\x7C6\a(\x2\x2\x7C6\x7CA\a\f\x2\x2\x7C7\x7CA\a\x8D\x2\x2\x7C8\x7CA"+
		"\a\x9A\x2\x2\x7C9\x7C3\x3\x2\x2\x2\x7C9\x7C4\x3\x2\x2\x2\x7C9\x7C5\x3"+
		"\x2\x2\x2\x7C9\x7C7\x3\x2\x2\x2\x7C9\x7C8\x3\x2\x2\x2\x7CA\x7D9\x3\x2"+
		"\x2\x2\x7CB\x7DA\x5\x126\x94\x2\x7CC\x7D0\a.\x2\x2\x7CD\x7D0\a/\x2\x2"+
		"\x7CE\x7D0\a-\x2\x2\x7CF\x7CC\x3\x2\x2\x2\x7CF\x7CD\x3\x2\x2\x2\x7CF\x7CE"+
		"\x3\x2\x2\x2\x7D0\x7D7\x3\x2\x2\x2\x7D1\x7D3\a\x8F\x2\x2\x7D2\x7D4\x5"+
		"\x19E\xD0\x2\x7D3\x7D2\x3\x2\x2\x2\x7D3\x7D4\x3\x2\x2\x2\x7D4\x7D5\x3"+
		"\x2\x2\x2\x7D5\x7D8\a\x90\x2\x2\x7D6\x7D8\x5\x13A\x9E\x2\x7D7\x7D1\x3"+
		"\x2\x2\x2\x7D7\x7D6\x3\x2\x2\x2\x7D8\x7DA\x3\x2\x2\x2\x7D9\x7CB\x3\x2"+
		"\x2\x2\x7D9\x7CF\x3\x2\x2\x2\x7DA\x7DC\x3\x2\x2\x2\x7DB\x7C9\x3\x2\x2"+
		"\x2\x7DC\x7DF\x3\x2\x2\x2\x7DD\x7DB\x3\x2\x2\x2\x7DD\x7DE\x3\x2\x2\x2"+
		"\x7DE\x125\x3\x2\x2\x2\x7DF\x7DD\x3\x2\x2\x2\x7E0\x822\x5\x12A\x96\x2"+
		"\x7E1\x7E6\a\xAA\x2\x2\x7E2\x7E6\a\xA8\x2\x2\x7E3\x7E6\a\xA9\x2\x2\x7E4"+
		"\x7E6\a\xA7\x2\x2\x7E5\x7E1\x3\x2\x2\x2\x7E5\x7E2\x3\x2\x2\x2\x7E5\x7E3"+
		"\x3\x2\x2\x2\x7E5\x7E4\x3\x2\x2\x2\x7E6\x7F5\x3\x2\x2\x2\x7E7\x7F6\x5"+
		"\x12A\x96\x2\x7E8\x7EC\a.\x2\x2\x7E9\x7EC\a/\x2\x2\x7EA\x7EC\a-\x2\x2"+
		"\x7EB\x7E8\x3\x2\x2\x2\x7EB\x7E9\x3\x2\x2\x2\x7EB\x7EA\x3\x2\x2\x2\x7EC"+
		"\x7F3\x3\x2\x2\x2\x7ED\x7EF\a\x8F\x2\x2\x7EE\x7F0\x5\x19E\xD0\x2\x7EF"+
		"\x7EE\x3\x2\x2\x2\x7EF\x7F0\x3\x2\x2\x2\x7F0\x7F1\x3\x2\x2\x2\x7F1\x7F4"+
		"\a\x90\x2\x2\x7F2\x7F4\x5\x13A\x9E\x2\x7F3\x7ED\x3\x2\x2\x2\x7F3\x7F2"+
		"\x3\x2\x2\x2\x7F4\x7F6\x3\x2\x2\x2\x7F5\x7E7\x3\x2\x2\x2\x7F5\x7EB\x3"+
		"\x2\x2\x2\x7F6\x7F8\x3\x2\x2\x2\x7F7\x7E5\x3\x2\x2\x2\x7F8\x7FB\x3\x2"+
		"\x2\x2\x7F9\x7F7\x3\x2\x2\x2\x7F9\x7FA\x3\x2\x2\x2\x7FA\x823\x3\x2\x2"+
		"\x2\x7FB\x7F9\x3\x2\x2\x2\x7FC\x7FE\a\f\x2\x2\x7FD\x7FC\x3\x2\x2\x2\x7FD"+
		"\x7FE\x3\x2\x2\x2\x7FE\x820\x3\x2\x2\x2\x7FF\x802\a\x5\x2\x2\x800\x803"+
		"\a\x8F\x2\x2\x801\x803\a\x91\x2\x2\x802\x800\x3\x2\x2\x2\x802\x801\x3"+
		"\x2\x2\x2\x803\x804\x3\x2\x2\x2\x804\x80E\x5\x118\x8D\x2\x805\x806\a\x95"+
		"\x2\x2\x806\x80F\x5\x118\x8D\x2\x807\x808\a\x96\x2\x2\x808\x80A\x5\x118"+
		"\x8D\x2\x809\x807\x3\x2\x2\x2\x80A\x80D\x3\x2\x2\x2\x80B\x809\x3\x2\x2"+
		"\x2\x80B\x80C\x3\x2\x2\x2\x80C\x80F\x3\x2\x2\x2\x80D\x80B\x3\x2\x2\x2"+
		"\x80E\x805\x3\x2\x2\x2\x80E\x80B\x3\x2\x2\x2\x80F\x812\x3\x2\x2\x2\x810"+
		"\x813\a\x90\x2\x2\x811\x813\a\x92\x2\x2\x812\x810\x3\x2\x2\x2\x812\x811"+
		"\x3\x2\x2\x2\x813\x821\x3\x2\x2\x2\x814\x815\a\x5\x2\x2\x815\x821\x5\x128"+
		"\x95\x2\x816\x817\a\x6\x2\x2\x817\x821\x5\x15A\xAE\x2\x818\x819\a\a\x2"+
		"\x2\x819\x81C\x5\x12A\x96\x2\x81A\x81B\a\t\x2\x2\x81B\x81D\x5\x1DE\xF0"+
		"\x2\x81C\x81A\x3\x2\x2\x2\x81C\x81D\x3\x2\x2\x2\x81D\x821\x3\x2\x2\x2"+
		"\x81E\x81F\a\b\x2\x2\x81F\x821\x5\x12A\x96\x2\x820\x7FF\x3\x2\x2\x2\x820"+
		"\x814\x3\x2\x2\x2\x820\x816\x3\x2\x2\x2\x820\x818\x3\x2\x2\x2\x820\x81E"+
		"\x3\x2\x2\x2\x821\x823\x3\x2\x2\x2\x822\x7F9\x3\x2\x2\x2\x822\x7FD\x3"+
		"\x2\x2\x2\x823\x127\x3\x2\x2\x2\x824\x825\x5\x13E\xA0\x2\x825\x129\x3"+
		"\x2\x2\x2\x826\x830\x5\x12C\x97\x2\x827\x828\a\xAF\x2\x2\x828\x82D\x5"+
		"\x12C\x97\x2\x829\x82A\a\xAF\x2\x2\x82A\x82C\x5\x12C\x97\x2\x82B\x829"+
		"\x3\x2\x2\x2\x82C\x82F\x3\x2\x2\x2\x82D\x82B\x3\x2\x2\x2\x82D\x82E\x3"+
		"\x2\x2\x2\x82E\x831\x3\x2\x2\x2\x82F\x82D\x3\x2\x2\x2\x830\x827\x3\x2"+
		"\x2\x2\x830\x831\x3\x2\x2\x2\x831\x12B\x3\x2\x2\x2\x832\x837\x5\x12E\x98"+
		"\x2\x833\x834\t\a\x2\x2\x834\x836\x5\x12E\x98\x2\x835\x833\x3\x2\x2\x2"+
		"\x836\x839\x3\x2\x2\x2\x837\x835\x3\x2\x2\x2\x837\x838\x3\x2\x2\x2\x838"+
		"\x12D\x3\x2\x2\x2\x839\x837\x3\x2\x2\x2\x83A\x83F\x5\x130\x99\x2\x83B"+
		"\x83C\t\b\x2\x2\x83C\x83E\x5\x130\x99\x2\x83D\x83B\x3\x2\x2\x2\x83E\x841"+
		"\x3\x2\x2\x2\x83F\x83D\x3\x2\x2\x2\x83F\x840\x3\x2\x2\x2\x840\x12F\x3"+
		"\x2\x2\x2\x841\x83F\x3\x2\x2\x2\x842\x843\a\xA0\x2\x2\x843\x87E\x5\x1B8"+
		"\xDD\x2\x844\x87E\x5\x1DA\xEE\x2\x845\x87E\x5\x132\x9A\x2\x846\x847\a"+
		"\x8F\x2\x2\x847\x848\x5\x118\x8D\x2\x848\x84A\a\x90\x2\x2\x849\x84B\x5"+
		"\x134\x9B\x2\x84A\x849\x3\x2\x2\x2\x84A\x84B\x3\x2\x2\x2\x84B\x87E\x3"+
		"\x2\x2\x2\x84C\x87E\x5\x144\xA3\x2\x84D\x87E\x5\x148\xA5\x2\x84E\x87E"+
		"\x5\x142\xA2\x2\x84F\x87E\x5\x138\x9D\x2\x850\x87E\x5\x13C\x9F\x2\x851"+
		"\x852\a}\x2\x2\x852\x853\a\x93\x2\x2\x853\x858\x5\x136\x9C\x2\x854\x855"+
		"\a\x96\x2\x2\x855\x857\x5\x136\x9C\x2\x856\x854\x3\x2\x2\x2\x857\x85A"+
		"\x3\x2\x2\x2\x858\x856\x3\x2\x2\x2\x858\x859\x3\x2\x2\x2\x859\x85B\x3"+
		"\x2\x2\x2\x85A\x858\x3\x2\x2\x2\x85B\x85C\a\x94\x2\x2\x85C\x87E\x3\x2"+
		"\x2\x2\x85D\x85E\a}\x2\x2\x85E\x85F\x5\x18E\xC8\x2\x85F\x868\a\x8F\x2"+
		"\x2\x860\x865\x5\x118\x8D\x2\x861\x862\a\x96\x2\x2\x862\x864\x5\x118\x8D"+
		"\x2\x863\x861\x3\x2\x2\x2\x864\x867\x3\x2\x2\x2\x865\x863\x3\x2\x2\x2"+
		"\x865\x866\x3\x2\x2\x2\x866\x869\x3\x2\x2\x2\x867\x865\x3\x2\x2\x2\x868"+
		"\x860\x3\x2\x2\x2\x868\x869\x3\x2\x2\x2\x869\x86A\x3\x2\x2\x2\x86A\x86C"+
		"\a\x90\x2\x2\x86B\x86D\x5\x134\x9B\x2\x86C\x86B\x3\x2\x2\x2\x86C\x86D"+
		"\x3\x2\x2\x2\x86D\x87E\x3\x2\x2\x2\x86E\x86F\a\xC1\x2\x2\x86F\x870\a\x91"+
		"\x2\x2\x870\x875\x5\x118\x8D\x2\x871\x872\a\x96\x2\x2\x872\x874\x5\x118"+
		"\x8D\x2\x873\x871\x3\x2\x2\x2\x874\x877\x3\x2\x2\x2\x875\x873\x3\x2\x2"+
		"\x2\x875\x876\x3\x2\x2\x2\x876\x878\x3\x2\x2\x2\x877\x875\x3\x2\x2\x2"+
		"\x878\x87A\a\x92\x2\x2\x879\x87B\x5\x134\x9B\x2\x87A\x879\x3\x2\x2\x2"+
		"\x87A\x87B\x3\x2\x2\x2\x87B\x87E\x3\x2\x2\x2\x87C\x87E\x5\x1E2\xF2\x2"+
		"\x87D\x842\x3\x2\x2\x2\x87D\x844\x3\x2\x2\x2\x87D\x845\x3\x2\x2\x2\x87D"+
		"\x846\x3\x2\x2\x2\x87D\x84C\x3\x2\x2\x2\x87D\x84D\x3\x2\x2\x2\x87D\x84E"+
		"\x3\x2\x2\x2\x87D\x84F\x3\x2\x2\x2\x87D\x850\x3\x2\x2\x2\x87D\x851\x3"+
		"\x2\x2\x2\x87D\x85D\x3\x2\x2\x2\x87D\x86E\x3\x2\x2\x2\x87D\x87C\x3\x2"+
		"\x2\x2\x87E\x131\x3\x2\x2\x2\x87F\x881\x5\x1D8\xED\x2\x880\x882\x5\x134"+
		"\x9B\x2\x881\x880\x3\x2\x2\x2\x881\x882\x3\x2\x2\x2\x882\x133\x3\x2\x2"+
		"\x2\x883\x884\a\xB4\x2\x2\x884\x889\x5\x14E\xA8\x2\x885\x886\a\xB4\x2"+
		"\x2\x886\x888\x5\x14E\xA8\x2\x887\x885\x3\x2\x2\x2\x888\x88B\x3\x2\x2"+
		"\x2\x889\x887\x3\x2\x2\x2\x889\x88A\x3\x2\x2\x2\x88A\x135\x3\x2\x2\x2"+
		"\x88B\x889\x3\x2\x2\x2\x88C\x88F\x5\x1B8\xDD\x2\x88D\x88E\a\x8C\x2\x2"+
		"\x88E\x890\x5\x118\x8D\x2\x88F\x88D\x3\x2\x2\x2\x88F\x890\x3\x2\x2\x2"+
		"\x890\x137\x3\x2\x2\x2\x891\x893\x5\x13E\xA0\x2\x892\x894\x5\x134\x9B"+
		"\x2\x893\x892\x3\x2\x2\x2\x893\x894\x3\x2\x2\x2\x894\x139\x3\x2\x2\x2"+
		"\x895\x896\x5\x13E\xA0\x2\x896\x13B\x3\x2\x2\x2\x897\x898\aI\x2\x2\x898"+
		"\x899\x5\x13E\xA0\x2\x899\x13D\x3\x2\x2\x2\x89A\x89B\a\x8F\x2\x2\x89B"+
		"\x89D\a\x1A\x2\x2\x89C\x89E\a,\x2\x2\x89D\x89C\x3\x2\x2\x2\x89D\x89E\x3"+
		"\x2\x2\x2\x89E\x89F\x3\x2\x2\x2\x89F\x8A0\x5\xC0\x61\x2\x8A0\x8A1\a \x2"+
		"\x2\x8A1\x8A4\x5\x140\xA1\x2\x8A2\x8A3\a\xF\x2\x2\x8A3\x8A5\x5\xBC_\x2"+
		"\x8A4\x8A2\x3\x2\x2\x2\x8A4\x8A5\x3\x2\x2\x2\x8A5\x8A9\x3\x2\x2\x2\x8A6"+
		"\x8A7\a*\x2\x2\x8A7\x8A8\a)\x2\x2\x8A8\x8AA\x5\xD6l\x2\x8A9\x8A6\x3\x2"+
		"\x2\x2\x8A9\x8AA\x3\x2\x2\x2\x8AA\x8AB\x3\x2\x2\x2\x8AB\x8AC\a\x90\x2"+
		"\x2\x8AC\x13F\x3\x2\x2\x2\x8AD\x8B7\x5\x17A\xBE\x2\x8AE\x8AF\a\xB4\x2"+
		"\x2\x8AF\x8B4\x5\xD4k\x2\x8B0\x8B1\a\xB4\x2\x2\x8B1\x8B3\x5\xD4k\x2\x8B2"+
		"\x8B0\x3\x2\x2\x2\x8B3\x8B6\x3\x2\x2\x2\x8B4\x8B2\x3\x2\x2\x2\x8B4\x8B5"+
		"\x3\x2\x2\x2\x8B5\x8B8\x3\x2\x2\x2\x8B6\x8B4\x3\x2\x2\x2\x8B7\x8AE\x3"+
		"\x2\x2\x2\x8B7\x8B8\x3\x2\x2\x2\x8B8\x8BC\x3\x2\x2\x2\x8B9\x8BA\a\x10"+
		"\x2\x2\x8BA\x8BD\a\xC1\x2\x2\x8BB\x8BD\a\xC1\x2\x2\x8BC\x8B9\x3\x2\x2"+
		"\x2\x8BC\x8BB\x3\x2\x2\x2\x8BC\x8BD\x3\x2\x2\x2\x8BD\x8C0\x3\x2\x2\x2"+
		"\x8BE\x8C1\a?\x2\x2\x8BF\x8C1\a@\x2\x2\x8C0\x8BE\x3\x2\x2\x2\x8C0\x8BF"+
		"\x3\x2\x2\x2\x8C0\x8C1\x3\x2\x2\x2\x8C1\x141\x3\x2\x2\x2\x8C2\x8CB\a\x93"+
		"\x2\x2\x8C3\x8C8\x5\x118\x8D\x2\x8C4\x8C5\a\x96\x2\x2\x8C5\x8C7\x5\x118"+
		"\x8D\x2\x8C6\x8C4\x3\x2\x2\x2\x8C7\x8CA\x3\x2\x2\x2\x8C8\x8C6\x3\x2\x2"+
		"\x2\x8C8\x8C9\x3\x2\x2\x2\x8C9\x8CC\x3\x2\x2\x2\x8CA\x8C8\x3\x2\x2\x2"+
		"\x8CB\x8C3\x3\x2\x2\x2\x8CB\x8CC\x3\x2\x2\x2\x8CC\x8CD\x3\x2\x2\x2\x8CD"+
		"\x8CF\a\x94\x2\x2\x8CE\x8D0\x5\x134\x9B\x2\x8CF\x8CE\x3\x2\x2\x2\x8CF"+
		"\x8D0\x3\x2\x2\x2\x8D0\x143\x3\x2\x2\x2\x8D1\x8D2\a\x11\x2\x2\x8D2\x8D4"+
		"\a\x8F\x2\x2\x8D3\x8D5\t\t\x2\x2\x8D4\x8D3\x3\x2\x2\x2\x8D4\x8D5\x3\x2"+
		"\x2\x2\x8D5\x8D6\x3\x2\x2\x2\x8D6\x8D7\x5\x192\xCA\x2\x8D7\x8D8\a\x90"+
		"\x2\x2\x8D8\x975\x3\x2\x2\x2\x8D9\x8DA\a\x12\x2\x2\x8DA\x8DC\a\x8F\x2"+
		"\x2\x8DB\x8DD\t\t\x2\x2\x8DC\x8DB\x3\x2\x2\x2\x8DC\x8DD\x3\x2\x2\x2\x8DD"+
		"\x8DE\x3\x2\x2\x2\x8DE\x8DF\x5\x192\xCA\x2\x8DF\x8E0\a\x90\x2\x2\x8E0"+
		"\x975\x3\x2\x2\x2\x8E1\x8E2\a\x19\x2\x2\x8E2\x8E5\a\x8F\x2\x2\x8E3\x8E6"+
		"\a-\x2\x2\x8E4\x8E6\a,\x2\x2\x8E5\x8E3\x3\x2\x2\x2\x8E5\x8E4\x3\x2\x2"+
		"\x2\x8E5\x8E6\x3\x2\x2\x2\x8E6\x8E7\x3\x2\x2\x2\x8E7\x8E8\x5\x192\xCA"+
		"\x2\x8E8\x8E9\a\x90\x2\x2\x8E9\x975\x3\x2\x2\x2\x8EA\x8EB\a\x16\x2\x2"+
		"\x8EB\x8ED\a\x8F\x2\x2\x8EC\x8EE\t\t\x2\x2\x8ED\x8EC\x3\x2\x2\x2\x8ED"+
		"\x8EE\x3\x2\x2\x2\x8EE\x8EF\x3\x2\x2\x2\x8EF\x8F0\x5\x192\xCA\x2\x8F0"+
		"\x8F1\a\x90\x2\x2\x8F1\x975\x3\x2\x2\x2\x8F2\x8F3\a\x17\x2\x2\x8F3\x8F5"+
		"\a\x8F\x2\x2\x8F4\x8F6\t\t\x2\x2\x8F5\x8F4\x3\x2\x2\x2\x8F5\x8F6\x3\x2"+
		"\x2\x2\x8F6\x8F7\x3\x2\x2\x2\x8F7\x8F8\x5\x192\xCA\x2\x8F8\x8F9\a\x90"+
		"\x2\x2\x8F9\x975\x3\x2\x2\x2\x8FA\x8FB\a\x18\x2\x2\x8FB\x8FD\a\x8F\x2"+
		"\x2\x8FC\x8FE\t\t\x2\x2\x8FD\x8FC\x3\x2\x2\x2\x8FD\x8FE\x3\x2\x2\x2\x8FE"+
		"\x8FF\x3\x2\x2\x2\x8FF\x900\x5\x192\xCA\x2\x900\x901\a\x90\x2\x2\x901"+
		"\x975\x3\x2\x2\x2\x902\x975\x5\x146\xA4\x2\x903\x904\a\x15\x2\x2\x904"+
		"\x905\a\x8F\x2\x2\x905\x906\x5\x118\x8D\x2\x906\x907\a\x96\x2\x2\x907"+
		"\x90C\x5\x118\x8D\x2\x908\x909\a\x96\x2\x2\x909\x90B\x5\x118\x8D\x2\x90A"+
		"\x908\x3\x2\x2\x2\x90B\x90E\x3\x2\x2\x2\x90C\x90A\x3\x2\x2\x2\x90C\x90D"+
		"\x3\x2\x2\x2\x90D\x90F\x3\x2\x2\x2\x90E\x90C\x3\x2\x2\x2\x90F\x910\a\x90"+
		"\x2\x2\x910\x975\x3\x2\x2\x2\x911\x912\a\x44\x2\x2\x912\x913\a\x8F\x2"+
		"\x2\x913\x916\x5\x118\x8D\x2\x914\x915\a\x96\x2\x2\x915\x917\x5\x118\x8D"+
		"\x2\x916\x914\x3\x2\x2\x2\x916\x917\x3\x2\x2\x2\x917\x918\x3\x2\x2\x2"+
		"\x918\x91A\a\x90\x2\x2\x919\x91B\x5\x134\x9B\x2\x91A\x919\x3\x2\x2\x2"+
		"\x91A\x91B\x3\x2\x2\x2\x91B\x975\x3\x2\x2\x2\x91C\x91D\a\x45\x2\x2\x91D"+
		"\x91E\a\x8F\x2\x2\x91E\x921\x5\x118\x8D\x2\x91F\x920\a\x96\x2\x2\x920"+
		"\x922\x5\x118\x8D\x2\x921\x91F\x3\x2\x2\x2\x921\x922\x3\x2\x2\x2\x922"+
		"\x923\x3\x2\x2\x2\x923\x925\a\x90\x2\x2\x924\x926\x5\x134\x9B\x2\x925"+
		"\x924\x3\x2\x2\x2\x925\x926\x3\x2\x2\x2\x926\x975\x3\x2\x2\x2\x927\x928"+
		"\a\x46\x2\x2\x928\x929\a\x8F\x2\x2\x929\x92A\x5\x118\x8D\x2\x92A\x92B"+
		"\a\x90\x2\x2\x92B\x975\x3\x2\x2\x2\x92C\x92D\aG\x2\x2\x92D\x92E\a\x8F"+
		"\x2\x2\x92E\x92F\x5\x118\x8D\x2\x92F\x931\a\x90\x2\x2\x930\x932\x5\x134"+
		"\x9B\x2\x931\x930\x3\x2\x2\x2\x931\x932\x3\x2\x2\x2\x932\x975\x3\x2\x2"+
		"\x2\x933\x934\aH\x2\x2\x934\x935\a\x8F\x2\x2\x935\x936\x5\x118\x8D\x2"+
		"\x936\x937\a\x96\x2\x2\x937\x938\x5\x1B8\xDD\x2\x938\x939\a\x90\x2\x2"+
		"\x939\x975\x3\x2\x2\x2\x93A\x93B\a\x85\x2\x2\x93B\x93C\a\x8F\x2\x2\x93C"+
		"\x93D\x5\x118\x8D\x2\x93D\x93E\a\x90\x2\x2\x93E\x975\x3\x2\x2\x2\x93F"+
		"\x940\a\x86\x2\x2\x940\x941\a\x8F\x2\x2\x941\x942\x5\x19E\xD0\x2\x942"+
		"\x943\a\x90\x2\x2\x943\x975\x3\x2\x2\x2\x944\x945\aL\x2\x2\x945\x946\a"+
		"\x8F\x2\x2\x946\x947\x5\x118\x8D\x2\x947\x948\a\x96\x2\x2\x948\x94D\x5"+
		"\x18E\xC8\x2\x949\x94A\a\x96\x2\x2\x94A\x94C\x5\x18E\xC8\x2\x94B\x949"+
		"\x3\x2\x2\x2\x94C\x94F\x3\x2\x2\x2\x94D\x94B\x3\x2\x2\x2\x94D\x94E\x3"+
		"\x2\x2\x2\x94E\x950\x3\x2\x2\x2\x94F\x94D\x3\x2\x2\x2\x950\x951\a\x90"+
		"\x2\x2\x951\x975\x3\x2\x2\x2\x952\x953\aM\x2\x2\x953\x954\a\x8F\x2\x2"+
		"\x954\x955\x5\x118\x8D\x2\x955\x956\a\x90\x2\x2\x956\x975\x3\x2\x2\x2"+
		"\x957\x958\aN\x2\x2\x958\x959\a\x8F\x2\x2\x959\x95A\x5\x118\x8D\x2\x95A"+
		"\x95B\t\n\x2\x2\x95B\x95E\x5\x18E\xC8\x2\x95C\x95D\a\x96\x2\x2\x95D\x95F"+
		"\x5\x19A\xCE\x2\x95E\x95C\x3\x2\x2\x2\x95E\x95F\x3\x2\x2\x2\x95F\x960"+
		"\x3\x2\x2\x2\x960\x962\a\x90\x2\x2\x961\x963\x5\x134\x9B\x2\x962\x961"+
		"\x3\x2\x2\x2\x962\x963\x3\x2\x2\x2\x963\x975\x3\x2\x2\x2\x964\x965\aI"+
		"\x2\x2\x965\x966\a\x8F\x2\x2\x966\x967\x5\x1B8\xDD\x2\x967\x968\a\x90"+
		"\x2\x2\x968\x975\x3\x2\x2\x2\x969\x96C\aO\x2\x2\x96A\x96B\a\x8F\x2\x2"+
		"\x96B\x96D\a\x90\x2\x2\x96C\x96A\x3\x2\x2\x2\x96C\x96D\x3\x2\x2\x2\x96D"+
		"\x96F\x3\x2\x2\x2\x96E\x970\x5\x134\x9B\x2\x96F\x96E\x3\x2\x2\x2\x96F"+
		"\x970\x3\x2\x2\x2\x970\x975\x3\x2\x2\x2\x971\x972\a;\x2\x2\x972\x973\a"+
		"\x8F\x2\x2\x973\x975\a\x90\x2\x2\x974\x8D1\x3\x2\x2\x2\x974\x8D9\x3\x2"+
		"\x2\x2\x974\x8E1\x3\x2\x2\x2\x974\x8EA\x3\x2\x2\x2\x974\x8F2\x3\x2\x2"+
		"\x2\x974\x8FA\x3\x2\x2\x2\x974\x902\x3\x2\x2\x2\x974\x903\x3\x2\x2\x2"+
		"\x974\x911\x3\x2\x2\x2\x974\x91C\x3\x2\x2\x2\x974\x927\x3\x2\x2\x2\x974"+
		"\x92C\x3\x2\x2\x2\x974\x933\x3\x2\x2\x2\x974\x93A\x3\x2\x2\x2\x974\x93F"+
		"\x3\x2\x2\x2\x974\x944\x3\x2\x2\x2\x974\x952\x3\x2\x2\x2\x974\x957\x3"+
		"\x2\x2\x2\x974\x964\x3\x2\x2\x2\x974\x969\x3\x2\x2\x2\x974\x971\x3\x2"+
		"\x2\x2\x975\x145\x3\x2\x2\x2\x976\x97A\a\x32\x2\x2\x977\x97A\a\x33\x2"+
		"\x2\x978\x97A\a\x4\x2\x2\x979\x976\x3\x2\x2\x2\x979\x977\x3\x2\x2\x2\x979"+
		"\x978\x3\x2\x2\x2\x97A\x97B\x3\x2\x2\x2\x97B\x97D\a\x8F\x2\x2\x97C\x97E"+
		"\x5\x192\xCA\x2\x97D\x97C\x3\x2\x2\x2\x97D\x97E\x3\x2\x2\x2\x97E\x97F"+
		"\x3\x2\x2\x2\x97F\x981\a\x90\x2\x2\x980\x982\x5\x134\x9B\x2\x981\x980"+
		"\x3\x2\x2\x2\x981\x982\x3\x2\x2\x2\x982\x147\x3\x2\x2\x2\x983\x986\x5"+
		"\x1B8\xDD\x2\x984\x986\x5\x14A\xA6\x2\x985\x983\x3\x2\x2\x2\x985\x984"+
		"\x3\x2\x2\x2\x986\x149\x3\x2\x2\x2\x987\x98C\x5\x14C\xA7\x2\x988\x989"+
		"\a\xB4\x2\x2\x989\x98B\x5\x14E\xA8\x2\x98A\x988\x3\x2\x2\x2\x98B\x98E"+
		"\x3\x2\x2\x2\x98C\x98A\x3\x2\x2\x2\x98C\x98D\x3\x2\x2\x2\x98D\x14B\x3"+
		"\x2\x2\x2\x98E\x98C\x3\x2\x2\x2\x98F\x990\x5\x18E\xC8\x2\x990\x991\a\xB4"+
		"\x2\x2\x991\x992\x5\x152\xAA\x2\x992\x995\x3\x2\x2\x2\x993\x995\x5\x150"+
		"\xA9\x2\x994\x98F\x3\x2\x2\x2\x994\x993\x3\x2\x2\x2\x995\x99B\x3\x2\x2"+
		"\x2\x996\x998\a\x8F\x2\x2\x997\x999\x5\x156\xAC\x2\x998\x997\x3\x2\x2"+
		"\x2\x998\x999\x3\x2\x2\x2\x999\x99A\x3\x2\x2\x2\x99A\x99C\a\x90\x2\x2"+
		"\x99B\x996\x3\x2\x2\x2\x99B\x99C\x3\x2\x2\x2\x99C\x14D\x3\x2\x2\x2\x99D"+
		"\x9A3\x5\x154\xAB\x2\x99E\x9A0\a\x8F\x2\x2\x99F\x9A1\x5\x156\xAC\x2\x9A0"+
		"\x99F\x3\x2\x2\x2\x9A0\x9A1\x3\x2\x2\x2\x9A1\x9A2\x3\x2\x2\x2\x9A2\x9A4"+
		"\a\x90\x2\x2\x9A3\x99E\x3\x2\x2\x2\x9A3\x9A4\x3\x2\x2\x2\x9A4\x14F\x3"+
		"\x2\x2\x2\x9A5\x9A9\x5\x1C2\xE2\x2\x9A6\x9A9\a\x13\x2\x2\x9A7\x9A9\a\x14"+
		"\x2\x2\x9A8\x9A5\x3\x2\x2\x2\x9A8\x9A6\x3\x2\x2\x2\x9A8\x9A7\x3\x2\x2"+
		"\x2\x9A9\x151\x3\x2\x2\x2\x9AA\x9AF\x5\x1C2\xE2\x2\x9AB\x9AF\a\x33\x2"+
		"\x2\x9AC\x9AF\a\x32\x2\x2\x9AD\x9AF\a\x4\x2\x2\x9AE\x9AA\x3\x2\x2\x2\x9AE"+
		"\x9AB\x3\x2\x2\x2\x9AE\x9AC\x3\x2\x2\x2\x9AE\x9AD\x3\x2\x2\x2\x9AF\x153"+
		"\x3\x2\x2\x2\x9B0\x9BB\x5\x1C2\xE2\x2\x9B1\x9BB\a\x33\x2\x2\x9B2\x9BB"+
		"\a\x32\x2\x2\x9B3\x9BB\a\x4\x2\x2\x9B4\x9BB\a\x13\x2\x2\x9B5\x9BB\a\x14"+
		"\x2\x2\x9B6\x9BB\a\xF\x2\x2\x9B7\x9BB\aR\x2\x2\x9B8\x9BB\av\x2\x2\x9B9"+
		"\x9BB\a\x6\x2\x2\x9BA\x9B0\x3\x2\x2\x2\x9BA\x9B1\x3\x2\x2\x2\x9BA\x9B2"+
		"\x3\x2\x2\x2\x9BA\x9B3\x3\x2\x2\x2\x9BA\x9B4\x3\x2\x2\x2\x9BA\x9B5\x3"+
		"\x2\x2\x2\x9BA\x9B6\x3\x2\x2\x2\x9BA\x9B7\x3\x2\x2\x2\x9BA\x9B8\x3\x2"+
		"\x2\x2\x9BA\x9B9\x3\x2\x2\x2\x9BB\x155\x3\x2\x2\x2\x9BC\x9BE\t\t\x2\x2"+
		"\x9BD\x9BC\x3\x2\x2\x2\x9BD\x9BE\x3\x2\x2\x2\x9BE\x9BF\x3\x2\x2\x2\x9BF"+
		"\x9C4\x5\x158\xAD\x2\x9C0\x9C1\a\x96\x2\x2\x9C1\x9C3\x5\x158\xAD\x2\x9C2"+
		"\x9C0\x3\x2\x2\x2\x9C3\x9C6\x3\x2\x2\x2\x9C4\x9C2\x3\x2\x2\x2\x9C4\x9C5"+
		"\x3\x2\x2\x2\x9C5\x157\x3\x2\x2\x2\x9C6\x9C4\x3\x2\x2\x2\x9C7\x9C9\x5"+
		"\x10\t\x2\x9C8\x9C7\x3\x2\x2\x2\x9C8\x9C9\x3\x2\x2\x2\x9C9\x9CA\x3\x2"+
		"\x2\x2\x9CA\x9CB\x5\x196\xCC\x2\x9CB\x159\x3\x2\x2\x2\x9CC\x9CD\x5\x12A"+
		"\x96\x2\x9CD\x9CE\a\v\x2\x2\x9CE\x9CF\x5\x12A\x96\x2\x9CF\x15B\x3\x2\x2"+
		"\x2\x9D0\x9D1\x5\x15E\xB0\x2\x9D1\x15D\x3\x2\x2\x2\x9D2\x9D6\x5\x162\xB2"+
		"\x2\x9D3\x9D5\x5\x160\xB1\x2\x9D4\x9D3\x3\x2\x2\x2\x9D5\x9D8\x3\x2\x2"+
		"\x2\x9D6\x9D4\x3\x2\x2\x2\x9D6\x9D7\x3\x2\x2\x2\x9D7\x15F\x3\x2\x2\x2"+
		"\x9D8\x9D6\x3\x2\x2\x2\x9D9\x9DF\a\x8A\x2\x2\x9DA\x9DB\a\x88\x2\x2\x9DB"+
		"\x9DC\x5\x118\x8D\x2\x9DC\x9DD\a\x89\x2\x2\x9DD\x9DF\x3\x2\x2\x2\x9DE"+
		"\x9D9\x3\x2\x2\x2\x9DE\x9DA\x3\x2\x2\x2\x9DF\x9E0\x3\x2\x2\x2\x9E0\x9E1"+
		"\x5\x162\xB2\x2\x9E1\x161\x3\x2\x2\x2\x9E2\x9E7\x5\x164\xB3\x2\x9E3\x9E4"+
		"\a\n\x2\x2\x9E4\x9E6\x5\x164\xB3\x2\x9E5\x9E3\x3\x2\x2\x2\x9E6\x9E9\x3"+
		"\x2\x2\x2\x9E7\x9E5\x3\x2\x2\x2\x9E7\x9E8\x3\x2\x2\x2\x9E8\x163\x3\x2"+
		"\x2\x2\x9E9\x9E7\x3\x2\x2\x2\x9EA\x9EF\x5\x166\xB4\x2\x9EB\x9EC\a\v\x2"+
		"\x2\x9EC\x9EE\x5\x166\xB4\x2\x9ED\x9EB\x3\x2\x2\x2\x9EE\x9F1\x3\x2\x2"+
		"\x2\x9EF\x9ED\x3\x2\x2\x2\x9EF\x9F0\x3\x2\x2\x2\x9F0\x165\x3\x2\x2\x2"+
		"\x9F1\x9EF\x3\x2\x2\x2\x9F2\x9F4\x5\x178\xBD\x2\x9F3\x9F2\x3\x2\x2\x2"+
		"\x9F3\x9F4\x3\x2\x2\x2\x9F4\x9F5\x3\x2\x2\x2\x9F5\x9F8\x5\x168\xB5\x2"+
		"\x9F6\x9F7\aU\x2\x2\x9F7\x9F9\x5\x168\xB5\x2\x9F8\x9F6\x3\x2\x2\x2\x9F8"+
		"\x9F9\x3\x2\x2\x2\x9F9\x167\x3\x2\x2\x2\x9FA\x9FF\a\r\x2\x2\x9FB\x9FF"+
		"\a\f\x2\x2\x9FC\x9FD\a\xE\x2\x2\x9FD\x9FF\x5\x16C\xB7\x2\x9FE\x9FA\x3"+
		"\x2\x2\x2\x9FE\x9FB\x3\x2\x2\x2\x9FE\x9FC\x3\x2\x2\x2\x9FF\xA01\x3\x2"+
		"\x2\x2\xA00\xA02\x5\x178\xBD\x2\xA01\xA00\x3\x2\x2\x2\xA01\xA02\x3\x2"+
		"\x2\x2\xA02\xA04\x3\x2\x2\x2\xA03\x9FE\x3\x2\x2\x2\xA03\xA04\x3\x2\x2"+
		"\x2\xA04\xA05\x3\x2\x2\x2\xA05\xA06\x5\x16A\xB6\x2\xA06\x169\x3\x2\x2"+
		"\x2\xA07\xA0D\x5\x170\xB9\x2\xA08\xA09\a\x8F\x2\x2\xA09\xA0A\x5\x15C\xAF"+
		"\x2\xA0A\xA0B\a\x90\x2\x2\xA0B\xA0D\x3\x2\x2\x2\xA0C\xA07\x3\x2\x2\x2"+
		"\xA0C\xA08\x3\x2\x2\x2\xA0D\xA12\x3\x2\x2\x2\xA0E\xA0F\a\xF\x2\x2\xA0F"+
		"\xA13\x5\x174\xBB\x2\xA10\xA11\ax\x2\x2\xA11\xA13\x5\x176\xBC\x2\xA12"+
		"\xA0E\x3\x2\x2\x2\xA12\xA10\x3\x2\x2\x2\xA12\xA13\x3\x2\x2\x2\xA13\x16B"+
		"\x3\x2\x2\x2\xA14\xA15\a\x8F\x2\x2\xA15\xA1A\x5\x16E\xB8\x2\xA16\xA17"+
		"\a\x96\x2\x2\xA17\xA19\x5\x16E\xB8\x2\xA18\xA16\x3\x2\x2\x2\xA19\xA1C"+
		"\x3\x2\x2\x2\xA1A\xA18\x3\x2\x2\x2\xA1A\xA1B\x3\x2\x2\x2\xA1B\xA1D\x3"+
		"\x2\x2\x2\xA1C\xA1A\x3\x2\x2\x2\xA1D\xA1E\a\x90\x2\x2\xA1E\x16D\x3\x2"+
		"\x2\x2\xA1F\xA20\x5\x1A2\xD2\x2\xA20\x16F\x3\x2\x2\x2\xA21\xA24\x5\x172"+
		"\xBA\x2\xA22\xA24\x5\x18A\xC6\x2\xA23\xA21\x3\x2\x2\x2\xA23\xA22\x3\x2"+
		"\x2\x2\xA24\x171\x3\x2\x2\x2\xA25\xA26\a\xC1\x2\x2\xA26\xA29\a\x95\x2"+
		"\x2\xA27\xA2A\a\xC1\x2\x2\xA28\xA2A\aV\x2\x2\xA29\xA27\x3\x2\x2\x2\xA29"+
		"\xA28\x3\x2\x2\x2\xA2A\xA2B\x3\x2\x2\x2\xA2B\xA2D\a\x8F\x2\x2\xA2C\xA2E"+
		"\x5\x194\xCB\x2\xA2D\xA2C\x3\x2\x2\x2\xA2D\xA2E\x3\x2\x2\x2\xA2E\xA2F"+
		"\x3\x2\x2\x2\xA2F\xA30\a\x90\x2\x2\xA30\x173\x3\x2\x2\x2\xA31\xA32\a\xC1"+
		"\x2\x2\xA32\xA33\a\x95\x2\x2\xA33\xA34\a\xC1\x2\x2\xA34\xA36\a\x8F\x2"+
		"\x2\xA35\xA37\x5\x1A0\xD1\x2\xA36\xA35\x3\x2\x2\x2\xA36\xA37\x3\x2\x2"+
		"\x2\xA37\xA38\x3\x2\x2\x2\xA38\xA39\a\x90\x2\x2\xA39\x175\x3\x2\x2\x2"+
		"\xA3A\xA3B\a\x8F\x2\x2\xA3B\xA3C\x5\x118\x8D\x2\xA3C\xA3D\a\x90\x2\x2"+
		"\xA3D\x177\x3\x2\x2\x2\xA3E\xA48\a\x91\x2\x2\xA3F\xA44\x5\x118\x8D\x2"+
		"\xA40\xA42\a\x95\x2\x2\xA41\xA43\x5\x118\x8D\x2\xA42\xA41\x3\x2\x2\x2"+
		"\xA42\xA43\x3\x2\x2\x2\xA43\xA45\x3\x2\x2\x2\xA44\xA40\x3\x2\x2\x2\xA44"+
		"\xA45\x3\x2\x2\x2\xA45\xA49\x3\x2\x2\x2\xA46\xA47\a\x95\x2\x2\xA47\xA49"+
		"\x5\x118\x8D\x2\xA48\xA3F\x3\x2\x2\x2\xA48\xA46\x3\x2\x2\x2\xA49\xA4A"+
		"\x3\x2\x2\x2\xA4A\xA4B\a\x92\x2\x2\xA4B\x179\x3\x2\x2\x2\xA4C\xA4D\a\xC1"+
		"\x2\x2\xA4D\xA4F\a\x8C\x2\x2\xA4E\xA4C\x3\x2\x2\x2\xA4E\xA4F\x3\x2\x2"+
		"\x2\xA4F\xA50\x3\x2\x2\x2\xA50\xA56\x5\x18E\xC8\x2\xA51\xA53\a\x8F\x2"+
		"\x2\xA52\xA54\x5\x19E\xD0\x2\xA53\xA52\x3\x2\x2\x2\xA53\xA54\x3\x2\x2"+
		"\x2\xA54\xA55\x3\x2\x2\x2\xA55\xA57\a\x90\x2\x2\xA56\xA51\x3\x2\x2\x2"+
		"\xA56\xA57\x3\x2\x2\x2\xA57\xA59\x3\x2\x2\x2\xA58\xA5A\x5\x17C\xBF\x2"+
		"\xA59\xA58\x3\x2\x2\x2\xA59\xA5A\x3\x2\x2\x2\xA5A\x17B\x3\x2\x2\x2\xA5B"+
		"\xA5F\x5\x17E\xC0\x2\xA5C\xA5E\x5\x17E\xC0\x2\xA5D\xA5C\x3\x2\x2\x2\xA5E"+
		"\xA61\x3\x2\x2\x2\xA5F\xA5D\x3\x2\x2\x2\xA5F\xA60\x3\x2\x2\x2\xA60\x17D"+
		"\x3\x2\x2\x2\xA61\xA5F\x3\x2\x2\x2\xA62\xA64\a\x91\x2\x2\xA63\xA65\x5"+
		"\x180\xC1\x2\xA64\xA63\x3\x2\x2\x2\xA64\xA65\x3\x2\x2\x2\xA65\xA66\x3"+
		"\x2\x2\x2\xA66\xA68\x5\x118\x8D\x2\xA67\xA69\x5\x182\xC2\x2\xA68\xA67"+
		"\x3\x2\x2\x2\xA68\xA69\x3\x2\x2\x2\xA69\xA6C\x3\x2\x2\x2\xA6A\xA6B\a\x10"+
		"\x2\x2\xA6B\xA6D\a\xC1\x2\x2\xA6C\xA6A\x3\x2\x2\x2\xA6C\xA6D\x3\x2\x2"+
		"\x2\xA6D\xA70\x3\x2\x2\x2\xA6E\xA6F\a\xF\x2\x2\xA6F\xA71\x5\x118\x8D\x2"+
		"\xA70\xA6E\x3\x2\x2\x2\xA70\xA71\x3\x2\x2\x2\xA71\xA72\x3\x2\x2\x2\xA72"+
		"\xA73\a\x92\x2\x2\xA73\x17F\x3\x2\x2\x2\xA74\xA75\a\x1A\x2\x2\xA75\xA76"+
		"\x5\x184\xC3\x2\xA76\xA77\a \x2\x2\xA77\x181\x3\x2\x2\x2\xA78\xA79\a\xBA"+
		"\x2\x2\xA79\xA7A\a\xC1\x2\x2\xA7A\xA7B\a\x8F\x2\x2\xA7B\xA7C\a\xC1\x2"+
		"\x2\xA7C\xA7D\a\x90\x2\x2\xA7D\x183\x3\x2\x2\x2\xA7E\xA83\x5\x186\xC4"+
		"\x2\xA7F\xA80\a\x96\x2\x2\xA80\xA82\x5\x186\xC4\x2\xA81\xA7F\x3\x2\x2"+
		"\x2\xA82\xA85\x3\x2\x2\x2\xA83\xA81\x3\x2\x2\x2\xA83\xA84\x3\x2\x2\x2"+
		"\xA84\x185\x3\x2\x2\x2\xA85\xA83\x3\x2\x2\x2\xA86\xA8E\a\xA3\x2\x2\xA87"+
		"\xA8E\x5\x188\xC5\x2\xA88\xA8B\x5\x118\x8D\x2\xA89\xA8A\a\x10\x2\x2\xA8A"+
		"\xA8C\x5\x1BE\xE0\x2\xA8B\xA89\x3\x2\x2\x2\xA8B\xA8C\x3\x2\x2\x2\xA8C"+
		"\xA8E\x3\x2\x2\x2\xA8D\xA86\x3\x2\x2\x2\xA8D\xA87\x3\x2\x2\x2\xA8D\xA88"+
		"\x3\x2\x2\x2\xA8E\x187\x3\x2\x2\x2\xA8F\xA90\a\xC1\x2\x2\xA90\xA91\a\xB4"+
		"\x2\x2\xA91\xA94\a\xA3\x2\x2\xA92\xA93\a\x10\x2\x2\xA93\xA95\a\xC1\x2"+
		"\x2\xA94\xA92\x3\x2\x2\x2\xA94\xA95\x3\x2\x2\x2\xA95\x189\x3\x2\x2\x2"+
		"\xA96\xA97\a\xC1\x2\x2\xA97\xA99\a\x8C\x2\x2\xA98\xA96\x3\x2\x2\x2\xA98"+
		"\xA99\x3\x2\x2\x2\xA99\xA9A\x3\x2\x2\x2\xA9A\xAA0\x5\x18E\xC8\x2\xA9B"+
		"\xA9D\a\x8F\x2\x2\xA9C\xA9E\x5\x19E\xD0\x2\xA9D\xA9C\x3\x2\x2\x2\xA9D"+
		"\xA9E\x3\x2\x2\x2\xA9E\xA9F\x3\x2\x2\x2\xA9F\xAA1\a\x90\x2\x2\xAA0\xA9B"+
		"\x3\x2\x2\x2\xAA0\xAA1\x3\x2\x2\x2\xAA1\xAA3\x3\x2\x2\x2\xAA2\xAA4\x5"+
		"\x17C\xBF\x2\xAA3\xAA2\x3\x2\x2\x2\xAA3\xAA4\x3\x2\x2\x2\xAA4\xAA6\x3"+
		"\x2\x2\x2\xAA5\xAA7\x5\x18C\xC7\x2\xAA6\xAA5\x3\x2\x2\x2\xAA6\xAA7\x3"+
		"\x2\x2\x2\xAA7\x18B\x3\x2\x2\x2\xAA8\xAA9\a\xBA\x2\x2\xAA9\xAAE\a\xC1"+
		"\x2\x2\xAAA\xAAB\a\x8F\x2\x2\xAAB\xAAC\x5\x1D6\xEC\x2\xAAC\xAAD\a\x90"+
		"\x2\x2\xAAD\xAAF\x3\x2\x2\x2\xAAE\xAAA\x3\x2\x2\x2\xAAE\xAAF\x3\x2\x2"+
		"\x2\xAAF\x18D\x3\x2\x2\x2\xAB0\xAB5\x5\x1C0\xE1\x2\xAB1\xAB2\a\xB4\x2"+
		"\x2\xAB2\xAB4\x5\x1C0\xE1\x2\xAB3\xAB1\x3\x2\x2\x2\xAB4\xAB7\x3\x2\x2"+
		"\x2\xAB5\xAB3\x3\x2\x2\x2\xAB5\xAB6\x3\x2\x2\x2\xAB6\x18F\x3\x2\x2\x2"+
		"\xAB7\xAB5\x3\x2\x2\x2\xAB8\xABA\a\x9B\x2\x2\xAB9\xAB8\x3\x2\x2\x2\xAB9"+
		"\xABA\x3\x2\x2\x2\xABA\xABB\x3\x2\x2\x2\xABB\xAC0\x5\x1C0\xE1\x2\xABC"+
		"\xABD\a\x9B\x2\x2\xABD\xABF\x5\x1C0\xE1\x2\xABE\xABC\x3\x2\x2\x2\xABF"+
		"\xAC2\x3\x2\x2\x2\xAC0\xABE\x3\x2\x2\x2\xAC0\xAC1\x3\x2\x2\x2\xAC1\x191"+
		"\x3\x2\x2\x2\xAC2\xAC0\x3\x2\x2\x2\xAC3\xAC8\x5\x196\xCC\x2\xAC4\xAC5"+
		"\a\x96\x2\x2\xAC5\xAC7\x5\x196\xCC\x2\xAC6\xAC4\x3\x2\x2\x2\xAC7\xACA"+
		"\x3\x2\x2\x2\xAC8\xAC6\x3\x2\x2\x2\xAC8\xAC9\x3\x2\x2\x2\xAC9\x193\x3"+
		"\x2\x2\x2\xACA\xAC8\x3\x2\x2\x2\xACB\xAD0\x5\x198\xCD\x2\xACC\xACD\a\x96"+
		"\x2\x2\xACD\xACF\x5\x198\xCD\x2\xACE\xACC\x3\x2\x2\x2\xACF\xAD2\x3\x2"+
		"\x2\x2\xAD0\xACE\x3\x2\x2\x2\xAD0\xAD1\x3\x2\x2\x2\xAD1\x195\x3\x2\x2"+
		"\x2\xAD2\xAD0\x3\x2\x2\x2\xAD3\xAD6\x5\x19A\xCE\x2\xAD4\xAD6\x5\x1A2\xD2"+
		"\x2\xAD5\xAD3\x3\x2\x2\x2\xAD5\xAD4\x3\x2\x2\x2\xAD6\x197\x3\x2\x2\x2"+
		"\xAD7\xADA\x5\x19C\xCF\x2\xAD8\xADA\x5\x1A4\xD3\x2\xAD9\xAD7\x3\x2\x2"+
		"\x2\xAD9\xAD8\x3\x2\x2\x2\xADA\x199\x3\x2\x2\x2\xADB\xADC\a\xC1\x2\x2"+
		"\xADC\xAE3\a\x95\x2\x2\xADD\xAE4\x5\x118\x8D\x2\xADE\xAE0\a\x8F\x2\x2"+
		"\xADF\xAE1\x5\x19E\xD0\x2\xAE0\xADF\x3\x2\x2\x2\xAE0\xAE1\x3\x2\x2\x2"+
		"\xAE1\xAE2\x3\x2\x2\x2\xAE2\xAE4\a\x90\x2\x2\xAE3\xADD\x3\x2\x2\x2\xAE3"+
		"\xADE\x3\x2\x2\x2\xAE4\x19B\x3\x2\x2\x2\xAE5\xAE6\a\xC1\x2\x2\xAE6\xAED"+
		"\a\x95\x2\x2\xAE7\xAEE\x5\x1A2\xD2\x2\xAE8\xAEA\a\x8F\x2\x2\xAE9\xAEB"+
		"\x5\x1A0\xD1\x2\xAEA\xAE9\x3\x2\x2\x2\xAEA\xAEB\x3\x2\x2\x2\xAEB\xAEC"+
		"\x3\x2\x2\x2\xAEC\xAEE\a\x90\x2\x2\xAED\xAE7\x3\x2\x2\x2\xAED\xAE8\x3"+
		"\x2\x2\x2\xAEE\x19D\x3\x2\x2\x2\xAEF\xAF4\x5\x118\x8D\x2\xAF0\xAF1\a\x96"+
		"\x2\x2\xAF1\xAF3\x5\x118\x8D\x2\xAF2\xAF0\x3\x2\x2\x2\xAF3\xAF6\x3\x2"+
		"\x2\x2\xAF4\xAF2\x3\x2\x2\x2\xAF4\xAF5\x3\x2\x2\x2\xAF5\x19F\x3\x2\x2"+
		"\x2\xAF6\xAF4\x3\x2\x2\x2\xAF7\xAFC\x5\x1A4\xD3\x2\xAF8\xAF9\a\x96\x2"+
		"\x2\xAF9\xAFB\x5\x1A4\xD3\x2\xAFA\xAF8\x3\x2\x2\x2\xAFB\xAFE\x3\x2\x2"+
		"\x2\xAFC\xAFA\x3\x2\x2\x2\xAFC\xAFD\x3\x2\x2\x2\xAFD\x1A1\x3\x2\x2\x2"+
		"\xAFE\xAFC\x3\x2\x2\x2\xAFF\xB0A\x5\x1A8\xD5\x2\xB00\xB0A\x5\x1C4\xE3"+
		"\x2\xB01\xB0A\x5\x1A6\xD4\x2\xB02\xB0A\x5\x1AE\xD8\x2\xB03\xB0A\x5\x1AC"+
		"\xD7\x2\xB04\xB0A\x5\x1B0\xD9\x2\xB05\xB0A\x5\x1B2\xDA\x2\xB06\xB0A\x5"+
		"\x1B4\xDB\x2\xB07\xB0A\a\xA3\x2\x2\xB08\xB0A\x5\x188\xC5\x2\xB09\xAFF"+
		"\x3\x2\x2\x2\xB09\xB00\x3\x2\x2\x2\xB09\xB01\x3\x2\x2\x2\xB09\xB02\x3"+
		"\x2\x2\x2\xB09\xB03\x3\x2\x2\x2\xB09\xB04\x3\x2\x2\x2\xB09\xB05\x3\x2"+
		"\x2\x2\xB09\xB06\x3\x2\x2\x2\xB09\xB07\x3\x2\x2\x2\xB09\xB08\x3\x2\x2"+
		"\x2\xB0A\x1A3\x3\x2\x2\x2\xB0B\xB0E\x5\x1AA\xD6\x2\xB0C\xB0E\x5\x1A2\xD2"+
		"\x2\xB0D\xB0B\x3\x2\x2\x2\xB0D\xB0C\x3\x2\x2\x2\xB0E\x1A5\x3\x2\x2\x2"+
		"\xB0F\xB15\x5\x118\x8D\x2\xB10\xB16\a\x38\x2\x2\xB11\xB16\a\x39\x2\x2"+
		"\xB12\xB16\a\x66\x2\x2\xB13\xB16\a\x65\x2\x2\xB14\xB16\a\x64\x2\x2\xB15"+
		"\xB10\x3\x2\x2\x2\xB15\xB11\x3\x2\x2\x2\xB15\xB12\x3\x2\x2\x2\xB15\xB13"+
		"\x3\x2\x2\x2\xB15\xB14\x3\x2\x2\x2\xB15\xB16\x3\x2\x2\x2\xB16\x1A7\x3"+
		"\x2\x2\x2\xB17\xB18\aK\x2\x2\xB18\x1A9\x3\x2\x2\x2\xB19\xB1A\a\x33\x2"+
		"\x2\xB1A\x1AB\x3\x2\x2\x2\xB1B\xB1C\a\xA3\x2\x2\xB1C\xB20\a\x9B\x2\x2"+
		"\xB1D\xB21\x5\x1D6\xEC\x2\xB1E\xB21\a\xC1\x2\x2\xB1F\xB21\x5\x1D8\xED"+
		"\x2\xB20\xB1D\x3\x2\x2\x2\xB20\xB1E\x3\x2\x2\x2\xB20\xB1F\x3\x2\x2\x2"+
		"\xB21\x1AD\x3\x2\x2\x2\xB22\xB26\x5\x1D6\xEC\x2\xB23\xB26\a\xC1\x2\x2"+
		"\xB24\xB26\x5\x1D8\xED\x2\xB25\xB22\x3\x2\x2\x2\xB25\xB23\x3\x2\x2\x2"+
		"\xB25\xB24\x3\x2\x2\x2\xB26\xB27\x3\x2\x2\x2\xB27\xB2B\a\x95\x2\x2\xB28"+
		"\xB2C\x5\x1D6\xEC\x2\xB29\xB2C\a\xC1\x2\x2\xB2A\xB2C\x5\x1D8\xED\x2\xB2B"+
		"\xB28\x3\x2\x2\x2\xB2B\xB29\x3\x2\x2\x2\xB2B\xB2A\x3\x2\x2\x2\xB2C\x1AF"+
		"\x3\x2\x2\x2\xB2D\xB31\x5\x1D6\xEC\x2\xB2E\xB31\a\xC1\x2\x2\xB2F\xB31"+
		"\x5\x1D8\xED\x2\xB30\xB2D\x3\x2\x2\x2\xB30\xB2E\x3\x2\x2\x2\xB30\xB2F"+
		"\x3\x2\x2\x2\xB31\xB32\x3\x2\x2\x2\xB32\xB33\a\x33\x2\x2\xB33\x1B1\x3"+
		"\x2\x2\x2\xB34\xB38\x5\x1D6\xEC\x2\xB35\xB38\a\xC1\x2\x2\xB36\xB38\x5"+
		"\x1D8\xED\x2\xB37\xB34\x3\x2\x2\x2\xB37\xB35\x3\x2\x2\x2\xB37\xB36\x3"+
		"\x2\x2\x2\xB38\xB39\x3\x2\x2\x2\xB39\xB3A\aJ\x2\x2\xB3A\x1B3\x3\x2\x2"+
		"\x2\xB3B\xB3C\a\x91\x2\x2\xB3C\xB41\x5\x1B6\xDC\x2\xB3D\xB3E\a\x96\x2"+
		"\x2\xB3E\xB40\x5\x1B6\xDC\x2\xB3F\xB3D\x3\x2\x2\x2\xB40\xB43\x3\x2\x2"+
		"\x2\xB41\xB3F\x3\x2\x2\x2\xB41\xB42\x3\x2\x2\x2\xB42\xB44\x3\x2\x2\x2"+
		"\xB43\xB41\x3\x2\x2\x2\xB44\xB45\a\x92\x2\x2\xB45\x1B5\x3\x2\x2\x2\xB46"+
		"\xB4A\x5\x1AE\xD8\x2\xB47\xB4A\x5\x1AC\xD7\x2\xB48\xB4A\x5\x1DC\xEF\x2"+
		"\xB49\xB46\x3\x2\x2\x2\xB49\xB47\x3\x2\x2\x2\xB49\xB48\x3\x2\x2\x2\xB4A"+
		"\x1B7\x3\x2\x2\x2\xB4B\xB50\x5\x1BA\xDE\x2\xB4C\xB4D\a\xB4\x2\x2\xB4D"+
		"\xB4F\x5\x1BA\xDE\x2\xB4E\xB4C\x3\x2\x2\x2\xB4F\xB52\x3\x2\x2\x2\xB50"+
		"\xB4E\x3\x2\x2\x2\xB50\xB51\x3\x2\x2\x2\xB51\x1B9\x3\x2\x2\x2\xB52\xB50"+
		"\x3\x2\x2\x2\xB53\xB64\x5\x1BC\xDF\x2\xB54\xB55\a\x91\x2\x2\xB55\xB56"+
		"\x5\x1D6\xEC\x2\xB56\xB58\a\x92\x2\x2\xB57\xB59\a\x8E\x2\x2\xB58\xB57"+
		"\x3\x2\x2\x2\xB58\xB59\x3\x2\x2\x2\xB59\xB65\x3\x2\x2\x2\xB5A\xB5D\a\x8F"+
		"\x2\x2\xB5B\xB5E\a\xC0\x2\x2\xB5C\xB5E\a\xBF\x2\x2\xB5D\xB5B\x3\x2\x2"+
		"\x2\xB5D\xB5C\x3\x2\x2\x2\xB5E\xB5F\x3\x2\x2\x2\xB5F\xB61\a\x90\x2\x2"+
		"\xB60\xB62\a\x8E\x2\x2\xB61\xB60\x3\x2\x2\x2\xB61\xB62\x3\x2\x2\x2\xB62"+
		"\xB65\x3\x2\x2\x2\xB63\xB65\a\x8E\x2\x2\xB64\xB54\x3\x2\x2\x2\xB64\xB5A"+
		"\x3\x2\x2\x2\xB64\xB63\x3\x2\x2\x2\xB64\xB65\x3\x2\x2\x2\xB65\x1BB\x3"+
		"\x2\x2\x2\xB66\xB6E\x5\x1BE\xE0\x2\xB67\xB68\a\xB8\x2\x2\xB68\xB6A\a\xB4"+
		"\x2\x2\xB69\xB6B\x5\x1BE\xE0\x2\xB6A\xB69\x3\x2\x2\x2\xB6A\xB6B\x3\x2"+
		"\x2\x2\xB6B\xB6D\x3\x2\x2\x2\xB6C\xB67\x3\x2\x2\x2\xB6D\xB70\x3\x2\x2"+
		"\x2\xB6E\xB6C\x3\x2\x2\x2\xB6E\xB6F\x3\x2\x2\x2\xB6F\x1BD\x3\x2\x2\x2"+
		"\xB70\xB6E\x3\x2\x2\x2\xB71\xBA5\a\xC1\x2\x2\xB72\xBA5\a\xBE\x2\x2\xB73"+
		"\xBA5\aV\x2\x2\xB74\xBA5\a\x19\x2\x2\xB75\xBA5\a\t\x2\x2\xB76\xBA5\a\r"+
		"\x2\x2\xB77\xBA5\a\x11\x2\x2\xB78\xBA5\a\x12\x2\x2\xB79\xBA5\a\x13\x2"+
		"\x2\xB7A\xBA5\a\x14\x2\x2\xB7B\xBA5\a\x15\x2\x2\xB7C\xBA5\a\x16\x2\x2"+
		"\xB7D\xBA5\a\x17\x2\x2\xB7E\xBA5\a\x18\x2\x2\xB7F\xBA5\a\x31\x2\x2\xB80"+
		"\xBA5\a\x32\x2\x2\xB81\xBA5\a\x33\x2\x2\xB82\xBA5\ax\x2\x2\xB83\xBA5\a"+
		"z\x2\x2\xB84\xBA5\a{\x2\x2\xB85\xBA5\a>\x2\x2\xB86\xBA5\a?\x2\x2\xB87"+
		"\xBA5\a@\x2\x2\xB88\xBA5\aU\x2\x2\xB89\xBA5\a\x41\x2\x2\xB8A\xBA5\a\x42"+
		"\x2\x2\xB8B\xBA5\a\x43\x2\x2\xB8C\xBA5\a\x44\x2\x2\xB8D\xBA5\a\x45\x2"+
		"\x2\xB8E\xBA5\aH\x2\x2\xB8F\xBA5\aJ\x2\x2\xB90\xBA5\aK\x2\x2\xB91\xBA5"+
		"\aL\x2\x2\xB92\xBA5\aM\x2\x2\xB93\xBA5\aN\x2\x2\xB94\xBA5\aQ\x2\x2\xB95"+
		"\xBA5\aS\x2\x2\xB96\xBA5\aT\x2\x2\xB97\xBA5\aW\x2\x2\xB98\xBA5\a\x4\x2"+
		"\x2\xB99\xBA5\a$\x2\x2\xB9A\xBA5\a%\x2\x2\xB9B\xBA5\a!\x2\x2\xB9C\xBA5"+
		"\a&\x2\x2\xB9D\xBA5\a#\x2\x2\xB9E\xBA5\as\x2\x2\xB9F\xBA5\at\x2\x2\xBA0"+
		"\xBA5\au\x2\x2\xBA1\xBA5\a\x7F\x2\x2\xBA2\xBA5\aw\x2\x2\xBA3\xBA5\ay\x2"+
		"\x2\xBA4\xB71\x3\x2\x2\x2\xBA4\xB72\x3\x2\x2\x2\xBA4\xB73\x3\x2\x2\x2"+
		"\xBA4\xB74\x3\x2\x2\x2\xBA4\xB75\x3\x2\x2\x2\xBA4\xB76\x3\x2\x2\x2\xBA4"+
		"\xB77\x3\x2\x2\x2\xBA4\xB78\x3\x2\x2\x2\xBA4\xB79\x3\x2\x2\x2\xBA4\xB7A"+
		"\x3\x2\x2\x2\xBA4\xB7B\x3\x2\x2\x2\xBA4\xB7C\x3\x2\x2\x2\xBA4\xB7D\x3"+
		"\x2\x2\x2\xBA4\xB7E\x3\x2\x2\x2\xBA4\xB7F\x3\x2\x2\x2\xBA4\xB80\x3\x2"+
		"\x2\x2\xBA4\xB81\x3\x2\x2\x2\xBA4\xB82\x3\x2\x2\x2\xBA4\xB83\x3\x2\x2"+
		"\x2\xBA4\xB84\x3\x2\x2\x2\xBA4\xB85\x3\x2\x2\x2\xBA4\xB86\x3\x2\x2\x2"+
		"\xBA4\xB87\x3\x2\x2\x2\xBA4\xB88\x3\x2\x2\x2\xBA4\xB89\x3\x2\x2\x2\xBA4"+
		"\xB8A\x3\x2\x2\x2\xBA4\xB8B\x3\x2\x2\x2\xBA4\xB8C\x3\x2\x2\x2\xBA4\xB8D"+
		"\x3\x2\x2\x2\xBA4\xB8E\x3\x2\x2\x2\xBA4\xB8F\x3\x2\x2\x2\xBA4\xB90\x3"+
		"\x2\x2\x2\xBA4\xB91\x3\x2\x2\x2\xBA4\xB92\x3\x2\x2\x2\xBA4\xB93\x3\x2"+
		"\x2\x2\xBA4\xB94\x3\x2\x2\x2\xBA4\xB95\x3\x2\x2\x2\xBA4\xB96\x3\x2\x2"+
		"\x2\xBA4\xB97\x3\x2\x2\x2\xBA4\xB98\x3\x2\x2\x2\xBA4\xB99\x3\x2\x2\x2"+
		"\xBA4\xB9A\x3\x2\x2\x2\xBA4\xB9B\x3\x2\x2\x2\xBA4\xB9C\x3\x2\x2\x2\xBA4"+
		"\xB9D\x3\x2\x2\x2\xBA4\xB9E\x3\x2\x2\x2\xBA4\xB9F\x3\x2\x2\x2\xBA4\xBA0"+
		"\x3\x2\x2\x2\xBA4\xBA1\x3\x2\x2\x2\xBA4\xBA2\x3\x2\x2\x2\xBA4\xBA3\x3"+
		"\x2\x2\x2\xBA5\x1BF\x3\x2\x2\x2\xBA6\xBAA\a\xC1\x2\x2\xBA7\xBAA\a\x31"+
		"\x2\x2\xBA8\xBAA\a\xBE\x2\x2\xBA9\xBA6\x3\x2\x2\x2\xBA9\xBA7\x3\x2\x2"+
		"\x2\xBA9\xBA8\x3\x2\x2\x2\xBAA\x1C1\x3\x2\x2\x2\xBAB\xBAE\a\xC1\x2\x2"+
		"\xBAC\xBAE\a\xBE\x2\x2\xBAD\xBAB\x3\x2\x2\x2\xBAD\xBAC\x3\x2\x2\x2\xBAE"+
		"\x1C3\x3\x2\x2\x2\xBAF\xBB1\x5\x1C6\xE4\x2\xBB0\xBB2\x5\x1C8\xE5\x2\xBB1"+
		"\xBB0\x3\x2\x2\x2\xBB1\xBB2\x3\x2\x2\x2\xBB2\xBB4\x3\x2\x2\x2\xBB3\xBB5"+
		"\x5\x1CA\xE6\x2\xBB4\xBB3\x3\x2\x2\x2\xBB4\xBB5\x3\x2\x2\x2\xBB5\xBB7"+
		"\x3\x2\x2\x2\xBB6\xBB8\x5\x1CC\xE7\x2\xBB7\xBB6\x3\x2\x2\x2\xBB7\xBB8"+
		"\x3\x2\x2\x2\xBB8\xBBA\x3\x2\x2\x2\xBB9\xBBB\x5\x1CE\xE8\x2\xBBA\xBB9"+
		"\x3\x2\x2\x2\xBBA\xBBB\x3\x2\x2\x2\xBBB\xBBD\x3\x2\x2\x2\xBBC\xBBE\x5"+
		"\x1D0\xE9\x2\xBBD\xBBC\x3\x2\x2\x2\xBBD\xBBE\x3\x2\x2\x2\xBBE\xBC0\x3"+
		"\x2\x2\x2\xBBF\xBC1\x5\x1D2\xEA\x2\xBC0\xBBF\x3\x2\x2\x2\xBC0\xBC1\x3"+
		"\x2\x2\x2\xBC1\xBC3\x3\x2\x2\x2\xBC2\xBC4\x5\x1D4\xEB\x2\xBC3\xBC2\x3"+
		"\x2\x2\x2\xBC3\xBC4\x3\x2\x2\x2\xBC4\xC0C\x3\x2\x2\x2\xBC5\xBC7\x5\x1C8"+
		"\xE5\x2\xBC6\xBC8\x5\x1CA\xE6\x2\xBC7\xBC6\x3\x2\x2\x2\xBC7\xBC8\x3\x2"+
		"\x2\x2\xBC8\xBCA\x3\x2\x2\x2\xBC9\xBCB\x5\x1CC\xE7\x2\xBCA\xBC9\x3\x2"+
		"\x2\x2\xBCA\xBCB\x3\x2\x2\x2\xBCB\xBCD\x3\x2\x2\x2\xBCC\xBCE\x5\x1CE\xE8"+
		"\x2\xBCD\xBCC\x3\x2\x2\x2\xBCD\xBCE\x3\x2\x2\x2\xBCE\xBD0\x3\x2\x2\x2"+
		"\xBCF\xBD1\x5\x1D0\xE9\x2\xBD0\xBCF\x3\x2\x2\x2\xBD0\xBD1\x3\x2\x2\x2"+
		"\xBD1\xBD3\x3\x2\x2\x2\xBD2\xBD4\x5\x1D2\xEA\x2\xBD3\xBD2\x3\x2\x2\x2"+
		"\xBD3\xBD4\x3\x2\x2\x2\xBD4\xBD6\x3\x2\x2\x2\xBD5\xBD7\x5\x1D4\xEB\x2"+
		"\xBD6\xBD5\x3\x2\x2\x2\xBD6\xBD7\x3\x2\x2\x2\xBD7\xC0C\x3\x2\x2\x2\xBD8"+
		"\xBDA\x5\x1CA\xE6\x2\xBD9\xBDB\x5\x1CC\xE7\x2\xBDA\xBD9\x3\x2\x2\x2\xBDA"+
		"\xBDB\x3\x2\x2\x2\xBDB\xBDD\x3\x2\x2\x2\xBDC\xBDE\x5\x1CE\xE8\x2\xBDD"+
		"\xBDC\x3\x2\x2\x2\xBDD\xBDE\x3\x2\x2\x2\xBDE\xBE0\x3\x2\x2\x2\xBDF\xBE1"+
		"\x5\x1D0\xE9\x2\xBE0\xBDF\x3\x2\x2\x2\xBE0\xBE1\x3\x2\x2\x2\xBE1\xBE3"+
		"\x3\x2\x2\x2\xBE2\xBE4\x5\x1D2\xEA\x2\xBE3\xBE2\x3\x2\x2\x2\xBE3\xBE4"+
		"\x3\x2\x2\x2\xBE4\xBE6\x3\x2\x2\x2\xBE5\xBE7\x5\x1D4\xEB\x2\xBE6\xBE5"+
		"\x3\x2\x2\x2\xBE6\xBE7\x3\x2\x2\x2\xBE7\xC0C\x3\x2\x2\x2\xBE8\xBEA\x5"+
		"\x1CC\xE7\x2\xBE9\xBEB\x5\x1CE\xE8\x2\xBEA\xBE9\x3\x2\x2\x2\xBEA\xBEB"+
		"\x3\x2\x2\x2\xBEB\xBED\x3\x2\x2\x2\xBEC\xBEE\x5\x1D0\xE9\x2\xBED\xBEC"+
		"\x3\x2\x2\x2\xBED\xBEE\x3\x2\x2\x2\xBEE\xBF0\x3\x2\x2\x2\xBEF\xBF1\x5"+
		"\x1D2\xEA\x2\xBF0\xBEF\x3\x2\x2\x2\xBF0\xBF1\x3\x2\x2\x2\xBF1\xBF3\x3"+
		"\x2\x2\x2\xBF2\xBF4\x5\x1D4\xEB\x2\xBF3\xBF2\x3\x2\x2\x2\xBF3\xBF4\x3"+
		"\x2\x2\x2\xBF4\xC0C\x3\x2\x2\x2\xBF5\xBF7\x5\x1CE\xE8\x2\xBF6\xBF8\x5"+
		"\x1D0\xE9\x2\xBF7\xBF6\x3\x2\x2\x2\xBF7\xBF8\x3\x2\x2\x2\xBF8\xBFA\x3"+
		"\x2\x2\x2\xBF9\xBFB\x5\x1D2\xEA\x2\xBFA\xBF9\x3\x2\x2\x2\xBFA\xBFB\x3"+
		"\x2\x2\x2\xBFB\xBFD\x3\x2\x2\x2\xBFC\xBFE\x5\x1D4\xEB\x2\xBFD\xBFC\x3"+
		"\x2\x2\x2\xBFD\xBFE\x3\x2\x2\x2\xBFE\xC0C\x3\x2\x2\x2\xBFF\xC01\x5\x1D0"+
		"\xE9\x2\xC00\xC02\x5\x1D2\xEA\x2\xC01\xC00\x3\x2\x2\x2\xC01\xC02\x3\x2"+
		"\x2\x2\xC02\xC04\x3\x2\x2\x2\xC03\xC05\x5\x1D4\xEB\x2\xC04\xC03\x3\x2"+
		"\x2\x2\xC04\xC05\x3\x2\x2\x2\xC05\xC0C\x3\x2\x2\x2\xC06\xC08\x5\x1D2\xEA"+
		"\x2\xC07\xC09\x5\x1D4\xEB\x2\xC08\xC07\x3\x2\x2\x2\xC08\xC09\x3\x2\x2"+
		"\x2\xC09\xC0C\x3\x2\x2\x2\xC0A\xC0C\x5\x1D4\xEB\x2\xC0B\xBAF\x3\x2\x2"+
		"\x2\xC0B\xBC5\x3\x2\x2\x2\xC0B\xBD8\x3\x2\x2\x2\xC0B\xBE8\x3\x2\x2\x2"+
		"\xC0B\xBF5\x3\x2\x2\x2\xC0B\xBFF\x3\x2\x2\x2\xC0B\xC06\x3\x2\x2\x2\xC0B"+
		"\xC0A\x3\x2\x2\x2\xC0C\x1C5\x3\x2\x2\x2\xC0D\xC11\x5\x1DC\xEF\x2\xC0E"+
		"\xC11\a\xC1\x2\x2\xC0F\xC11\x5\x1D8\xED\x2\xC10\xC0D\x3\x2\x2\x2\xC10"+
		"\xC0E\x3\x2\x2\x2\xC10\xC0F\x3\x2\x2\x2\xC11\xC12\x3\x2\x2\x2\xC12\xC13"+
		"\t\v\x2\x2\xC13\x1C7\x3\x2\x2\x2\xC14\xC18\x5\x1DC\xEF\x2\xC15\xC18\a"+
		"\xC1\x2\x2\xC16\xC18\x5\x1D8\xED\x2\xC17\xC14\x3\x2\x2\x2\xC17\xC15\x3"+
		"\x2\x2\x2\xC17\xC16\x3\x2\x2\x2\xC18\xC19\x3\x2\x2\x2\xC19\xC1A\t\f\x2"+
		"\x2\xC1A\x1C9\x3\x2\x2\x2\xC1B\xC1F\x5\x1DC\xEF\x2\xC1C\xC1F\a\xC1\x2"+
		"\x2\xC1D\xC1F\x5\x1D8\xED\x2\xC1E\xC1B\x3\x2\x2\x2\xC1E\xC1C\x3\x2\x2"+
		"\x2\xC1E\xC1D\x3\x2\x2\x2\xC1F\xC20\x3\x2\x2\x2\xC20\xC21\t\r\x2\x2\xC21"+
		"\x1CB\x3\x2\x2\x2\xC22\xC26\x5\x1DC\xEF\x2\xC23\xC26\a\xC1\x2\x2\xC24"+
		"\xC26\x5\x1D8\xED\x2\xC25\xC22\x3\x2\x2\x2\xC25\xC23\x3\x2\x2\x2\xC25"+
		"\xC24\x3\x2\x2\x2\xC26\xC27\x3\x2\x2\x2\xC27\xC28\t\xE\x2\x2\xC28\x1CD"+
		"\x3\x2\x2\x2\xC29\xC2D\x5\x1DC\xEF\x2\xC2A\xC2D\a\xC1\x2\x2\xC2B\xC2D"+
		"\x5\x1D8\xED\x2\xC2C\xC29\x3\x2\x2\x2\xC2C\xC2A\x3\x2\x2\x2\xC2C\xC2B"+
		"\x3\x2\x2\x2\xC2D\xC2E\x3\x2\x2\x2\xC2E\xC2F\t\xF\x2\x2\xC2F\x1CF\x3\x2"+
		"\x2\x2\xC30\xC34\x5\x1DC\xEF\x2\xC31\xC34\a\xC1\x2\x2\xC32\xC34\x5\x1D8"+
		"\xED\x2\xC33\xC30\x3\x2\x2\x2\xC33\xC31\x3\x2\x2\x2\xC33\xC32\x3\x2\x2"+
		"\x2\xC34\xC35\x3\x2\x2\x2\xC35\xC36\t\x10\x2\x2\xC36\x1D1\x3\x2\x2\x2"+
		"\xC37\xC3B\x5\x1DC\xEF\x2\xC38\xC3B\a\xC1\x2\x2\xC39\xC3B\x5\x1D8\xED"+
		"\x2\xC3A\xC37\x3\x2\x2\x2\xC3A\xC38\x3\x2\x2\x2\xC3A\xC39\x3\x2\x2\x2"+
		"\xC3B\xC3C\x3\x2\x2\x2\xC3C\xC3D\t\x11\x2\x2\xC3D\x1D3\x3\x2\x2\x2\xC3E"+
		"\xC42\x5\x1DC\xEF\x2\xC3F\xC42\a\xC1\x2\x2\xC40\xC42\x5\x1D8\xED\x2\xC41"+
		"\xC3E\x3\x2\x2\x2\xC41\xC3F\x3\x2\x2\x2\xC41\xC40\x3\x2\x2\x2\xC42\xC43"+
		"\x3\x2\x2\x2\xC43\xC44\t\x12\x2\x2\xC44\x1D5\x3\x2\x2\x2\xC45\xC46\t\x13"+
		"\x2\x2\xC46\x1D7\x3\x2\x2\x2\xC47\xC4A\a\x8E\x2\x2\xC48\xC49\a\x95\x2"+
		"\x2\xC49\xC4B\x5\x190\xC9\x2\xC4A\xC48\x3\x2\x2\x2\xC4A\xC4B\x3\x2\x2"+
		"\x2\xC4B\x1D9\x3\x2\x2\x2\xC4C\xC52\x5\x1DC\xEF\x2\xC4D\xC52\x5\x1DE\xF0"+
		"\x2\xC4E\xC52\aj\x2\x2\xC4F\xC52\ak\x2\x2\xC50\xC52\al\x2\x2\xC51\xC4C"+
		"\x3\x2\x2\x2\xC51\xC4D\x3\x2\x2\x2\xC51\xC4E\x3\x2\x2\x2\xC51\xC4F\x3"+
		"\x2\x2\x2\xC51\xC50\x3\x2\x2\x2\xC52\x1DB\x3\x2\x2\x2\xC53\xC56\a\xA0"+
		"\x2\x2\xC54\xC56\a\x9D\x2\x2\xC55\xC53\x3\x2\x2\x2\xC55\xC54\x3\x2\x2"+
		"\x2\xC55\xC56\x3\x2\x2\x2\xC56\xC57\x3\x2\x2\x2\xC57\xC58\x5\x1D6\xEC"+
		"\x2\xC58\x1DD\x3\x2\x2\x2\xC59\xC5C\a\xC0\x2\x2\xC5A\xC5C\a\xBF\x2\x2"+
		"\xC5B\xC59\x3\x2\x2\x2\xC5B\xC5A\x3\x2\x2\x2\xC5C\x1DF\x3\x2\x2\x2\xC5D"+
		"\xC61\x5\x1DA\xEE\x2\xC5E\xC61\x5\x1E2\xF2\x2\xC5F\xC61\x5\x1E4\xF3\x2"+
		"\xC60\xC5D\x3\x2\x2\x2\xC60\xC5E\x3\x2\x2\x2\xC60\xC5F\x3\x2\x2\x2\xC61"+
		"\x1E1\x3\x2\x2\x2\xC62\xC63\a\x93\x2\x2\xC63\xC64\x5\x1E8\xF5\x2\xC64"+
		"\xC65\a\x94\x2\x2\xC65\x1E3\x3\x2\x2\x2\xC66\xC68\a\x91\x2\x2\xC67\xC69"+
		"\x5\x1E6\xF4\x2\xC68\xC67\x3\x2\x2\x2\xC68\xC69\x3\x2\x2\x2\xC69\xC6A"+
		"\x3\x2\x2\x2\xC6A\xC6B\a\x92\x2\x2\xC6B\x1E5\x3\x2\x2\x2\xC6C\xC71\x5"+
		"\x1E0\xF1\x2\xC6D\xC6E\a\x96\x2\x2\xC6E\xC70\x5\x1E0\xF1\x2\xC6F\xC6D"+
		"\x3\x2\x2\x2\xC70\xC73\x3\x2\x2\x2\xC71\xC6F\x3\x2\x2\x2\xC71\xC72\x3"+
		"\x2\x2\x2\xC72\xC75\x3\x2\x2\x2\xC73\xC71\x3\x2\x2\x2\xC74\xC76\a\x96"+
		"\x2\x2\xC75\xC74\x3\x2\x2\x2\xC75\xC76\x3\x2\x2\x2\xC76\x1E7\x3\x2\x2"+
		"\x2\xC77\xC7C\x5\x1EA\xF6\x2\xC78\xC79\a\x96\x2\x2\xC79\xC7B\x5\x1EA\xF6"+
		"\x2\xC7A\xC78\x3\x2\x2\x2\xC7B\xC7E\x3\x2\x2\x2\xC7C\xC7A\x3\x2\x2\x2"+
		"\xC7C\xC7D\x3\x2\x2\x2\xC7D\xC80\x3\x2\x2\x2\xC7E\xC7C\x3\x2\x2\x2\xC7F"+
		"\xC81\a\x96\x2\x2\xC80\xC7F\x3\x2\x2\x2\xC80\xC81\x3\x2\x2\x2\xC81\x1E9"+
		"\x3\x2\x2\x2\xC82\xC85\x5\x1DE\xF0\x2\xC83\xC85\x5\x1BE\xE0\x2\xC84\xC82"+
		"\x3\x2\x2\x2\xC84\xC83\x3\x2\x2\x2\xC85\xC86\x3\x2\x2\x2\xC86\xC87\a\x95"+
		"\x2\x2\xC87\xC88\x5\x1E0\xF1\x2\xC88\x1EB\x3\x2\x2\x2\x1C5\x1EE\x1F0\x1F8"+
		"\x1FA\x208\x20C\x20F\x214\x217\x21B\x224\x22D\x234\x23D\x240\x247\x253"+
		"\x25B\x25E\x261\x266\x276\x279\x280\x284\x28A\x28D\x291\x296\x29A\x29E"+
		"\x2A3\x2A7\x2B0\x2B3\x2B5\x2BA\x2BE\x2C3\x2CD\x2D3\x2D7\x2DD\x2E1\x2E6"+
		"\x2EA\x2F0\x2F5\x2FE\x303\x306\x30D\x312\x31A\x320\x326\x32A\x32E\x331"+
		"\x334\x338\x33C\x341\x345\x34A\x34E\x355\x35B\x363\x368\x36E\x378\x380"+
		"\x387\x392\x395\x399\x39C\x3A3\x3A8\x3AA\x3B0\x3B6\x3C5\x3CA\x3CE\x3D4"+
		"\x3D7\x3DC\x3E2\x3ED\x3F4\x3F7\x3FA\x3FE\x400\x406\x409\x410\x418\x41B"+
		"\x41D\x424\x42B\x431\x435\x43C\x441\x444\x449\x452\x456\x466\x46E\x474"+
		"\x479\x47C\x47F\x483\x486\x48C\x497\x49C\x49F\x4B1\x4B6\x4BE\x4C5\x4C9"+
		"\x4D0\x4DE\x4E0\x4E6\x4F5\x4F8\x4FD\x505\x50B\x50E\x513\x518\x51E\x525"+
		"\x52D\x535\x53C\x542\x544\x549\x551\x556\x55A\x55D\x564\x570\x57E\x583"+
		"\x58B\x591\x594\x59B\x5A1\x5A7\x5AE\x5B4\x5B7\x5BA\x5BF\x5C7\x5D3\x5D6"+
		"\x5DF\x5E5\x5E9\x5EC\x5EF\x5F9\x5FF\x607\x60A\x60F\x612\x616\x61C\x61F"+
		"\x625\x632\x637\x639\x642\x645\x64B\x64F\x658\x65E\x667\x674\x67B\x684"+
		"\x687\x68A\x691\x697\x69C\x6A2\x6A8\x6AB\x6B3\x6B9\x6BD\x6C0\x6C3\x6CA"+
		"\x6CE\x6D5\x6D9\x6DD\x6E1\x6E3\x6F4\x6F8\x6FB\x6FF\x702\x70D\x716\x71C"+
		"\x71E\x733\x73A\x740\x745\x74D\x750\x759\x762\x765\x767\x76A\x76E\x771"+
		"\x774\x77E\x78C\x78F\x79A\x79D\x7A3\x7AA\x7B2\x7BA\x7C0\x7C9\x7CF\x7D3"+
		"\x7D7\x7D9\x7DD\x7E5\x7EB\x7EF\x7F3\x7F5\x7F9\x7FD\x802\x80B\x80E\x812"+
		"\x81C\x820\x822\x82D\x830\x837\x83F\x84A\x858\x865\x868\x86C\x875\x87A"+
		"\x87D\x881\x889\x88F\x893\x89D\x8A4\x8A9\x8B4\x8B7\x8BC\x8C0\x8C8\x8CB"+
		"\x8CF\x8D4\x8DC\x8E5\x8ED\x8F5\x8FD\x90C\x916\x91A\x921\x925\x931\x94D"+
		"\x95E\x962\x96C\x96F\x974\x979\x97D\x981\x985\x98C\x994\x998\x99B\x9A0"+
		"\x9A3\x9A8\x9AE\x9BA\x9BD\x9C4\x9C8\x9D6\x9DE\x9E7\x9EF\x9F3\x9F8\x9FE"+
		"\xA01\xA03\xA0C\xA12\xA1A\xA23\xA29\xA2D\xA36\xA42\xA44\xA48\xA4E\xA53"+
		"\xA56\xA59\xA5F\xA64\xA68\xA6C\xA70\xA83\xA8B\xA8D\xA94\xA98\xA9D\xAA0"+
		"\xAA3\xAA6\xAAE\xAB5\xAB9\xAC0\xAC8\xAD0\xAD5\xAD9\xAE0\xAE3\xAEA\xAED"+
		"\xAF4\xAFC\xB09\xB0D\xB15\xB20\xB25\xB2B\xB30\xB37\xB41\xB49\xB50\xB58"+
		"\xB5D\xB61\xB64\xB6A\xB6E\xBA4\xBA9\xBAD\xBB1\xBB4\xBB7\xBBA\xBBD\xBC0"+
		"\xBC3\xBC7\xBCA\xBCD\xBD0\xBD3\xBD6\xBDA\xBDD\xBE0\xBE3\xBE6\xBEA\xBED"+
		"\xBF0\xBF3\xBF7\xBFA\xBFD\xC01\xC04\xC08\xC0B\xC10\xC17\xC1E\xC25\xC2C"+
		"\xC33\xC3A\xC41\xC4A\xC51\xC55\xC5B\xC60\xC68\xC71\xC75\xC7C\xC80\xC84";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace com.espertech.esper.epl.generated
